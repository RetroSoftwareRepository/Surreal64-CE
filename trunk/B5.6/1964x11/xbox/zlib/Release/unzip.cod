; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\unzip.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DOIEBMOI@1?41?44?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT @unzlocal_getByte@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzlocal_getShort@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzlocal_getLong@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @strcmpcasenosensitive_internal@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzStringFileNameCompare@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzlocal_SearchCentralDir@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzOpen@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzClose@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzGetGlobalInfo@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzlocal_DosDateToTmuDate@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzlocal_GetCurrentFileInfoInternal@36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzGetCurrentFileInfo@32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzGoToFirstFile@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzGoToNextFile@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzLocateFile@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzlocal_CheckCurrentFileCoherencyHeader@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzOpenCurrentFile@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzReadCurrentFile@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unztell@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzeof@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzGetLocalExtrafield@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzCloseCurrentFile@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @unzGetGlobalComment@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_unz_copyright
CONST	SEGMENT
_unz_copyright DB ' unzip 0.15 Copyright 1998 Gilles Vollant ', 00H
CONST	ENDS
EXTRN	_fread:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\unzip.c
;	COMDAT @unzlocal_getByte@8
_TEXT	SEGMENT
_c$ = -1						; size = 1
_pi$ = 8						; size = 4
@unzlocal_getByte@8 PROC NEAR				; COMDAT
; _fin$ = esi

; 139  : {

  00000	51		 push	 ecx

; 140  :     unsigned char c;
; 141  : 	int err = fread(&c, 1, 1, fin);

  00001	56		 push	 esi
  00002	6a 01		 push	 1
  00004	8d 44 24 0b	 lea	 eax, DWORD PTR _c$[esp+12]
  00008	6a 01		 push	 1
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _fread
  00010	83 c4 10	 add	 esp, 16			; 00000010H

; 142  :     if (err==1)

  00013	83 f8 01	 cmp	 eax, 1
  00016	75 11		 jne	 SHORT $L2096

; 143  :     {
; 144  :         *pi = (int)c;

  00018	0f b6 4c 24 03	 movzx	 ecx, BYTE PTR _c$[esp+4]
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR _pi$[esp]
  00021	89 0a		 mov	 DWORD PTR [edx], ecx

; 145  :         return UNZ_OK;

  00023	33 c0		 xor	 eax, eax

; 150  :             return UNZ_ERRNO;
; 151  :         else
; 152  :             return UNZ_EOF;
; 153  :     }
; 154  : }

  00025	59		 pop	 ecx
  00026	c2 04 00	 ret	 4
$L2096:

; 146  :     }
; 147  :     else
; 148  :     {
; 149  :         if (ferror(fin)) 

  00029	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  0002c	24 20		 and	 al, 32			; 00000020H
  0002e	f6 d8		 neg	 al
  00030	1b c0		 sbb	 eax, eax

; 150  :             return UNZ_ERRNO;
; 151  :         else
; 152  :             return UNZ_EOF;
; 153  :     }
; 154  : }

  00032	59		 pop	 ecx
  00033	c2 04 00	 ret	 4
@unzlocal_getByte@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @unzlocal_getShort@8
_TEXT	SEGMENT
_c$2669 = 8						; size = 1
_c$2660 = 8						; size = 1
_i$ = 8							; size = 4
_pX$ = 8						; size = 4
@unzlocal_getShort@8 PROC NEAR				; COMDAT
; _fin$ = edi

; 163  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _pX$[esp+4]
  00006	56		 push	 esi

; 164  :     uLong x ;
; 165  :     int i;
; 166  :     int err;
; 167  : 
; 168  :     err = unzlocal_getByte(fin,&i);

  00007	57		 push	 edi
  00008	6a 01		 push	 1
  0000a	8d 44 24 18	 lea	 eax, DWORD PTR _c$2660[esp+16]
  0000e	6a 01		 push	 1
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _fread
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	83 f8 01	 cmp	 eax, 1
  0001c	75 09		 jne	 SHORT $L2662
  0001e	0f b6 74 24 10	 movzx	 esi, BYTE PTR _c$2660[esp+8]
  00023	33 c0		 xor	 eax, eax
  00025	eb 0d		 jmp	 SHORT $L2664
$L2662:
  00027	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  0002a	8b 74 24 10	 mov	 esi, DWORD PTR _i$[esp+8]
  0002e	24 20		 and	 al, 32			; 00000020H
  00030	f6 d8		 neg	 al
  00032	1b c0		 sbb	 eax, eax
$L2664:

; 169  :     x = (uLong)i;
; 170  :     
; 171  :     if (err==UNZ_OK)

  00034	85 c0		 test	 eax, eax
  00036	8b de		 mov	 ebx, esi
  00038	75 37		 jne	 SHORT $L2112

; 172  :         err = unzlocal_getByte(fin,&i);

  0003a	57		 push	 edi
  0003b	6a 01		 push	 1
  0003d	8d 4c 24 18	 lea	 ecx, DWORD PTR _c$2669[esp+16]
  00041	6a 01		 push	 1
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _fread
  00049	83 c4 10	 add	 esp, 16			; 00000010H
  0004c	83 f8 01	 cmp	 eax, 1
  0004f	75 15		 jne	 SHORT $L2671
  00051	0f b6 74 24 10	 movzx	 esi, BYTE PTR _c$2669[esp+8]
$L2673:

; 173  :     x += ((uLong)i)<<8;

  00056	c1 e6 08	 shl	 esi, 8
  00059	33 c0		 xor	 eax, eax
  0005b	03 f3		 add	 esi, ebx

; 174  :    
; 175  :     if (err==UNZ_OK)
; 176  :         *pX = x;

  0005d	89 75 00	 mov	 DWORD PTR [ebp], esi
  00060	5e		 pop	 esi
  00061	5d		 pop	 ebp
  00062	5b		 pop	 ebx

; 179  :     return err;
; 180  : }

  00063	c2 04 00	 ret	 4

; 172  :         err = unzlocal_getByte(fin,&i);

$L2671:
  00066	f6 47 0c 20	 test	 BYTE PTR [edi+12], 32	; 00000020H
  0006a	74 ea		 je	 SHORT $L2673
  0006c	b8 ff ff ff ff	 mov	 eax, -1
$L2112:
  00071	5e		 pop	 esi

; 177  :     else
; 178  :         *pX = 0;

  00072	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0
  00079	5d		 pop	 ebp
  0007a	5b		 pop	 ebx

; 179  :     return err;
; 180  : }

  0007b	c2 04 00	 ret	 4
@unzlocal_getShort@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @unzlocal_getLong@8
_TEXT	SEGMENT
_c$2708 = 8						; size = 1
_c$2699 = 8						; size = 1
_c$2690 = 8						; size = 1
_c$2681 = 8						; size = 1
_i$ = 8							; size = 4
_pX$ = 8						; size = 4
@unzlocal_getLong@8 PROC NEAR				; COMDAT
; _fin$ = edi

; 185  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _pX$[esp+4]
  00006	56		 push	 esi

; 186  :     uLong x ;
; 187  :     int i;
; 188  :     int err;
; 189  : 
; 190  :     err = unzlocal_getByte(fin,&i);

  00007	57		 push	 edi
  00008	6a 01		 push	 1
  0000a	8d 44 24 18	 lea	 eax, DWORD PTR _c$2681[esp+16]
  0000e	6a 01		 push	 1
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _fread
  00016	83 c4 10	 add	 esp, 16			; 00000010H
  00019	83 f8 01	 cmp	 eax, 1
  0001c	75 09		 jne	 SHORT $L2683
  0001e	0f b6 74 24 10	 movzx	 esi, BYTE PTR _c$2681[esp+8]
  00023	33 c0		 xor	 eax, eax
  00025	eb 0d		 jmp	 SHORT $L2685
$L2683:
  00027	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  0002a	8b 74 24 10	 mov	 esi, DWORD PTR _i$[esp+8]
  0002e	24 20		 and	 al, 32			; 00000020H
  00030	f6 d8		 neg	 al
  00032	1b c0		 sbb	 eax, eax
$L2685:

; 191  :     x = (uLong)i;
; 192  :     
; 193  :     if (err==UNZ_OK)

  00034	85 c0		 test	 eax, eax
  00036	8b de		 mov	 ebx, esi
  00038	75 29		 jne	 SHORT $L2716

; 194  :         err = unzlocal_getByte(fin,&i);

  0003a	57		 push	 edi
  0003b	6a 01		 push	 1
  0003d	8d 4c 24 18	 lea	 ecx, DWORD PTR _c$2690[esp+16]
  00041	6a 01		 push	 1
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _fread
  00049	83 c4 10	 add	 esp, 16			; 00000010H
  0004c	83 f8 01	 cmp	 eax, 1
  0004f	75 09		 jne	 SHORT $L2692
  00051	0f b6 74 24 10	 movzx	 esi, BYTE PTR _c$2690[esp+8]
  00056	33 c0		 xor	 eax, eax
  00058	eb 09		 jmp	 SHORT $L2716
$L2692:
  0005a	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  0005d	24 20		 and	 al, 32			; 00000020H
  0005f	f6 d8		 neg	 al
  00061	1b c0		 sbb	 eax, eax
$L2716:

; 195  :     x += ((uLong)i)<<8;

  00063	8b d6		 mov	 edx, esi
  00065	c1 e2 08	 shl	 edx, 8
  00068	03 da		 add	 ebx, edx

; 196  : 
; 197  :     if (err==UNZ_OK)

  0006a	85 c0		 test	 eax, eax
  0006c	75 29		 jne	 SHORT $L2703

; 198  :         err = unzlocal_getByte(fin,&i);

  0006e	57		 push	 edi
  0006f	6a 01		 push	 1
  00071	8d 44 24 18	 lea	 eax, DWORD PTR _c$2699[esp+16]
  00075	6a 01		 push	 1
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _fread
  0007d	83 c4 10	 add	 esp, 16			; 00000010H
  00080	83 f8 01	 cmp	 eax, 1
  00083	75 09		 jne	 SHORT $L2701
  00085	0f b6 74 24 10	 movzx	 esi, BYTE PTR _c$2699[esp+8]
  0008a	33 c0		 xor	 eax, eax
  0008c	eb 09		 jmp	 SHORT $L2703
$L2701:
  0008e	8a 47 0c	 mov	 al, BYTE PTR [edi+12]
  00091	24 20		 and	 al, 32			; 00000020H
  00093	f6 d8		 neg	 al
  00095	1b c0		 sbb	 eax, eax
$L2703:

; 199  :     x += ((uLong)i)<<16;

  00097	8b ce		 mov	 ecx, esi
  00099	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0009c	03 d9		 add	 ebx, ecx

; 200  : 
; 201  :     if (err==UNZ_OK)

  0009e	85 c0		 test	 eax, eax
  000a0	75 37		 jne	 SHORT $L2129

; 202  :         err = unzlocal_getByte(fin,&i);

  000a2	57		 push	 edi
  000a3	6a 01		 push	 1
  000a5	8d 54 24 18	 lea	 edx, DWORD PTR _c$2708[esp+16]
  000a9	6a 01		 push	 1
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _fread
  000b1	83 c4 10	 add	 esp, 16			; 00000010H
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	75 15		 jne	 SHORT $L2710
  000b9	0f b6 74 24 10	 movzx	 esi, BYTE PTR _c$2708[esp+8]
$L2712:

; 203  :     x += ((uLong)i)<<24;

  000be	c1 e6 18	 shl	 esi, 24			; 00000018H
  000c1	33 c0		 xor	 eax, eax
  000c3	03 f3		 add	 esi, ebx

; 204  :    
; 205  :     if (err==UNZ_OK)
; 206  :         *pX = x;

  000c5	89 75 00	 mov	 DWORD PTR [ebp], esi
  000c8	5e		 pop	 esi
  000c9	5d		 pop	 ebp
  000ca	5b		 pop	 ebx

; 209  :     return err;
; 210  : }

  000cb	c2 04 00	 ret	 4

; 202  :         err = unzlocal_getByte(fin,&i);

$L2710:
  000ce	f6 47 0c 20	 test	 BYTE PTR [edi+12], 32	; 00000020H
  000d2	74 ea		 je	 SHORT $L2712
  000d4	b8 ff ff ff ff	 mov	 eax, -1
$L2129:
  000d9	5e		 pop	 esi

; 207  :     else
; 208  :         *pX = 0;

  000da	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0
  000e1	5d		 pop	 ebp
  000e2	5b		 pop	 ebx

; 209  :     return err;
; 210  : }

  000e3	c2 04 00	 ret	 4
@unzlocal_getLong@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @strcmpcasenosensitive_internal@8
_TEXT	SEGMENT
@strcmpcasenosensitive_internal@8 PROC NEAR		; COMDAT
; _fileName1$ = edx
; _fileName2$ = eax

; 217  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax
$L2137:

; 218  : 	for (;;)
; 219  : 	{
; 220  : 		char c1=*(fileName1++);

  00003	8a 0a		 mov	 cl, BYTE PTR [edx]

; 221  : 		char c2=*(fileName2++);

  00005	8a 06		 mov	 al, BYTE PTR [esi]
  00007	42		 inc	 edx
  00008	46		 inc	 esi

; 222  : 		if ((c1>='a') && (c1<='z'))

  00009	80 f9 61	 cmp	 cl, 97			; 00000061H
  0000c	7c 08		 jl	 SHORT $L2141
  0000e	80 f9 7a	 cmp	 cl, 122			; 0000007aH
  00011	7f 03		 jg	 SHORT $L2141

; 223  : 			c1 -= 0x20;

  00013	80 c1 e0	 add	 cl, -32			; ffffffe0H
$L2141:

; 224  : 		if ((c2>='a') && (c2<='z'))

  00016	3c 61		 cmp	 al, 97			; 00000061H
  00018	7c 06		 jl	 SHORT $L2142
  0001a	3c 7a		 cmp	 al, 122			; 0000007aH
  0001c	7f 02		 jg	 SHORT $L2142

; 225  : 			c2 -= 0x20;

  0001e	04 e0		 add	 al, -32			; ffffffe0H
$L2142:

; 226  : 		if (c1=='\0')

  00020	84 c9		 test	 cl, cl
  00022	74 11		 je	 SHORT $L2721

; 228  : 		if (c2=='\0')

  00024	84 c0		 test	 al, al
  00026	74 06		 je	 SHORT $L2724

; 229  : 			return 1;
; 230  : 		if (c1<c2)

  00028	3a c8		 cmp	 cl, al
  0002a	7c 0f		 jl	 SHORT $L2723

; 232  : 		if (c1>c2)

  0002c	7e d5		 jle	 SHORT $L2137
$L2724:

; 233  : 			return 1;

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	5e		 pop	 esi

; 234  : 	}
; 235  : }

  00034	c3		 ret	 0
$L2721:

; 227  : 			return ((c2=='\0') ? 0 : -1);

  00035	f6 d8		 neg	 al
  00037	5e		 pop	 esi
  00038	1b c0		 sbb	 eax, eax

; 234  : 	}
; 235  : }

  0003a	c3		 ret	 0
$L2723:

; 231  : 			return -1;

  0003b	83 c8 ff	 or	 eax, -1
  0003e	5e		 pop	 esi

; 234  : 	}
; 235  : }

  0003f	c3		 ret	 0
@strcmpcasenosensitive_internal@8 ENDP
_TEXT	ENDS
PUBLIC	@unzStringFileNameCompare@12
; Function compile flags: /Ogty
;	COMDAT @unzStringFileNameCompare@12
_TEXT	SEGMENT
_iCaseSensitivity$ = 8					; size = 4
@unzStringFileNameCompare@12 PROC NEAR			; COMDAT
; _fileName1$ = ecx
; _fileName2$ = edx

; 261  : {

  00000	8b c2		 mov	 eax, edx

; 262  : 	if (iCaseSensitivity==0)

  00002	8b 54 24 04	 mov	 edx, DWORD PTR _iCaseSensitivity$[esp-4]
  00006	85 d2		 test	 edx, edx

; 263  : 		iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;
; 264  : 
; 265  : 	if (iCaseSensitivity==1)

  00008	74 40		 je	 SHORT $L2155
  0000a	83 fa 01	 cmp	 edx, 1
  0000d	75 3b		 jne	 SHORT $L2155
  0000f	53		 push	 ebx
  00010	56		 push	 esi

; 266  : 		return strcmp(fileName1,fileName2);

  00011	8b f0		 mov	 esi, eax
  00013	8b c1		 mov	 eax, ecx
$L2728:
  00015	8a 10		 mov	 dl, BYTE PTR [eax]
  00017	8a 1e		 mov	 bl, BYTE PTR [esi]
  00019	8a ca		 mov	 cl, dl
  0001b	3a d3		 cmp	 dl, bl
  0001d	75 21		 jne	 SHORT $L2729
  0001f	84 c9		 test	 cl, cl
  00021	74 16		 je	 SHORT $L2730
  00023	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00026	8a 5e 01	 mov	 bl, BYTE PTR [esi+1]
  00029	8a ca		 mov	 cl, dl
  0002b	3a d3		 cmp	 dl, bl
  0002d	75 11		 jne	 SHORT $L2729
  0002f	83 c0 02	 add	 eax, 2
  00032	83 c6 02	 add	 esi, 2
  00035	84 c9		 test	 cl, cl
  00037	75 dc		 jne	 SHORT $L2728
$L2730:
  00039	5e		 pop	 esi
  0003a	33 c0		 xor	 eax, eax
  0003c	5b		 pop	 ebx

; 269  : } 

  0003d	c2 04 00	 ret	 4
$L2729:

; 266  : 		return strcmp(fileName1,fileName2);

  00040	1b c0		 sbb	 eax, eax
  00042	5e		 pop	 esi
  00043	83 d8 ff	 sbb	 eax, -1
  00046	5b		 pop	 ebx

; 269  : } 

  00047	c2 04 00	 ret	 4
$L2155:

; 267  : 
; 268  : 	return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);

  0004a	8b d1		 mov	 edx, ecx
  0004c	e8 00 00 00 00	 call	 @strcmpcasenosensitive_internal@8

; 269  : } 

  00051	c2 04 00	 ret	 4
@unzStringFileNameCompare@12 ENDP
_TEXT	ENDS
EXTRN	_malloc:NEAR
EXTRN	_fseek:NEAR
EXTRN	_ftell:NEAR
EXTRN	_free:NEAR
; Function compile flags: /Ogty
;	COMDAT @unzlocal_SearchCentralDir@4
_TEXT	SEGMENT
_uMaxBack$ = -12					; size = 4
_uPosFound$ = -8					; size = 4
_uSizeFile$ = -4					; size = 4
_fin$ = 8						; size = 4
@unzlocal_SearchCentralDir@4 PROC NEAR			; COMDAT

; 279  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	55		 push	 ebp
  00004	56		 push	 esi

; 280  : 	unsigned char* buf;
; 281  : 	uLong uSizeFile;
; 282  : 	uLong uBackRead;
; 283  : 	uLong uMaxBack=0xffff; /* maximum size of global comment */
; 284  : 	uLong uPosFound=0;
; 285  : 	
; 286  : 	if (fseek(fin,0,SEEK_END) != 0)

  00005	8b 74 24 18	 mov	 esi, DWORD PTR _fin$[esp+16]
  00009	6a 02		 push	 2
  0000b	6a 00		 push	 0
  0000d	bd ff ff 00 00	 mov	 ebp, 65535		; 0000ffffH
  00012	56		 push	 esi
  00013	89 6c 24 14	 mov	 DWORD PTR _uMaxBack$[esp+32], ebp
  00017	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _uPosFound$[esp+32], 0
  0001f	e8 00 00 00 00	 call	 _fseek
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	85 c0		 test	 eax, eax
  00029	74 0a		 je	 SHORT $L2166
  0002b	5e		 pop	 esi

; 287  : 		return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5d		 pop	 ebp

; 331  : }

  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	c2 04 00	 ret	 4
$L2166:
  00035	57		 push	 edi

; 288  : 
; 289  : 
; 290  : 	uSizeFile = ftell( fin );

  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _ftell
  0003c	8b f8		 mov	 edi, eax
  0003e	83 c4 04	 add	 esp, 4

; 291  : 	
; 292  : 	if (uMaxBack>uSizeFile)

  00041	81 ff ff ff 00
	00		 cmp	 edi, 65535		; 0000ffffH
  00047	89 7c 24 14	 mov	 DWORD PTR _uSizeFile$[esp+24], edi
  0004b	73 06		 jae	 SHORT $L2167

; 293  : 		uMaxBack = uSizeFile;

  0004d	89 7c 24 0c	 mov	 DWORD PTR _uMaxBack$[esp+24], edi
  00051	8b e8		 mov	 ebp, eax
$L2167:

; 294  : 
; 295  : 	buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);

  00053	68 04 04 00 00	 push	 1028			; 00000404H
  00058	e8 00 00 00 00	 call	 _malloc
  0005d	8b f0		 mov	 esi, eax
  0005f	83 c4 04	 add	 esp, 4

; 296  : 	if (buf==NULL)

  00062	85 f6		 test	 esi, esi
  00064	75 09		 jne	 SHORT $L2170
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp

; 331  : }

  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	c2 04 00	 ret	 4
$L2170:
  0006f	53		 push	 ebx

; 297  : 		return 0;
; 298  : 
; 299  : 	uBackRead = 4;

  00070	bb 04 00 00 00	 mov	 ebx, 4

; 300  : 	while (uBackRead<uMaxBack)

  00075	3b eb		 cmp	 ebp, ebx
  00077	0f 86 9f 00 00
	00		 jbe	 $L2745
  0007d	eb 11		 jmp	 SHORT $L2172
$L2744:
  0007f	8b 6c 24 10	 mov	 ebp, DWORD PTR _uMaxBack$[esp+28]
  00083	8b 7c 24 18	 mov	 edi, DWORD PTR _uSizeFile$[esp+28]
  00087	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L2172:

; 301  : 	{
; 302  : 		uLong uReadSize,uReadPos ;
; 303  : 		int i;
; 304  : 		if (uBackRead+BUFREADCOMMENT>uMaxBack) 

  00090	8d 83 00 04 00
	00		 lea	 eax, DWORD PTR [ebx+1024]
  00096	3b c5		 cmp	 eax, ebp

; 305  : 			uBackRead = uMaxBack;

  00098	8b dd		 mov	 ebx, ebp
  0009a	77 02		 ja	 SHORT $L2178

; 306  : 		else
; 307  : 			uBackRead+=BUFREADCOMMENT;

  0009c	8b d8		 mov	 ebx, eax
$L2178:

; 308  : 		uReadPos = uSizeFile-uBackRead ;

  0009e	8b ef		 mov	 ebp, edi
  000a0	2b eb		 sub	 ebp, ebx

; 309  : 		
; 310  : 		uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ? 
; 311  :                      (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);

  000a2	8b c7		 mov	 eax, edi
  000a4	2b c5		 sub	 eax, ebp
  000a6	3d 04 04 00 00	 cmp	 eax, 1028		; 00000404H
  000ab	bf 04 04 00 00	 mov	 edi, 1028		; 00000404H
  000b0	77 02		 ja	 SHORT $L2735
  000b2	8b f8		 mov	 edi, eax
$L2735:

; 312  : 		if (fseek(fin,uReadPos,SEEK_SET)!=0)

  000b4	8b 44 24 20	 mov	 eax, DWORD PTR _fin$[esp+24]
  000b8	6a 00		 push	 0
  000ba	55		 push	 ebp
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _fseek
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c4	85 c0		 test	 eax, eax
  000c6	75 54		 jne	 SHORT $L2745

; 313  : 			break;
; 314  : 
; 315  : 		if (fread(buf,(uInt)uReadSize,1,fin)!=1)

  000c8	8b 4c 24 20	 mov	 ecx, DWORD PTR _fin$[esp+24]
  000cc	51		 push	 ecx
  000cd	6a 01		 push	 1
  000cf	57		 push	 edi
  000d0	56		 push	 esi
  000d1	e8 00 00 00 00	 call	 _fread
  000d6	83 c4 10	 add	 esp, 16			; 00000010H
  000d9	83 f8 01	 cmp	 eax, 1
  000dc	75 3e		 jne	 SHORT $L2745

; 316  : 			break;
; 317  : 
; 318  :                 for (i=(int)uReadSize-3; (i--)>0;)

  000de	8d 47 fd	 lea	 eax, DWORD PTR [edi-3]
  000e1	85 c0		 test	 eax, eax
  000e3	7e 2d		 jle	 SHORT $L2743
$L2184:

; 319  : 			if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && 
; 320  : 				((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))

  000e5	8a 4c 30 ff	 mov	 cl, BYTE PTR [eax+esi-1]
  000e9	48		 dec	 eax
  000ea	80 f9 50	 cmp	 cl, 80			; 00000050H
  000ed	75 15		 jne	 SHORT $L2186
  000ef	80 7c 30 01 4b	 cmp	 BYTE PTR [eax+esi+1], 75 ; 0000004bH
  000f4	75 0e		 jne	 SHORT $L2186
  000f6	80 7c 30 02 05	 cmp	 BYTE PTR [eax+esi+2], 5
  000fb	75 07		 jne	 SHORT $L2186
  000fd	80 7c 30 03 06	 cmp	 BYTE PTR [eax+esi+3], 6
  00102	74 06		 je	 SHORT $L2738
$L2186:

; 316  : 			break;
; 317  : 
; 318  :                 for (i=(int)uReadSize-3; (i--)>0;)

  00104	85 c0		 test	 eax, eax
  00106	7f dd		 jg	 SHORT $L2184

; 323  : 				break;
; 324  : 			}
; 325  : 
; 326  : 		if (uPosFound!=0)

  00108	eb 08		 jmp	 SHORT $L2743
$L2738:

; 321  : 			{
; 322  : 				uPosFound = uReadPos+i;

  0010a	03 c5		 add	 eax, ebp
  0010c	89 44 24 14	 mov	 DWORD PTR _uPosFound$[esp+28], eax

; 323  : 				break;
; 324  : 			}
; 325  : 
; 326  : 		if (uPosFound!=0)

  00110	75 0a		 jne	 SHORT $L2745
$L2743:

; 300  : 	while (uBackRead<uMaxBack)

  00112	3b 5c 24 10	 cmp	 ebx, DWORD PTR _uMaxBack$[esp+28]
  00116	0f 82 63 ff ff
	ff		 jb	 $L2744
$L2745:

; 327  : 			break;
; 328  : 	}
; 329  : 	TRYFREE(buf);

  0011c	56		 push	 esi
  0011d	e8 00 00 00 00	 call	 _free

; 330  : 	return uPosFound;

  00122	8b 44 24 18	 mov	 eax, DWORD PTR _uPosFound$[esp+32]
  00126	83 c4 04	 add	 esp, 4
  00129	5b		 pop	 ebx
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	5d		 pop	 ebp

; 331  : }

  0012d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00130	c2 04 00	 ret	 4
@unzlocal_SearchCentralDir@4 ENDP
_TEXT	ENDS
PUBLIC	@unzGetGlobalInfo@8
; Function compile flags: /Ogty
;	COMDAT @unzGetGlobalInfo@8
_TEXT	SEGMENT
@unzGetGlobalInfo@8 PROC NEAR				; COMDAT
; _file$ = ecx
; _pglobal_info$ = edx

; 466  : 	unz_s* s;
; 467  : 	if (file==NULL)

  00000	85 c9		 test	 ecx, ecx
  00002	75 06		 jne	 SHORT $L2243

; 468  : 		return UNZ_PARAMERROR;

  00004	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH

; 472  : }

  00009	c3		 ret	 0
$L2243:

; 469  : 	s=(unz_s*)file;
; 470  : 	*pglobal_info=s->gi;

  0000a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000d	89 02		 mov	 DWORD PTR [edx], eax
  0000f	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00012	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 471  : 	return UNZ_OK;

  00015	33 c0		 xor	 eax, eax

; 472  : }

  00017	c3		 ret	 0
@unzGetGlobalInfo@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @unzlocal_DosDateToTmuDate@8
_TEXT	SEGMENT
@unzlocal_DosDateToTmuDate@8 PROC NEAR			; COMDAT
; _ulDosDate$ = ecx
; _ptm$ = edx

; 481  : {

  00000	56		 push	 esi

; 482  :     uLong uDate;
; 483  :     uDate = (uLong)(ulDosDate>>16);

  00001	8b c1		 mov	 eax, ecx
  00003	c1 e8 10	 shr	 eax, 16			; 00000010H

; 484  :     ptm->tm_mday = (uInt)(uDate&0x1f) ;

  00006	8b f0		 mov	 esi, eax
  00008	83 e6 1f	 and	 esi, 31			; 0000001fH
  0000b	89 72 0c	 mov	 DWORD PTR [edx+12], esi

; 485  :     ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;

  0000e	8b f0		 mov	 esi, eax

; 486  :     ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;

  00010	c1 e8 09	 shr	 eax, 9
  00013	83 e0 7f	 and	 eax, 127		; 0000007fH
  00016	05 bc 07 00 00	 add	 eax, 1980		; 000007bcH
  0001b	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 487  : 
; 488  :     ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);

  0001e	8b c1		 mov	 eax, ecx
  00020	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00023	83 e0 1f	 and	 eax, 31			; 0000001fH
  00026	c1 ee 05	 shr	 esi, 5
  00029	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 489  :     ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;

  0002c	8b c1		 mov	 eax, ecx
  0002e	83 e6 0f	 and	 esi, 15			; 0000000fH
  00031	4e		 dec	 esi
  00032	c1 e8 05	 shr	 eax, 5

; 490  :     ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;

  00035	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00038	83 e0 3f	 and	 eax, 63			; 0000003fH
  0003b	d1 e1		 shl	 ecx, 1
  0003d	89 72 10	 mov	 DWORD PTR [edx+16], esi
  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00043	89 0a		 mov	 DWORD PTR [edx], ecx
  00045	5e		 pop	 esi

; 491  : }

  00046	c3		 ret	 0
@unzlocal_DosDateToTmuDate@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @unzlocal_GetCurrentFileInfoInternal@36
_TEXT	SEGMENT
_file_info_internal$ = -84				; size = 4
_uMagic$ = -84						; size = 4
_file_info$ = -80					; size = 80
_file$ = 8						; size = 4
_pfile_info$ = 12					; size = 4
_pfile_info_internal$ = 16				; size = 4
_szFileName$ = 20					; size = 4
_fileNameBufferSize$ = 24				; size = 4
_extraField$ = 28					; size = 4
_extraFieldBufferSize$ = 32				; size = 4
_szComment$ = 36					; size = 4
_commentBufferSize$ = 40				; size = 4
@unzlocal_GetCurrentFileInfoInternal@36 PROC NEAR	; COMDAT

; 522  : {

  00000	83 ec 54	 sub	 esp, 84			; 00000054H
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 523  : 	unz_s* s;
; 524  : 	unz_file_info file_info;
; 525  : 	unz_file_info_internal file_info_internal;
; 526  : 	int err=UNZ_OK;
; 527  : 	uLong uMagic;
; 528  : 	long lSeek=0;
; 529  : 
; 530  : 	if (file==NULL)

  00005	8b 6c 24 60	 mov	 ebp, DWORD PTR _file$[esp+88]
  00009	33 db		 xor	 ebx, ebx
  0000b	85 ed		 test	 ebp, ebp
  0000d	75 0d		 jne	 SHORT $L2295
  0000f	5d		 pop	 ebp

; 531  : 		return UNZ_PARAMERROR;

  00010	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00015	5b		 pop	 ebx

; 663  : }

  00016	83 c4 54	 add	 esp, 84			; 00000054H
  00019	c2 24 00	 ret	 36			; 00000024H
$L2295:

; 532  : 	s=(unz_s*)file;
; 533  : 	if (fseek(s->file,s->pos_in_central_dir+s->byte_before_the_zipfile,SEEK_SET)!=0)

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  0001f	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	03 c1		 add	 eax, ecx
  00026	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00029	6a 00		 push	 0
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _fseek
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	85 c0		 test	 eax, eax
  00037	74 05		 je	 SHORT $L2758

; 534  : 		err=UNZ_ERRNO;

  00039	83 cb ff	 or	 ebx, -1

; 535  : 
; 536  : 
; 537  : 	/* we check the magic */
; 538  : 	if (err==UNZ_OK)

  0003c	eb 25		 jmp	 SHORT $L2762
$L2758:

; 539  : 		if (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)

  0003e	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00041	8d 54 24 10	 lea	 edx, DWORD PTR _uMagic$[esp+100]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  0004b	85 c0		 test	 eax, eax
  0004d	74 05		 je	 SHORT $L2299

; 540  : 			err=UNZ_ERRNO;

  0004f	83 cb ff	 or	 ebx, -1

; 541  : 		else if (uMagic!=0x02014b50)

  00052	eb 0f		 jmp	 SHORT $L2762
$L2299:
  00054	81 7c 24 10 50
	4b 01 02	 cmp	 DWORD PTR _uMagic$[esp+100], 33639248 ; 02014b50H
  0005c	74 05		 je	 SHORT $L2762

; 542  : 			err=UNZ_BADZIPFILE;

  0005e	bb 99 ff ff ff	 mov	 ebx, -103		; ffffff99H
$L2762:

; 543  : 
; 544  : 	if (unzlocal_getShort(s->file,&file_info.version) != UNZ_OK)

  00063	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00066	8d 44 24 14	 lea	 eax, DWORD PTR _file_info$[esp+100]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00070	85 c0		 test	 eax, eax
  00072	74 03		 je	 SHORT $L2769

; 545  : 		err=UNZ_ERRNO;

  00074	83 cb ff	 or	 ebx, -1
$L2769:

; 546  : 
; 547  : 	if (unzlocal_getShort(s->file,&file_info.version_needed) != UNZ_OK)

  00077	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  0007a	8d 4c 24 18	 lea	 ecx, DWORD PTR _file_info$[esp+104]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00084	85 c0		 test	 eax, eax
  00086	74 03		 je	 SHORT $L2770

; 548  : 		err=UNZ_ERRNO;

  00088	83 cb ff	 or	 ebx, -1
$L2770:

; 549  : 
; 550  : 	if (unzlocal_getShort(s->file,&file_info.flag) != UNZ_OK)

  0008b	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  0008e	8d 54 24 1c	 lea	 edx, DWORD PTR _file_info$[esp+108]
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00098	85 c0		 test	 eax, eax
  0009a	74 03		 je	 SHORT $L2771

; 551  : 		err=UNZ_ERRNO;

  0009c	83 cb ff	 or	 ebx, -1
$L2771:

; 552  : 
; 553  : 	if (unzlocal_getShort(s->file,&file_info.compression_method) != UNZ_OK)

  0009f	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  000a2	8d 44 24 20	 lea	 eax, DWORD PTR _file_info$[esp+112]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  000ac	85 c0		 test	 eax, eax
  000ae	74 03		 je	 SHORT $L2772

; 554  : 		err=UNZ_ERRNO;

  000b0	83 cb ff	 or	 ebx, -1
$L2772:

; 555  : 
; 556  : 	if (unzlocal_getLong(s->file,&file_info.dosDate) != UNZ_OK)

  000b3	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  000b6	8d 4c 24 24	 lea	 ecx, DWORD PTR _file_info$[esp+116]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  000c0	85 c0		 test	 eax, eax
  000c2	74 03		 je	 SHORT $L2773

; 557  : 		err=UNZ_ERRNO;

  000c4	83 cb ff	 or	 ebx, -1
$L2773:

; 558  : 
; 559  :     unzlocal_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);

  000c7	8b 4c 24 24	 mov	 ecx, DWORD PTR _file_info$[esp+116]

; 560  : 
; 561  : 	if (unzlocal_getLong(s->file,&file_info.crc) != UNZ_OK)

  000cb	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  000ce	8b c1		 mov	 eax, ecx
  000d0	c1 e8 10	 shr	 eax, 16			; 00000010H
  000d3	8b d0		 mov	 edx, eax
  000d5	83 e2 1f	 and	 edx, 31			; 0000001fH
  000d8	89 54 24 58	 mov	 DWORD PTR _file_info$[esp+168], edx
  000dc	8b d0		 mov	 edx, eax
  000de	c1 e8 09	 shr	 eax, 9
  000e1	83 e0 7f	 and	 eax, 127		; 0000007fH
  000e4	c1 ea 05	 shr	 edx, 5
  000e7	05 bc 07 00 00	 add	 eax, 1980		; 000007bcH
  000ec	83 e2 0f	 and	 edx, 15			; 0000000fH
  000ef	89 44 24 60	 mov	 DWORD PTR _file_info$[esp+176], eax
  000f3	4a		 dec	 edx
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 54 24 5c	 mov	 DWORD PTR _file_info$[esp+172], edx
  000fa	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  000fd	8b d1		 mov	 edx, ecx
  000ff	83 e0 1f	 and	 eax, 31			; 0000001fH
  00102	89 44 24 54	 mov	 DWORD PTR _file_info$[esp+164], eax
  00106	c1 ea 05	 shr	 edx, 5
  00109	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0010c	8d 44 24 28	 lea	 eax, DWORD PTR _file_info$[esp+120]
  00110	83 e2 3f	 and	 edx, 63			; 0000003fH
  00113	d1 e1		 shl	 ecx, 1
  00115	50		 push	 eax
  00116	89 54 24 54	 mov	 DWORD PTR _file_info$[esp+164], edx
  0011a	89 4c 24 50	 mov	 DWORD PTR _file_info$[esp+160], ecx
  0011e	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  00123	85 c0		 test	 eax, eax
  00125	74 03		 je	 SHORT $L2774

; 562  : 		err=UNZ_ERRNO;

  00127	83 cb ff	 or	 ebx, -1
$L2774:

; 563  : 
; 564  : 	if (unzlocal_getLong(s->file,&file_info.compressed_size) != UNZ_OK)

  0012a	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  0012d	8d 4c 24 2c	 lea	 ecx, DWORD PTR _file_info$[esp+124]
  00131	51		 push	 ecx
  00132	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  00137	85 c0		 test	 eax, eax
  00139	74 03		 je	 SHORT $L2775

; 565  : 		err=UNZ_ERRNO;

  0013b	83 cb ff	 or	 ebx, -1
$L2775:

; 566  : 
; 567  : 	if (unzlocal_getLong(s->file,&file_info.uncompressed_size) != UNZ_OK)

  0013e	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00141	8d 54 24 30	 lea	 edx, DWORD PTR _file_info$[esp+128]
  00145	52		 push	 edx
  00146	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  0014b	85 c0		 test	 eax, eax
  0014d	74 03		 je	 SHORT $L2776

; 568  : 		err=UNZ_ERRNO;

  0014f	83 cb ff	 or	 ebx, -1
$L2776:

; 569  : 
; 570  : 	if (unzlocal_getShort(s->file,&file_info.size_filename) != UNZ_OK)

  00152	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00155	8d 44 24 34	 lea	 eax, DWORD PTR _file_info$[esp+132]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  0015f	85 c0		 test	 eax, eax
  00161	74 03		 je	 SHORT $L2777

; 571  : 		err=UNZ_ERRNO;

  00163	83 cb ff	 or	 ebx, -1
$L2777:

; 572  : 
; 573  : 	if (unzlocal_getShort(s->file,&file_info.size_file_extra) != UNZ_OK)

  00166	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00169	8d 4c 24 38	 lea	 ecx, DWORD PTR _file_info$[esp+136]
  0016d	51		 push	 ecx
  0016e	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00173	85 c0		 test	 eax, eax
  00175	74 03		 je	 SHORT $L2778

; 574  : 		err=UNZ_ERRNO;

  00177	83 cb ff	 or	 ebx, -1
$L2778:

; 575  : 
; 576  : 	if (unzlocal_getShort(s->file,&file_info.size_file_comment) != UNZ_OK)

  0017a	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  0017d	8d 54 24 3c	 lea	 edx, DWORD PTR _file_info$[esp+140]
  00181	52		 push	 edx
  00182	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00187	85 c0		 test	 eax, eax
  00189	74 03		 je	 SHORT $L2779

; 577  : 		err=UNZ_ERRNO;

  0018b	83 cb ff	 or	 ebx, -1
$L2779:

; 578  : 
; 579  : 	if (unzlocal_getShort(s->file,&file_info.disk_num_start) != UNZ_OK)

  0018e	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00191	8d 44 24 40	 lea	 eax, DWORD PTR _file_info$[esp+144]
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  0019b	85 c0		 test	 eax, eax
  0019d	74 03		 je	 SHORT $L2780

; 580  : 		err=UNZ_ERRNO;

  0019f	83 cb ff	 or	 ebx, -1
$L2780:

; 581  : 
; 582  : 	if (unzlocal_getShort(s->file,&file_info.internal_fa) != UNZ_OK)

  001a2	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  001a5	8d 4c 24 44	 lea	 ecx, DWORD PTR _file_info$[esp+148]
  001a9	51		 push	 ecx
  001aa	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  001af	85 c0		 test	 eax, eax
  001b1	74 03		 je	 SHORT $L2781

; 583  : 		err=UNZ_ERRNO;

  001b3	83 cb ff	 or	 ebx, -1
$L2781:

; 584  : 
; 585  : 	if (unzlocal_getLong(s->file,&file_info.external_fa) != UNZ_OK)

  001b6	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  001b9	8d 54 24 48	 lea	 edx, DWORD PTR _file_info$[esp+152]
  001bd	52		 push	 edx
  001be	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  001c3	85 c0		 test	 eax, eax
  001c5	74 03		 je	 SHORT $L2782

; 586  : 		err=UNZ_ERRNO;

  001c7	83 cb ff	 or	 ebx, -1
$L2782:

; 587  : 
; 588  : 	if (unzlocal_getLong(s->file,&file_info_internal.offset_curfile) != UNZ_OK)

  001ca	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  001cd	8d 44 24 10	 lea	 eax, DWORD PTR _file_info_internal$[esp+100]
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  001d7	85 c0		 test	 eax, eax
  001d9	74 03		 je	 SHORT $L2316

; 589  : 		err=UNZ_ERRNO;

  001db	83 cb ff	 or	 ebx, -1
$L2316:

; 590  : 
; 591  : 	lSeek+=file_info.size_filename;
; 592  : 	if ((err==UNZ_OK) && (szFileName!=NULL))

  001de	85 db		 test	 ebx, ebx
  001e0	8b 74 24 34	 mov	 esi, DWORD PTR _file_info$[esp+132]
  001e4	0f 85 ad 00 00
	00		 jne	 $L2326
  001ea	8b 44 24 74	 mov	 eax, DWORD PTR _szFileName$[esp+96]
  001ee	85 c0		 test	 eax, eax
  001f0	74 37		 je	 SHORT $L2764

; 593  : 	{
; 594  : 		uLong uSizeRead ;
; 595  : 		if (file_info.size_filename<fileNameBufferSize)

  001f2	8b 4c 24 78	 mov	 ecx, DWORD PTR _fileNameBufferSize$[esp+96]
  001f6	3b f1		 cmp	 esi, ecx
  001f8	73 07		 jae	 SHORT $L2320

; 596  : 		{
; 597  : 			*(szFileName+file_info.size_filename)='\0';

  001fa	88 1c 06	 mov	 BYTE PTR [esi+eax], bl

; 598  : 			uSizeRead = file_info.size_filename;

  001fd	8b fe		 mov	 edi, esi

; 599  : 		}
; 600  : 		else

  001ff	eb 02		 jmp	 SHORT $L2321
$L2320:

; 601  : 			uSizeRead = fileNameBufferSize;

  00201	8b f9		 mov	 edi, ecx
$L2321:

; 602  : 
; 603  : 		if ((file_info.size_filename>0) && (fileNameBufferSize>0))

  00203	85 f6		 test	 esi, esi
  00205	76 1c		 jbe	 SHORT $L2763
  00207	85 c9		 test	 ecx, ecx
  00209	76 18		 jbe	 SHORT $L2763

; 604  : 			if (fread(szFileName,(uInt)uSizeRead,1,s->file)!=1)

  0020b	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  0020e	51		 push	 ecx
  0020f	6a 01		 push	 1
  00211	57		 push	 edi
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 _fread
  00218	83 c4 10	 add	 esp, 16			; 00000010H
  0021b	83 f8 01	 cmp	 eax, 1
  0021e	74 03		 je	 SHORT $L2763

; 605  : 				err=UNZ_ERRNO;

  00220	83 cb ff	 or	 ebx, -1
$L2763:

; 606  : 		lSeek -= uSizeRead;

  00223	2b f7		 sub	 esi, edi

; 607  : 	}
; 608  : 
; 609  : 	
; 610  : 	if ((err==UNZ_OK) && (extraField!=NULL))

  00225	85 db		 test	 ebx, ebx
  00227	75 6e		 jne	 SHORT $L2326
$L2764:
  00229	8b 44 24 7c	 mov	 eax, DWORD PTR _extraField$[esp+96]
  0022d	85 c0		 test	 eax, eax
  0022f	74 66		 je	 SHORT $L2326

; 611  : 	{
; 612  : 		uLong uSizeRead ;
; 613  : 		if (file_info.size_file_extra<extraFieldBufferSize)

  00231	8b 7c 24 38	 mov	 edi, DWORD PTR _file_info$[esp+136]
  00235	8b ac 24 80 00
	00 00		 mov	 ebp, DWORD PTR _extraFieldBufferSize$[esp+96]
  0023c	3b fd		 cmp	 edi, ebp
  0023e	73 02		 jae	 SHORT $L2329

; 614  : 			uSizeRead = file_info.size_file_extra;

  00240	8b ef		 mov	 ebp, edi
$L2329:

; 615  : 		else
; 616  : 			uSizeRead = extraFieldBufferSize;
; 617  : 
; 618  : 		if (lSeek!=0)

  00242	85 f6		 test	 esi, esi
  00244	74 1d		 je	 SHORT $L2332

; 619  : 			if (fseek(s->file,lSeek,SEEK_CUR)==0)

  00246	8b 54 24 68	 mov	 edx, DWORD PTR _file$[esp+96]
  0024a	8b 02		 mov	 eax, DWORD PTR [edx]
  0024c	6a 01		 push	 1
  0024e	56		 push	 esi
  0024f	50		 push	 eax
  00250	e8 00 00 00 00	 call	 _fseek
  00255	83 c4 0c	 add	 esp, 12			; 0000000cH
  00258	85 c0		 test	 eax, eax
  0025a	75 04		 jne	 SHORT $L2331

; 620  : 				lSeek=0;

  0025c	33 f6		 xor	 esi, esi

; 621  : 			else

  0025e	eb 03		 jmp	 SHORT $L2332
$L2331:

; 622  : 				err=UNZ_ERRNO;

  00260	83 cb ff	 or	 ebx, -1
$L2332:

; 623  : 		if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))

  00263	85 ff		 test	 edi, edi
  00265	76 2a		 jbe	 SHORT $L2335
  00267	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR _extraFieldBufferSize$[esp+96]
  0026e	85 c0		 test	 eax, eax
  00270	76 1f		 jbe	 SHORT $L2335

; 624  : 			if (fread(extraField,(uInt)uSizeRead,1,s->file)!=1)

  00272	8b 4c 24 68	 mov	 ecx, DWORD PTR _file$[esp+96]
  00276	8b 11		 mov	 edx, DWORD PTR [ecx]
  00278	8b 44 24 7c	 mov	 eax, DWORD PTR _extraField$[esp+96]
  0027c	52		 push	 edx
  0027d	6a 01		 push	 1
  0027f	55		 push	 ebp
  00280	50		 push	 eax
  00281	e8 00 00 00 00	 call	 _fread
  00286	83 c4 10	 add	 esp, 16			; 00000010H
  00289	83 f8 01	 cmp	 eax, 1
  0028c	74 03		 je	 SHORT $L2335

; 625  : 				err=UNZ_ERRNO;

  0028e	83 cb ff	 or	 ebx, -1
$L2335:

; 626  : 		lSeek += file_info.size_file_extra - uSizeRead;

  00291	2b fd		 sub	 edi, ebp
  00293	03 f7		 add	 esi, edi

; 627  : 	}
; 628  : 	else

  00295	eb 04		 jmp	 SHORT $L2336
$L2326:

; 629  : 		lSeek+=file_info.size_file_extra; 

  00297	03 74 24 38	 add	 esi, DWORD PTR _file_info$[esp+136]
$L2336:

; 630  : 
; 631  : 	
; 632  : 	if ((err==UNZ_OK) && (szComment!=NULL))

  0029b	85 db		 test	 ebx, ebx
  0029d	0f 85 9e 00 00
	00		 jne	 $L2352
  002a3	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR _szComment$[esp+96]
  002aa	85 c0		 test	 eax, eax
  002ac	74 72		 je	 SHORT $L2760

; 633  : 	{
; 634  : 		uLong uSizeRead ;
; 635  : 		if (file_info.size_file_comment<commentBufferSize)

  002ae	8b 7c 24 3c	 mov	 edi, DWORD PTR _file_info$[esp+140]
  002b2	8b ac 24 88 00
	00 00		 mov	 ebp, DWORD PTR _commentBufferSize$[esp+96]
  002b9	3b fd		 cmp	 edi, ebp
  002bb	73 05		 jae	 SHORT $L2341

; 636  : 		{
; 637  : 			*(szComment+file_info.size_file_comment)='\0';

  002bd	88 1c 07	 mov	 BYTE PTR [edi+eax], bl

; 638  : 			uSizeRead = file_info.size_file_comment;

  002c0	8b ef		 mov	 ebp, edi
$L2341:

; 639  : 		}
; 640  : 		else
; 641  : 			uSizeRead = commentBufferSize;
; 642  : 
; 643  : 		if (lSeek!=0)

  002c2	85 f6		 test	 esi, esi
  002c4	74 19		 je	 SHORT $L2765

; 644  : 			if (fseek(s->file,lSeek,SEEK_CUR)==0)

  002c6	8b 4c 24 68	 mov	 ecx, DWORD PTR _file$[esp+96]
  002ca	8b 11		 mov	 edx, DWORD PTR [ecx]
  002cc	6a 01		 push	 1
  002ce	56		 push	 esi
  002cf	52		 push	 edx
  002d0	e8 00 00 00 00	 call	 _fseek
  002d5	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d8	85 c0		 test	 eax, eax
  002da	74 03		 je	 SHORT $L2765

; 645  : 				lSeek=0;
; 646  : 			else
; 647  : 				err=UNZ_ERRNO;

  002dc	83 cb ff	 or	 ebx, -1
$L2765:

; 648  : 		if ((file_info.size_file_comment>0) && (commentBufferSize>0))

  002df	85 ff		 test	 edi, edi
  002e1	76 39		 jbe	 SHORT $L2767
  002e3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR _commentBufferSize$[esp+96]
  002ea	85 c0		 test	 eax, eax
  002ec	76 2e		 jbe	 SHORT $L2767

; 649  : 			if (fread(szComment,(uInt)uSizeRead,1,s->file)!=1)

  002ee	8b 44 24 68	 mov	 eax, DWORD PTR _file$[esp+96]
  002f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f4	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR _szComment$[esp+96]
  002fb	51		 push	 ecx
  002fc	6a 01		 push	 1
  002fe	55		 push	 ebp
  002ff	52		 push	 edx
  00300	e8 00 00 00 00	 call	 _fread
  00305	83 c4 10	 add	 esp, 16			; 00000010H
  00308	83 f8 01	 cmp	 eax, 1
  0030b	74 0f		 je	 SHORT $L2767
  0030d	5f		 pop	 edi
  0030e	5e		 pop	 esi

; 650  : 				err=UNZ_ERRNO;

  0030f	83 cb ff	 or	 ebx, -1
  00312	5d		 pop	 ebp

; 661  : 
; 662  : 	return err;

  00313	8b c3		 mov	 eax, ebx
  00315	5b		 pop	 ebx

; 663  : }

  00316	83 c4 54	 add	 esp, 84			; 00000054H
  00319	c2 24 00	 ret	 36			; 00000024H
$L2767:

; 651  : 		lSeek+=file_info.size_file_comment - uSizeRead;
; 652  : 	}
; 653  : 	else
; 654  : 		lSeek+=file_info.size_file_comment;
; 655  : 
; 656  : 	if ((err==UNZ_OK) && (pfile_info!=NULL))

  0031c	85 db		 test	 ebx, ebx
  0031e	75 21		 jne	 SHORT $L2352
$L2760:
  00320	8b 7c 24 6c	 mov	 edi, DWORD PTR _pfile_info$[esp+96]
  00324	85 ff		 test	 edi, edi
  00326	74 0b		 je	 SHORT $L2761

; 657  : 		*pfile_info=file_info;

  00328	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0032d	8d 74 24 14	 lea	 esi, DWORD PTR _file_info$[esp+100]
  00331	f3 a5		 rep movsd
$L2761:

; 658  : 
; 659  : 	if ((err==UNZ_OK) && (pfile_info_internal!=NULL))

  00333	8b 44 24 70	 mov	 eax, DWORD PTR _pfile_info_internal$[esp+96]
  00337	85 c0		 test	 eax, eax
  00339	74 06		 je	 SHORT $L2352

; 660  : 		*pfile_info_internal=file_info_internal;

  0033b	8b 4c 24 10	 mov	 ecx, DWORD PTR _file_info_internal$[esp+100]
  0033f	89 08		 mov	 DWORD PTR [eax], ecx
$L2352:
  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5d		 pop	 ebp

; 661  : 
; 662  : 	return err;

  00344	8b c3		 mov	 eax, ebx
  00346	5b		 pop	 ebx

; 663  : }

  00347	83 c4 54	 add	 esp, 84			; 00000054H
  0034a	c2 24 00	 ret	 36			; 00000024H
@unzlocal_GetCurrentFileInfoInternal@36 ENDP
_TEXT	ENDS
PUBLIC	@unzGetCurrentFileInfo@32
; Function compile flags: /Ogty
;	COMDAT @unzGetCurrentFileInfo@32
_TEXT	SEGMENT
_szFileName$ = 8					; size = 4
_fileNameBufferSize$ = 12				; size = 4
_extraField$ = 16					; size = 4
_extraFieldBufferSize$ = 20				; size = 4
_szComment$ = 24					; size = 4
_commentBufferSize$ = 28				; size = 4
@unzGetCurrentFileInfo@32 PROC NEAR			; COMDAT
; _file$ = ecx
; _pfile_info$ = edx

; 686  : 	return unzlocal_GetCurrentFileInfoInternal(file,pfile_info,NULL,
; 687  : 												szFileName,fileNameBufferSize,
; 688  : 												extraField,extraFieldBufferSize,
; 689  : 												szComment,commentBufferSize);

  00000	8b 44 24 18	 mov	 eax, DWORD PTR _commentBufferSize$[esp-4]
  00004	50		 push	 eax
  00005	8b 44 24 18	 mov	 eax, DWORD PTR _szComment$[esp]
  00009	50		 push	 eax
  0000a	8b 44 24 18	 mov	 eax, DWORD PTR _extraFieldBufferSize$[esp+4]
  0000e	50		 push	 eax
  0000f	8b 44 24 18	 mov	 eax, DWORD PTR _extraField$[esp+8]
  00013	50		 push	 eax
  00014	8b 44 24 18	 mov	 eax, DWORD PTR _fileNameBufferSize$[esp+12]
  00018	50		 push	 eax
  00019	8b 44 24 18	 mov	 eax, DWORD PTR _szFileName$[esp+16]
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	52		 push	 edx
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 @unzlocal_GetCurrentFileInfoInternal@36

; 690  : }

  00027	c2 18 00	 ret	 24			; 00000018H
@unzGetCurrentFileInfo@32 ENDP
_TEXT	ENDS
PUBLIC	@unzGoToFirstFile@4
; Function compile flags: /Ogty
;	COMDAT @unzGoToFirstFile@4
_TEXT	SEGMENT
@unzGoToFirstFile@4 PROC NEAR				; COMDAT
; _file$ = ecx

; 698  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 699  : 	int err=UNZ_OK;
; 700  : 	unz_s* s;
; 701  : 	if (file==NULL)

  00003	85 f6		 test	 esi, esi
  00005	75 07		 jne	 SHORT $L2370

; 702  : 		return UNZ_PARAMERROR;

  00007	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  0000c	5e		 pop	 esi

; 710  : 	return err;
; 711  : }

  0000d	c3		 ret	 0
$L2370:

; 703  : 	s=(unz_s*)file;
; 704  : 	s->pos_in_central_dir=s->offset_central_dir;

  0000e	8b 46 24	 mov	 eax, DWORD PTR [esi+36]

; 705  : 	s->num_file=0;
; 706  : 	err=unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
; 707  : 											 &s->cur_file_info_internal,
; 708  : 											 NULL,0,NULL,0,NULL,0);

  00011	6a 00		 push	 0
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	8d 4e 78	 lea	 ecx, DWORD PTR [esi+120]
  00020	51		 push	 ecx
  00021	8d 56 28	 lea	 edx, DWORD PTR [esi+40]
  00024	52		 push	 edx
  00025	56		 push	 esi
  00026	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00029	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00030	e8 00 00 00 00	 call	 @unzlocal_GetCurrentFileInfoInternal@36

; 709  : 	s->current_file_ok = (err == UNZ_OK);

  00035	33 c9		 xor	 ecx, ecx
  00037	85 c0		 test	 eax, eax
  00039	0f 94 c1	 sete	 cl
  0003c	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  0003f	5e		 pop	 esi

; 710  : 	return err;
; 711  : }

  00040	c3		 ret	 0
@unzGoToFirstFile@4 ENDP
_TEXT	ENDS
PUBLIC	@unzGoToNextFile@4
; Function compile flags: /Ogty
;	COMDAT @unzGoToNextFile@4
_TEXT	SEGMENT
@unzGoToNextFile@4 PROC NEAR				; COMDAT
; _file$ = ecx

; 721  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 722  : 	unz_s* s;	
; 723  : 	int err;
; 724  : 
; 725  : 	if (file==NULL)

  00003	85 f6		 test	 esi, esi
  00005	75 07		 jne	 SHORT $L2381

; 726  : 		return UNZ_PARAMERROR;

  00007	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  0000c	5e		 pop	 esi

; 740  : 	return err;
; 741  : }

  0000d	c3		 ret	 0
$L2381:

; 727  : 	s=(unz_s*)file;
; 728  : 	if (!s->current_file_ok)

  0000e	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00011	85 c0		 test	 eax, eax

; 729  : 		return UNZ_END_OF_LIST_OF_FILE;

  00013	74 0b		 je	 SHORT $L2789

; 730  : 	if (s->num_file+1==s->gi.number_entry)

  00015	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00018	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001b	40		 inc	 eax
  0001c	3b c1		 cmp	 eax, ecx
  0001e	75 07		 jne	 SHORT $L2384
$L2789:

; 731  : 		return UNZ_END_OF_LIST_OF_FILE;

  00020	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  00025	5e		 pop	 esi

; 740  : 	return err;
; 741  : }

  00026	c3		 ret	 0
$L2384:

; 732  : 
; 733  : 	s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
; 734  : 			s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;

  00027	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  0002a	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]

; 735  : 	s->num_file++;
; 736  : 	err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
; 737  : 											   &s->cur_file_info_internal,
; 738  : 											   NULL,0,NULL,0,NULL,0);

  0002d	6a 00		 push	 0
  0002f	6a 00		 push	 0
  00031	03 ca		 add	 ecx, edx
  00033	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00036	6a 00		 push	 0
  00038	8d 4c 11 2e	 lea	 ecx, DWORD PTR [ecx+edx+46]
  0003c	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	03 d1		 add	 edx, ecx
  00045	6a 00		 push	 0
  00047	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0004a	8d 56 78	 lea	 edx, DWORD PTR [esi+120]
  0004d	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00050	52		 push	 edx
  00051	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 @unzlocal_GetCurrentFileInfoInternal@36

; 739  : 	s->current_file_ok = (err == UNZ_OK);

  0005b	33 c9		 xor	 ecx, ecx
  0005d	85 c0		 test	 eax, eax
  0005f	0f 94 c1	 sete	 cl
  00062	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00065	5e		 pop	 esi

; 740  : 	return err;
; 741  : }

  00066	c3		 ret	 0
@unzGoToNextFile@4 ENDP
_TEXT	ENDS
PUBLIC	@unzLocateFile@12
; Function compile flags: /Ogty
;	COMDAT @unzLocateFile@12
_TEXT	SEGMENT
_pos_in_central_dirSaved$ = -268			; size = 4
_num_fileSaved$ = -264					; size = 4
_szCurrentFileName$2405 = -260				; size = 257
_iCaseSensitivity$ = 8					; size = 4
@unzLocateFile@12 PROC NEAR				; COMDAT
; _file$ = ecx
; _szFileName$ = edx

; 756  : {

  00000	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 757  : 	unz_s* s;	
; 758  : 	int err;
; 759  : 
; 760  : 	
; 761  : 	uLong num_fileSaved;
; 762  : 	uLong pos_in_central_dirSaved;
; 763  : 
; 764  : 
; 765  : 	if (file==NULL)

  0000a	85 ff		 test	 edi, edi
  0000c	8b da		 mov	 ebx, edx

; 766  : 		return UNZ_PARAMERROR;

  0000e	74 15		 je	 SHORT $L2813

; 767  : 
; 768  :     if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)

  00010	8b c3		 mov	 eax, ebx
  00012	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L2805:
  00015	8a 08		 mov	 cl, BYTE PTR [eax]
  00017	40		 inc	 eax
  00018	84 c9		 test	 cl, cl
  0001a	75 f9		 jne	 SHORT $L2805
  0001c	2b c2		 sub	 eax, edx
  0001e	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00023	72 10		 jb	 SHORT $L2399
$L2813:
  00025	5f		 pop	 edi

; 769  :         return UNZ_PARAMERROR;

  00026	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  0002b	5b		 pop	 ebx

; 794  : 	return err;
; 795  : }

  0002c	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00032	c2 04 00	 ret	 4
$L2399:

; 770  : 
; 771  : 	s=(unz_s*)file;
; 772  : 	if (!s->current_file_ok)

  00035	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00038	85 c0		 test	 eax, eax
  0003a	75 10		 jne	 SHORT $L2401
  0003c	5f		 pop	 edi

; 773  : 		return UNZ_END_OF_LIST_OF_FILE;

  0003d	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  00042	5b		 pop	 ebx

; 794  : 	return err;
; 795  : }

  00043	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00049	c2 04 00	 ret	 4
$L2401:

; 774  : 
; 775  : 	num_fileSaved = s->num_file;
; 776  : 	pos_in_central_dirSaved = s->pos_in_central_dir;

  0004c	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0004f	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00052	55		 push	 ebp
  00053	89 4c 24 0c	 mov	 DWORD PTR _pos_in_central_dirSaved$[esp+280], ecx
  00057	56		 push	 esi

; 777  : 
; 778  : 	err = unzGoToFirstFile(file);

  00058	8b cf		 mov	 ecx, edi
  0005a	89 44 24 14	 mov	 DWORD PTR _num_fileSaved$[esp+284], eax
  0005e	e8 00 00 00 00	 call	 @unzGoToFirstFile@4

; 779  : 
; 780  : 	while (err == UNZ_OK)

  00063	85 c0		 test	 eax, eax
  00065	75 7e		 jne	 SHORT $L2404
  00067	8b ac 24 20 01
	00 00		 mov	 ebp, DWORD PTR _iCaseSensitivity$[esp+280]
  0006e	8b ff		 npad	 2
$L2403:

; 781  : 	{
; 782  : 		char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];
; 783  : 		unzGetCurrentFileInfo(file,NULL,
; 784  : 								szCurrentFileName,sizeof(szCurrentFileName)-1,
; 785  : 								NULL,0,NULL,0);

  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	6a 00		 push	 0
  00076	6a 00		 push	 0
  00078	68 00 01 00 00	 push	 256			; 00000100H
  0007d	8d 54 24 2c	 lea	 edx, DWORD PTR _szCurrentFileName$2405[esp+304]
  00081	52		 push	 edx
  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 @unzlocal_GetCurrentFileInfoInternal@36

; 786  : 		if (unzStringFileNameCompare(szCurrentFileName,
; 787  : 										szFileName,iCaseSensitivity)==0)

  0008c	85 ed		 test	 ebp, ebp
  0008e	74 3b		 je	 SHORT $L2798
  00090	83 fd 01	 cmp	 ebp, 1
  00093	75 36		 jne	 SHORT $L2798
  00095	8b f3		 mov	 esi, ebx
  00097	8d 44 24 18	 lea	 eax, DWORD PTR _szCurrentFileName$2405[esp+284]
  0009b	eb 03 8d 49 00	 npad	 5
$L2806:
  000a0	8a 10		 mov	 dl, BYTE PTR [eax]
  000a2	8a ca		 mov	 cl, dl
  000a4	3a 16		 cmp	 dl, BYTE PTR [esi]
  000a6	75 1c		 jne	 SHORT $L2807
  000a8	84 c9		 test	 cl, cl
  000aa	74 14		 je	 SHORT $L2808
  000ac	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000af	8a ca		 mov	 cl, dl
  000b1	3a 56 01	 cmp	 dl, BYTE PTR [esi+1]
  000b4	75 0e		 jne	 SHORT $L2807
  000b6	83 c0 02	 add	 eax, 2
  000b9	83 c6 02	 add	 esi, 2
  000bc	84 c9		 test	 cl, cl
  000be	75 e0		 jne	 SHORT $L2806
$L2808:
  000c0	33 c0		 xor	 eax, eax
  000c2	eb 12		 jmp	 SHORT $L2796
$L2807:
  000c4	1b c0		 sbb	 eax, eax
  000c6	83 d8 ff	 sbb	 eax, -1
  000c9	eb 0b		 jmp	 SHORT $L2796
$L2798:
  000cb	8b c3		 mov	 eax, ebx
  000cd	8d 54 24 18	 lea	 edx, DWORD PTR _szCurrentFileName$2405[esp+284]
  000d1	e8 00 00 00 00	 call	 @strcmpcasenosensitive_internal@8
$L2796:
  000d6	85 c0		 test	 eax, eax
  000d8	74 26		 je	 SHORT $L2803

; 789  : 		err = unzGoToNextFile(file);

  000da	8b cf		 mov	 ecx, edi
  000dc	e8 00 00 00 00	 call	 @unzGoToNextFile@4
  000e1	85 c0		 test	 eax, eax
  000e3	74 8b		 je	 SHORT $L2403
$L2404:

; 790  : 	}
; 791  : 
; 792  : 	s->num_file = num_fileSaved ;

  000e5	8b 4c 24 14	 mov	 ecx, DWORD PTR _num_fileSaved$[esp+284]

; 793  : 	s->pos_in_central_dir = pos_in_central_dirSaved ;

  000e9	8b 54 24 10	 mov	 edx, DWORD PTR _pos_in_central_dirSaved$[esp+284]
  000ed	5e		 pop	 esi
  000ee	5d		 pop	 ebp
  000ef	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  000f2	89 57 14	 mov	 DWORD PTR [edi+20], edx
  000f5	5f		 pop	 edi
  000f6	5b		 pop	 ebx

; 794  : 	return err;
; 795  : }

  000f7	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  000fd	c2 04 00	 ret	 4
$L2803:
  00100	5e		 pop	 esi
  00101	5d		 pop	 ebp
  00102	5f		 pop	 edi

; 788  : 			return UNZ_OK;

  00103	33 c0		 xor	 eax, eax
  00105	5b		 pop	 ebx

; 794  : 	return err;
; 795  : }

  00106	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  0010c	c2 04 00	 ret	 4
@unzLocateFile@12 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @unzlocal_CheckCurrentFileCoherencyHeader@16
_TEXT	SEGMENT
_uFlags$ = -4						; size = 4
_size_extra_field$ = 8					; size = 4
_size_filename$ = 8					; size = 4
_uData$ = 8						; size = 4
_uMagic$ = 8						; size = 4
_s$ = 8							; size = 4
_piSizeVar$ = 12					; size = 4
_poffset_local_extrafield$ = 16				; size = 4
_psize_local_extrafield$ = 20				; size = 4
@unzlocal_CheckCurrentFileCoherencyHeader@16 PROC NEAR	; COMDAT

; 812  : {

  00000	51		 push	 ecx

; 813  : 	uLong uMagic,uData,uFlags;
; 814  : 	uLong size_filename;
; 815  : 	uLong size_extra_field;
; 816  : 	int err=UNZ_OK;
; 817  : 
; 818  : 	*piSizeVar = 0;

  00001	8b 44 24 0c	 mov	 eax, DWORD PTR _piSizeVar$[esp]

; 819  : 	*poffset_local_extrafield = 0;

  00005	8b 4c 24 10	 mov	 ecx, DWORD PTR _poffset_local_extrafield$[esp]

; 820  : 	*psize_local_extrafield = 0;

  00009	8b 54 24 14	 mov	 edx, DWORD PTR _psize_local_extrafield$[esp]
  0000d	55		 push	 ebp
  0000e	8b 6c 24 0c	 mov	 ebp, DWORD PTR _s$[esp+4]
  00012	56		 push	 esi
  00013	33 f6		 xor	 esi, esi
  00015	89 30		 mov	 DWORD PTR [eax], esi
  00017	89 31		 mov	 DWORD PTR [ecx], esi
  00019	89 32		 mov	 DWORD PTR [edx], esi

; 821  : 
; 822  : 	if (fseek(s->file,s->cur_file_info_internal.offset_curfile +
; 823  : 								s->byte_before_the_zipfile,SEEK_SET)!=0)

  0001b	8b 4d 78	 mov	 ecx, DWORD PTR [ebp+120]
  0001e	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  00021	03 c1		 add	 eax, ecx
  00023	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00026	56		 push	 esi
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _fseek
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	85 c0		 test	 eax, eax
  00033	74 09		 je	 SHORT $L2816
  00035	5e		 pop	 esi

; 824  : 		return UNZ_ERRNO;

  00036	83 c8 ff	 or	 eax, -1
  00039	5d		 pop	 ebp

; 889  : }

  0003a	59		 pop	 ecx
  0003b	c2 10 00	 ret	 16			; 00000010H
$L2816:
  0003e	53		 push	 ebx
  0003f	57		 push	 edi

; 825  : 
; 826  : 
; 827  : 	if (err==UNZ_OK)
; 828  : 		if (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)

  00040	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00043	8d 54 24 18	 lea	 edx, DWORD PTR _uMagic$[esp+16]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  0004d	85 c0		 test	 eax, eax
  0004f	74 05		 je	 SHORT $L2425

; 829  : 			err=UNZ_ERRNO;

  00051	83 ce ff	 or	 esi, -1

; 830  : 		else if (uMagic!=0x04034b50)

  00054	eb 0f		 jmp	 SHORT $L2818
$L2425:
  00056	81 7c 24 18 50
	4b 03 04	 cmp	 DWORD PTR _uMagic$[esp+16], 67324752 ; 04034b50H
  0005e	74 05		 je	 SHORT $L2818

; 831  : 			err=UNZ_BADZIPFILE;

  00060	be 99 ff ff ff	 mov	 esi, -103		; ffffff99H
$L2818:

; 832  : 
; 833  : 	if (unzlocal_getShort(s->file,&uData) != UNZ_OK)

  00065	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00068	8d 44 24 18	 lea	 eax, DWORD PTR _uData$[esp+16]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00072	85 c0		 test	 eax, eax
  00074	74 03		 je	 SHORT $L2819

; 834  : 		err=UNZ_ERRNO;

  00076	83 ce ff	 or	 esi, -1
$L2819:

; 835  : /*
; 836  : 	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
; 837  : 		err=UNZ_BADZIPFILE;
; 838  : */
; 839  : 	if (unzlocal_getShort(s->file,&uFlags) != UNZ_OK)

  00079	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  0007c	8d 4c 24 10	 lea	 ecx, DWORD PTR _uFlags$[esp+20]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00086	85 c0		 test	 eax, eax
  00088	74 03		 je	 SHORT $L2820

; 840  : 		err=UNZ_ERRNO;

  0008a	83 ce ff	 or	 esi, -1
$L2820:

; 841  : 
; 842  : 	if (unzlocal_getShort(s->file,&uData) != UNZ_OK)

  0008d	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00090	8d 54 24 18	 lea	 edx, DWORD PTR _uData$[esp+16]
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  0009a	85 c0		 test	 eax, eax
  0009c	74 05		 je	 SHORT $L2430

; 843  : 		err=UNZ_ERRNO;

  0009e	83 ce ff	 or	 esi, -1

; 844  : 	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))

  000a1	eb 1b		 jmp	 SHORT $L2821
$L2430:
  000a3	85 f6		 test	 esi, esi
  000a5	75 17		 jne	 SHORT $L2821
  000a7	8b 45 34	 mov	 eax, DWORD PTR [ebp+52]
  000aa	39 44 24 18	 cmp	 DWORD PTR _uData$[esp+16], eax

; 845  : 		err=UNZ_BADZIPFILE;
; 846  : 
; 847  :     if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&
; 848  :                          (s->cur_file_info.compression_method!=Z_DEFLATED))

  000ae	75 09		 jne	 SHORT $L2822
  000b0	85 c0		 test	 eax, eax
  000b2	74 0a		 je	 SHORT $L2821
  000b4	83 f8 08	 cmp	 eax, 8
  000b7	74 05		 je	 SHORT $L2821
$L2822:

; 849  :         err=UNZ_BADZIPFILE;

  000b9	be 99 ff ff ff	 mov	 esi, -103		; ffffff99H
$L2821:

; 850  : 
; 851  : 	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* date/time */

  000be	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  000c1	8d 44 24 18	 lea	 eax, DWORD PTR _uData$[esp+16]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  000cb	85 c0		 test	 eax, eax
  000cd	74 03		 je	 SHORT $L2434

; 852  : 		err=UNZ_ERRNO;

  000cf	83 ce ff	 or	 esi, -1
$L2434:

; 853  : 
; 854  : 	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* crc */

  000d2	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  000d5	8d 4c 24 18	 lea	 ecx, DWORD PTR _uData$[esp+16]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  000df	85 c0		 test	 eax, eax
  000e1	8a 5c 24 10	 mov	 bl, BYTE PTR _uFlags$[esp+20]
  000e5	74 05		 je	 SHORT $L2435

; 855  : 		err=UNZ_ERRNO;

  000e7	83 ce ff	 or	 esi, -1

; 856  : 	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) &&

  000ea	eb 17		 jmp	 SHORT $L2437
$L2435:

; 857  : 		                      ((uFlags & 8)==0))

  000ec	85 f6		 test	 esi, esi
  000ee	75 13		 jne	 SHORT $L2437
  000f0	8b 54 24 18	 mov	 edx, DWORD PTR _uData$[esp+16]
  000f4	3b 55 3c	 cmp	 edx, DWORD PTR [ebp+60]
  000f7	74 0a		 je	 SHORT $L2437
  000f9	f6 c3 08	 test	 bl, 8
  000fc	75 05		 jne	 SHORT $L2437

; 858  : 		err=UNZ_BADZIPFILE;

  000fe	be 99 ff ff ff	 mov	 esi, -103		; ffffff99H
$L2437:

; 859  : 
; 860  : 	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* size compr */

  00103	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00106	8d 44 24 18	 lea	 eax, DWORD PTR _uData$[esp+16]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  00110	85 c0		 test	 eax, eax
  00112	74 05		 je	 SHORT $L2438

; 861  : 		err=UNZ_ERRNO;

  00114	83 ce ff	 or	 esi, -1

; 862  : 	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) &&

  00117	eb 17		 jmp	 SHORT $L2440
$L2438:

; 863  : 							  ((uFlags & 8)==0))

  00119	85 f6		 test	 esi, esi
  0011b	75 13		 jne	 SHORT $L2440
  0011d	8b 4c 24 18	 mov	 ecx, DWORD PTR _uData$[esp+16]
  00121	3b 4d 40	 cmp	 ecx, DWORD PTR [ebp+64]
  00124	74 0a		 je	 SHORT $L2440
  00126	f6 c3 08	 test	 bl, 8
  00129	75 05		 jne	 SHORT $L2440

; 864  : 		err=UNZ_BADZIPFILE;

  0012b	be 99 ff ff ff	 mov	 esi, -103		; ffffff99H
$L2440:

; 865  : 
; 866  : 	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* size uncompr */

  00130	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00133	8d 54 24 18	 lea	 edx, DWORD PTR _uData$[esp+16]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  0013d	85 c0		 test	 eax, eax
  0013f	74 05		 je	 SHORT $L2441

; 867  : 		err=UNZ_ERRNO;

  00141	83 ce ff	 or	 esi, -1

; 868  : 	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && 

  00144	eb 17		 jmp	 SHORT $L2443
$L2441:

; 869  : 							  ((uFlags & 8)==0))

  00146	85 f6		 test	 esi, esi
  00148	75 13		 jne	 SHORT $L2443
  0014a	8b 44 24 18	 mov	 eax, DWORD PTR _uData$[esp+16]
  0014e	3b 45 44	 cmp	 eax, DWORD PTR [ebp+68]
  00151	74 0a		 je	 SHORT $L2443
  00153	f6 c3 08	 test	 bl, 8
  00156	75 05		 jne	 SHORT $L2443

; 870  : 		err=UNZ_BADZIPFILE;

  00158	be 99 ff ff ff	 mov	 esi, -103		; ffffff99H
$L2443:

; 871  : 
; 872  : 
; 873  : 	if (unzlocal_getShort(s->file,&size_filename) != UNZ_OK)

  0015d	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00160	8d 4c 24 18	 lea	 ecx, DWORD PTR _size_filename$[esp+16]
  00164	51		 push	 ecx
  00165	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  0016a	85 c0		 test	 eax, eax
  0016c	8b 5c 24 18	 mov	 ebx, DWORD PTR _size_filename$[esp+16]
  00170	74 05		 je	 SHORT $L2444

; 874  : 		err=UNZ_ERRNO;

  00172	83 ce ff	 or	 esi, -1

; 875  : 	else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))

  00175	eb 0e		 jmp	 SHORT $L2446
$L2444:
  00177	85 f6		 test	 esi, esi
  00179	75 0a		 jne	 SHORT $L2446
  0017b	3b 5d 48	 cmp	 ebx, DWORD PTR [ebp+72]
  0017e	74 05		 je	 SHORT $L2446

; 876  : 		err=UNZ_BADZIPFILE;

  00180	be 99 ff ff ff	 mov	 esi, -103		; ffffff99H
$L2446:

; 877  : 
; 878  : 	*piSizeVar += (uInt)size_filename;

  00185	8b 44 24 1c	 mov	 eax, DWORD PTR _piSizeVar$[esp+16]
  00189	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018b	03 cb		 add	 ecx, ebx

; 879  : 
; 880  : 	if (unzlocal_getShort(s->file,&size_extra_field) != UNZ_OK)

  0018d	8d 54 24 18	 lea	 edx, DWORD PTR _size_extra_field$[esp+16]
  00191	89 08		 mov	 DWORD PTR [eax], ecx
  00193	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00196	52		 push	 edx
  00197	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  0019c	85 c0		 test	 eax, eax
  0019e	74 03		 je	 SHORT $L2448

; 881  : 		err=UNZ_ERRNO;

  001a0	83 ce ff	 or	 esi, -1
$L2448:

; 882  : 	*poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +
; 883  : 									SIZEZIPLOCALHEADER + size_filename;

  001a3	8b 45 78	 mov	 eax, DWORD PTR [ebp+120]
  001a6	8b 54 24 20	 mov	 edx, DWORD PTR _poffset_local_extrafield$[esp+16]
  001aa	8d 4c 18 1e	 lea	 ecx, DWORD PTR [eax+ebx+30]

; 884  : 	*psize_local_extrafield = (uInt)size_extra_field;

  001ae	8b 44 24 18	 mov	 eax, DWORD PTR _size_extra_field$[esp+16]
  001b2	89 0a		 mov	 DWORD PTR [edx], ecx
  001b4	8b 4c 24 24	 mov	 ecx, DWORD PTR _psize_local_extrafield$[esp+16]
  001b8	89 01		 mov	 DWORD PTR [ecx], eax

; 885  : 
; 886  : 	*piSizeVar += (uInt)size_extra_field;

  001ba	8b 4c 24 1c	 mov	 ecx, DWORD PTR _piSizeVar$[esp+16]
  001be	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c0	5f		 pop	 edi
  001c1	03 d0		 add	 edx, eax
  001c3	5b		 pop	 ebx

; 887  : 
; 888  : 	return err;

  001c4	8b c6		 mov	 eax, esi
  001c6	5e		 pop	 esi
  001c7	89 11		 mov	 DWORD PTR [ecx], edx
  001c9	5d		 pop	 ebp

; 889  : }

  001ca	59		 pop	 ecx
  001cb	c2 10 00	 ret	 16			; 00000010H
@unzlocal_CheckCurrentFileCoherencyHeader@16 ENDP
_TEXT	ENDS
PUBLIC	@unzReadCurrentFile@12
EXTRN	@inflate@8:NEAR
EXTRN	@crc32@12:NEAR
; Function compile flags: /Ogty
;	COMDAT @unzReadCurrentFile@12
_TEXT	SEGMENT
_iRead$ = -8						; size = 4
_err$ = -4						; size = 4
_len$ = 8						; size = 4
@unzReadCurrentFile@12 PROC NEAR			; COMDAT
; _file$ = ecx
; _buf$ = edx

; 1000 : {

  00000	83 ec 08	 sub	 esp, 8

; 1001 : 	int err=UNZ_OK;
; 1002 : 	uInt iRead = 0;
; 1003 : 	unz_s* s;
; 1004 : 	file_in_zip_read_info_s* pfile_in_zip_read_info;
; 1005 : 	if (file==NULL)

  00003	85 c9		 test	 ecx, ecx
  00005	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _err$[esp+8], 0
  0000d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR _iRead$[esp+8], 0
  00014	75 0b		 jne	 SHORT $L2495

; 1006 : 		return UNZ_PARAMERROR;

  00016	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH

; 1117 : }

  0001b	83 c4 08	 add	 esp, 8
  0001e	c2 04 00	 ret	 4
$L2495:
  00021	56		 push	 esi

; 1007 : 	s=(unz_s*)file;
; 1008 :     pfile_in_zip_read_info=s->pfile_in_zip_read;

  00022	8b 71 7c	 mov	 esi, DWORD PTR [ecx+124]

; 1009 : 
; 1010 : 	if (pfile_in_zip_read_info==NULL)

  00025	85 f6		 test	 esi, esi
  00027	75 0c		 jne	 SHORT $L2498

; 1011 : 		return UNZ_PARAMERROR;

  00029	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  0002e	5e		 pop	 esi

; 1117 : }

  0002f	83 c4 08	 add	 esp, 8
  00032	c2 04 00	 ret	 4
$L2498:

; 1012 : 
; 1013 : 
; 1014 : 	if ((pfile_in_zip_read_info->read_buffer == NULL))

  00035	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00038	75 0c		 jne	 SHORT $L2500

; 1015 : 		return UNZ_END_OF_LIST_OF_FILE;

  0003a	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  0003f	5e		 pop	 esi

; 1117 : }

  00040	83 c4 08	 add	 esp, 8
  00043	c2 04 00	 ret	 4
$L2500:

; 1016 : 	if (len==0)

  00046	8b 4c 24 10	 mov	 ecx, DWORD PTR _len$[esp+8]
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 09		 jne	 SHORT $L2501

; 1017 : 		return 0;

  0004e	33 c0		 xor	 eax, eax
  00050	5e		 pop	 esi

; 1117 : }

  00051	83 c4 08	 add	 esp, 8
  00054	c2 04 00	 ret	 4
$L2501:

; 1018 : 
; 1019 : 	pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;
; 1020 : 
; 1021 : 	pfile_in_zip_read_info->stream.avail_out = (uInt)len;
; 1022 : 	
; 1023 : 	if (len>pfile_in_zip_read_info->rest_read_uncompressed)

  00057	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0005a	3b c8		 cmp	 ecx, eax
  0005c	89 56 10	 mov	 DWORD PTR [esi+16], edx
  0005f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  00062	76 03		 jbe	 SHORT $L2825

; 1024 : 		pfile_in_zip_read_info->stream.avail_out = 
; 1025 : 		  (uInt)pfile_in_zip_read_info->rest_read_uncompressed;

  00064	89 46 14	 mov	 DWORD PTR [esi+20], eax
$L2825:

; 1026 : 
; 1027 : 	while (pfile_in_zip_read_info->stream.avail_out>0)

  00067	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0006a	85 c0		 test	 eax, eax
  0006c	53		 push	 ebx
  0006d	55		 push	 ebp
  0006e	57		 push	 edi
  0006f	0f 86 6b 01 00
	00		 jbe	 $L2830
$L2507:

; 1028 : 	{
; 1029 : 		if ((pfile_in_zip_read_info->stream.avail_in==0) &&
; 1030 :             (pfile_in_zip_read_info->rest_read_compressed>0))

  00075	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00078	85 c0		 test	 eax, eax
  0007a	75 6c		 jne	 SHORT $L2509
  0007c	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  0007f	85 c0		 test	 eax, eax
  00081	76 65		 jbe	 SHORT $L2509

; 1031 : 		{
; 1032 : 			uInt uReadThis = UNZ_BUFSIZE;

  00083	bf 00 40 00 00	 mov	 edi, 16384		; 00004000H

; 1033 : 			if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)

  00088	3b c7		 cmp	 eax, edi
  0008a	73 0a		 jae	 SHORT $L2834

; 1034 : 				uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;

  0008c	8b f8		 mov	 edi, eax

; 1035 : 			if (uReadThis == 0)

  0008e	85 ff		 test	 edi, edi
  00090	0f 84 31 01 00
	00		 je	 $L2827
$L2834:

; 1037 : 			if (fseek(pfile_in_zip_read_info->file,
; 1038 :                       pfile_in_zip_read_info->pos_in_zipfile + 
; 1039 :                          pfile_in_zip_read_info->byte_before_the_zipfile,SEEK_SET)!=0)

  00096	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00099	8b 46 68	 mov	 eax, DWORD PTR [esi+104]
  0009c	03 c1		 add	 eax, ecx
  0009e	8b 4e 60	 mov	 ecx, DWORD PTR [esi+96]
  000a1	6a 00		 push	 0
  000a3	50		 push	 eax
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _fseek
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ad	85 c0		 test	 eax, eax
  000af	0f 85 1e 01 00
	00		 jne	 $L2828

; 1041 : 			if (fread(pfile_in_zip_read_info->read_buffer,uReadThis,1,
; 1042 :                          pfile_in_zip_read_info->file)!=1)

  000b5	8b 56 60	 mov	 edx, DWORD PTR [esi+96]
  000b8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ba	52		 push	 edx
  000bb	6a 01		 push	 1
  000bd	57		 push	 edi
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _fread
  000c4	83 c4 10	 add	 esp, 16			; 00000010H
  000c7	83 f8 01	 cmp	 eax, 1
  000ca	0f 85 03 01 00
	00		 jne	 $L2828

; 1043 : 				return UNZ_ERRNO;
; 1044 : 			pfile_in_zip_read_info->pos_in_zipfile += uReadThis;

  000d0	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]

; 1045 : 
; 1046 : 			pfile_in_zip_read_info->rest_read_compressed-=uReadThis;

  000d3	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  000d6	03 cf		 add	 ecx, edi
  000d8	89 4e 3c	 mov	 DWORD PTR [esi+60], ecx

; 1047 : 			
; 1048 : 			pfile_in_zip_read_info->stream.next_in = 
; 1049 :                 (Bytef*)pfile_in_zip_read_info->read_buffer;

  000db	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000dd	2b c7		 sub	 eax, edi
  000df	89 46 58	 mov	 DWORD PTR [esi+88], eax
  000e2	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1050 : 			pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;

  000e5	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$L2509:

; 1051 : 		}
; 1052 : 
; 1053 : 		if (pfile_in_zip_read_info->compression_method==0)

  000e8	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  000eb	85 c0		 test	 eax, eax
  000ed	75 6e		 jne	 SHORT $L2518

; 1054 : 		{
; 1055 : 			uInt uDoCopy,i ;
; 1056 : 			if (pfile_in_zip_read_info->stream.avail_out < 
; 1057 :                             pfile_in_zip_read_info->stream.avail_in)

  000ef	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000f2	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  000f5	3b c7		 cmp	 eax, edi
  000f7	73 02		 jae	 SHORT $L2522

; 1058 : 				uDoCopy = pfile_in_zip_read_info->stream.avail_out ;

  000f9	8b f8		 mov	 edi, eax
$L2522:

; 1059 : 			else
; 1060 : 				uDoCopy = pfile_in_zip_read_info->stream.avail_in ;
; 1061 : 				
; 1062 : 			for (i=0;i<uDoCopy;i++)

  000fb	33 c0		 xor	 eax, eax
  000fd	85 ff		 test	 edi, edi
  000ff	76 11		 jbe	 SHORT $L2525
$L2523:

; 1063 : 				*(pfile_in_zip_read_info->stream.next_out+i) =
; 1064 :                         *(pfile_in_zip_read_info->stream.next_in+i);

  00101	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00104	8a 14 10	 mov	 dl, BYTE PTR [eax+edx]
  00107	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0010a	88 14 08	 mov	 BYTE PTR [eax+ecx], dl
  0010d	40		 inc	 eax
  0010e	3b c7		 cmp	 eax, edi
  00110	72 ef		 jb	 SHORT $L2523
$L2525:

; 1065 : 					
; 1066 : 			pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,
; 1067 : 								pfile_in_zip_read_info->stream.next_out,
; 1068 : 								uDoCopy);

  00112	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00115	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00118	57		 push	 edi
  00119	e8 00 00 00 00	 call	 @crc32@12

; 1069 : 			pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;

  0011e	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]

; 1070 : 			pfile_in_zip_read_info->stream.avail_in -= uDoCopy;
; 1071 : 			pfile_in_zip_read_info->stream.avail_out -= uDoCopy;

  00121	8b 6e 14	 mov	 ebp, DWORD PTR [esi+20]

; 1072 : 			pfile_in_zip_read_info->stream.next_out += uDoCopy;

  00124	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]

; 1073 : 			pfile_in_zip_read_info->stream.next_in += uDoCopy;

  00127	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0012a	89 46 50	 mov	 DWORD PTR [esi+80], eax
  0012d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00130	2b cf		 sub	 ecx, edi
  00132	2b c7		 sub	 eax, edi
  00134	89 4e 5c	 mov	 DWORD PTR [esi+92], ecx

; 1074 :             pfile_in_zip_read_info->stream.total_out += uDoCopy;

  00137	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0013a	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1075 : 			iRead += uDoCopy;

  0013d	8b 44 24 10	 mov	 eax, DWORD PTR _iRead$[esp+24]
  00141	2b ef		 sub	 ebp, edi
  00143	03 df		 add	 ebx, edi
  00145	03 d7		 add	 edx, edi
  00147	03 cf		 add	 ecx, edi
  00149	03 c7		 add	 eax, edi
  0014b	89 6e 14	 mov	 DWORD PTR [esi+20], ebp
  0014e	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00151	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00154	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00157	89 44 24 10	 mov	 DWORD PTR _iRead$[esp+24], eax

; 1076 : 		}
; 1077 : 		else

  0015b	eb 49		 jmp	 SHORT $L2535
$L2518:

; 1078 : 		{
; 1079 : 			uLong uTotalOutBefore,uTotalOutAfter;
; 1080 : 			const Bytef *bufBefore;
; 1081 : 			uLong uOutThis;
; 1082 : 			int flush=Z_SYNC_FLUSH;
; 1083 : 
; 1084 : 			uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;

  0015d	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]

; 1085 : 			bufBefore = pfile_in_zip_read_info->stream.next_out;

  00160	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]

; 1086 : 
; 1087 : 			/*
; 1088 : 			if ((pfile_in_zip_read_info->rest_read_uncompressed ==
; 1089 : 			         pfile_in_zip_read_info->stream.avail_out) &&
; 1090 : 				(pfile_in_zip_read_info->rest_read_compressed == 0))
; 1091 : 				flush = Z_FINISH;
; 1092 : 			*/
; 1093 : 			err=inflate(&pfile_in_zip_read_info->stream,flush);

  00163	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00166	ba 02 00 00 00	 mov	 edx, 2
  0016b	e8 00 00 00 00	 call	 @inflate@8

; 1094 : 
; 1095 : 			uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;

  00170	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]

; 1096 : 			uOutThis = uTotalOutAfter-uTotalOutBefore;
; 1097 : 			
; 1098 : 			pfile_in_zip_read_info->crc32 = 
; 1099 :                 crc32(pfile_in_zip_read_info->crc32,bufBefore,
; 1100 :                         (uInt)(uOutThis));

  00173	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  00176	2b fb		 sub	 edi, ebx
  00178	57		 push	 edi
  00179	8b d5		 mov	 edx, ebp
  0017b	89 44 24 18	 mov	 DWORD PTR _err$[esp+28], eax
  0017f	e8 00 00 00 00	 call	 @crc32@12

; 1101 : 
; 1102 : 			pfile_in_zip_read_info->rest_read_uncompressed -=
; 1103 :                 uOutThis;

  00184	8b 5e 5c	 mov	 ebx, DWORD PTR [esi+92]

; 1104 : 
; 1105 : 			iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);

  00187	8b 54 24 10	 mov	 edx, DWORD PTR _iRead$[esp+24]
  0018b	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1106 :             
; 1107 : 			if (err==Z_STREAM_END)

  0018e	8b 44 24 14	 mov	 eax, DWORD PTR _err$[esp+24]
  00192	2b df		 sub	 ebx, edi
  00194	03 d7		 add	 edx, edi
  00196	83 f8 01	 cmp	 eax, 1
  00199	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx
  0019c	89 54 24 10	 mov	 DWORD PTR _iRead$[esp+24], edx
  001a0	74 3e		 je	 SHORT $L2830

; 1109 : 			if (err!=Z_OK) 

  001a2	85 c0		 test	 eax, eax
  001a4	75 13		 jne	 SHORT $L2835
$L2535:

; 1026 : 
; 1027 : 	while (pfile_in_zip_read_info->stream.avail_out>0)

  001a6	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  001a9	85 c0		 test	 eax, eax
  001ab	0f 87 c4 fe ff
	ff		 ja	 $L2507

; 1110 : 				break;
; 1111 : 		}
; 1112 : 	}
; 1113 : 
; 1114 : 	if (err==Z_OK)

  001b1	8b 44 24 14	 mov	 eax, DWORD PTR _err$[esp+24]
  001b5	85 c0		 test	 eax, eax

; 1115 : 		return iRead;

  001b7	74 27		 je	 SHORT $L2830
$L2835:

; 1116 : 	return err;

  001b9	8b 44 24 14	 mov	 eax, DWORD PTR _err$[esp+24]
  001bd	5f		 pop	 edi
  001be	5d		 pop	 ebp
  001bf	5b		 pop	 ebx
  001c0	5e		 pop	 esi

; 1117 : }

  001c1	83 c4 08	 add	 esp, 8
  001c4	c2 04 00	 ret	 4
$L2827:
  001c7	5f		 pop	 edi
  001c8	5d		 pop	 ebp
  001c9	5b		 pop	 ebx

; 1036 : 				return UNZ_EOF;

  001ca	33 c0		 xor	 eax, eax
  001cc	5e		 pop	 esi

; 1117 : }

  001cd	83 c4 08	 add	 esp, 8
  001d0	c2 04 00	 ret	 4
$L2828:
  001d3	5f		 pop	 edi
  001d4	5d		 pop	 ebp
  001d5	5b		 pop	 ebx

; 1040 : 				return UNZ_ERRNO;

  001d6	83 c8 ff	 or	 eax, -1
  001d9	5e		 pop	 esi

; 1117 : }

  001da	83 c4 08	 add	 esp, 8
  001dd	c2 04 00	 ret	 4
$L2830:

; 1108 : 				return (iRead==0) ? UNZ_EOF : iRead;

  001e0	8b 44 24 10	 mov	 eax, DWORD PTR _iRead$[esp+24]
  001e4	5f		 pop	 edi
  001e5	5d		 pop	 ebp
  001e6	5b		 pop	 ebx
  001e7	5e		 pop	 esi

; 1117 : }

  001e8	83 c4 08	 add	 esp, 8
  001eb	c2 04 00	 ret	 4
@unzReadCurrentFile@12 ENDP
_TEXT	ENDS
PUBLIC	@unztell@4
; Function compile flags: /Ogty
;	COMDAT @unztell@4
_TEXT	SEGMENT
@unztell@4 PROC NEAR					; COMDAT
; _file$ = ecx

; 1126 : 	unz_s* s;
; 1127 : 	file_in_zip_read_info_s* pfile_in_zip_read_info;
; 1128 : 	if (file==NULL)

  00000	85 c9		 test	 ecx, ecx

; 1129 : 		return UNZ_PARAMERROR;

  00002	74 07		 je	 SHORT $L2843

; 1130 : 	s=(unz_s*)file;
; 1131 :     pfile_in_zip_read_info=s->pfile_in_zip_read;

  00004	8b 41 7c	 mov	 eax, DWORD PTR [ecx+124]

; 1132 : 
; 1133 : 	if (pfile_in_zip_read_info==NULL)

  00007	85 c0		 test	 eax, eax
  00009	75 06		 jne	 SHORT $L2546
$L2843:

; 1134 : 		return UNZ_PARAMERROR;

  0000b	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH

; 1137 : }

  00010	c3		 ret	 0
$L2546:

; 1135 : 
; 1136 : 	return (z_off_t)pfile_in_zip_read_info->stream.total_out;

  00011	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 1137 : }

  00014	c3		 ret	 0
@unztell@4 ENDP
_TEXT	ENDS
PUBLIC	@unzeof@4
; Function compile flags: /Ogty
;	COMDAT @unzeof@4
_TEXT	SEGMENT
@unzeof@4 PROC NEAR					; COMDAT
; _file$ = ecx

; 1146 : 	unz_s* s;
; 1147 : 	file_in_zip_read_info_s* pfile_in_zip_read_info;
; 1148 : 	if (file==NULL)

  00000	85 c9		 test	 ecx, ecx

; 1149 : 		return UNZ_PARAMERROR;

  00002	74 07		 je	 SHORT $L2846

; 1150 : 	s=(unz_s*)file;
; 1151 :     pfile_in_zip_read_info=s->pfile_in_zip_read;

  00004	8b 41 7c	 mov	 eax, DWORD PTR [ecx+124]

; 1152 : 
; 1153 : 	if (pfile_in_zip_read_info==NULL)

  00007	85 c0		 test	 eax, eax
  00009	75 06		 jne	 SHORT $L2557
$L2846:

; 1154 : 		return UNZ_PARAMERROR;

  0000b	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH

; 1157 : 		return 1;
; 1158 : 	else
; 1159 : 		return 0;
; 1160 : }

  00010	c3		 ret	 0
$L2557:

; 1155 : 	
; 1156 : 	if (pfile_in_zip_read_info->rest_read_uncompressed == 0)

  00011	8b 50 5c	 mov	 edx, DWORD PTR [eax+92]
  00014	33 c9		 xor	 ecx, ecx
  00016	85 d2		 test	 edx, edx
  00018	0f 94 c1	 sete	 cl
  0001b	8b c1		 mov	 eax, ecx

; 1157 : 		return 1;
; 1158 : 	else
; 1159 : 		return 0;
; 1160 : }

  0001d	c3		 ret	 0
@unzeof@4 ENDP
_TEXT	ENDS
PUBLIC	@unzGetLocalExtrafield@12
; Function compile flags: /Ogty
;	COMDAT @unzGetLocalExtrafield@12
_TEXT	SEGMENT
_len$ = 8						; size = 4
@unzGetLocalExtrafield@12 PROC NEAR			; COMDAT
; _file$ = ecx
; _buf$ = edx

; 1181 : 	unz_s* s;
; 1182 : 	file_in_zip_read_info_s* pfile_in_zip_read_info;
; 1183 : 	uInt read_now;
; 1184 : 	uLong size_to_read;
; 1185 : 
; 1186 : 	if (file==NULL)

  00000	85 c9		 test	 ecx, ecx
  00002	53		 push	 ebx
  00003	8b da		 mov	 ebx, edx
  00005	75 09		 jne	 SHORT $L2570

; 1187 : 		return UNZ_PARAMERROR;

  00007	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  0000c	5b		 pop	 ebx

; 1217 : }

  0000d	c2 04 00	 ret	 4
$L2570:
  00010	56		 push	 esi

; 1188 : 	s=(unz_s*)file;
; 1189 :     pfile_in_zip_read_info=s->pfile_in_zip_read;

  00011	8b 71 7c	 mov	 esi, DWORD PTR [ecx+124]

; 1190 : 
; 1191 : 	if (pfile_in_zip_read_info==NULL)

  00014	85 f6		 test	 esi, esi
  00016	75 0a		 jne	 SHORT $L2573
  00018	5e		 pop	 esi

; 1192 : 		return UNZ_PARAMERROR;

  00019	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  0001e	5b		 pop	 ebx

; 1217 : }

  0001f	c2 04 00	 ret	 4
$L2573:

; 1193 : 
; 1194 : 	size_to_read = (pfile_in_zip_read_info->size_local_extrafield - 
; 1195 : 				pfile_in_zip_read_info->pos_local_extrafield);

  00022	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00025	57		 push	 edi
  00026	8b 7e 48	 mov	 edi, DWORD PTR [esi+72]
  00029	2b f8		 sub	 edi, eax

; 1196 : 
; 1197 : 	if (buf==NULL)

  0002b	85 db		 test	 ebx, ebx
  0002d	75 08		 jne	 SHORT $L2575

; 1198 : 		return (int)size_to_read;

  0002f	8b c7		 mov	 eax, edi
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 1217 : }

  00034	c2 04 00	 ret	 4
$L2575:

; 1199 : 	
; 1200 : 	if (len>size_to_read)

  00037	8b 4c 24 10	 mov	 ecx, DWORD PTR _len$[esp+8]
  0003b	3b cf		 cmp	 ecx, edi
  0003d	55		 push	 ebp

; 1201 : 		read_now = (uInt)size_to_read;

  0003e	8b ef		 mov	 ebp, edi
  00040	77 02		 ja	 SHORT $L2579

; 1202 : 	else
; 1203 : 		read_now = (uInt)len ;

  00042	8b e9		 mov	 ebp, ecx
$L2579:

; 1204 : 
; 1205 : 	if (read_now==0)

  00044	85 ed		 test	 ebp, ebp
  00046	75 09		 jne	 SHORT $L2581
  00048	5d		 pop	 ebp
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi

; 1206 : 		return 0;

  0004b	33 c0		 xor	 eax, eax
  0004d	5b		 pop	 ebx

; 1217 : }

  0004e	c2 04 00	 ret	 4
$L2581:

; 1207 : 	
; 1208 : 	if (fseek(pfile_in_zip_read_info->file,
; 1209 :               pfile_in_zip_read_info->offset_local_extrafield + 
; 1210 : 			  pfile_in_zip_read_info->pos_local_extrafield,SEEK_SET)!=0)

  00051	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00054	8b 56 60	 mov	 edx, DWORD PTR [esi+96]
  00057	6a 00		 push	 0
  00059	03 c8		 add	 ecx, eax
  0005b	51		 push	 ecx
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 _fseek
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	85 c0		 test	 eax, eax
  00067	74 0a		 je	 SHORT $L2582
$L2852:
  00069	5d		 pop	 ebp
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi

; 1211 : 		return UNZ_ERRNO;

  0006c	83 c8 ff	 or	 eax, -1
  0006f	5b		 pop	 ebx

; 1217 : }

  00070	c2 04 00	 ret	 4
$L2582:

; 1212 : 
; 1213 : 	if (fread(buf,(uInt)size_to_read,1,pfile_in_zip_read_info->file)!=1)

  00073	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00076	50		 push	 eax
  00077	6a 01		 push	 1
  00079	57		 push	 edi
  0007a	53		 push	 ebx
  0007b	e8 00 00 00 00	 call	 _fread
  00080	83 c4 10	 add	 esp, 16			; 00000010H
  00083	83 f8 01	 cmp	 eax, 1

; 1214 : 		return UNZ_ERRNO;

  00086	75 e1		 jne	 SHORT $L2852

; 1215 : 
; 1216 : 	return (int)read_now;

  00088	8b c5		 mov	 eax, ebp
  0008a	5d		 pop	 ebp
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 1217 : }

  0008e	c2 04 00	 ret	 4
@unzGetLocalExtrafield@12 ENDP
_TEXT	ENDS
PUBLIC	@unzCloseCurrentFile@4
EXTRN	@inflateEnd@4:NEAR
; Function compile flags: /Ogty
;	COMDAT @unzCloseCurrentFile@4
_TEXT	SEGMENT
@unzCloseCurrentFile@4 PROC NEAR			; COMDAT
; _file$ = ecx

; 1225 : {

  00000	55		 push	 ebp
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1226 : 	int err=UNZ_OK;

  00004	33 ed		 xor	 ebp, ebp

; 1227 : 
; 1228 : 	unz_s* s;
; 1229 : 	file_in_zip_read_info_s* pfile_in_zip_read_info;
; 1230 : 	if (file==NULL)

  00006	85 ff		 test	 edi, edi
  00008	75 08		 jne	 SHORT $L2593
  0000a	5f		 pop	 edi

; 1231 : 		return UNZ_PARAMERROR;

  0000b	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00010	5d		 pop	 ebp

; 1257 : }

  00011	c3		 ret	 0
$L2593:
  00012	56		 push	 esi

; 1232 : 	s=(unz_s*)file;
; 1233 :     pfile_in_zip_read_info=s->pfile_in_zip_read;

  00013	8b 77 7c	 mov	 esi, DWORD PTR [edi+124]

; 1234 : 
; 1235 : 	if (pfile_in_zip_read_info==NULL)

  00016	85 f6		 test	 esi, esi
  00018	75 09		 jne	 SHORT $L2596
  0001a	5e		 pop	 esi
  0001b	5f		 pop	 edi

; 1236 : 		return UNZ_PARAMERROR;

  0001c	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00021	5d		 pop	 ebp

; 1257 : }

  00022	c3		 ret	 0
$L2596:

; 1237 : 
; 1238 : 
; 1239 : 	if (pfile_in_zip_read_info->rest_read_uncompressed == 0)

  00023	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00026	85 c0		 test	 eax, eax
  00028	75 0d		 jne	 SHORT $L2598

; 1240 : 	{
; 1241 : 		if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)

  0002a	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  0002d	3b 46 54	 cmp	 eax, DWORD PTR [esi+84]
  00030	74 05		 je	 SHORT $L2598

; 1242 : 			err=UNZ_CRCERROR;

  00032	bd 97 ff ff ff	 mov	 ebp, -105		; ffffff97H
$L2598:

; 1243 : 	}
; 1244 : 
; 1245 : 
; 1246 : 	TRYFREE(pfile_in_zip_read_info->read_buffer);

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	85 c0		 test	 eax, eax
  0003b	74 09		 je	 SHORT $L2599
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _free
  00043	83 c4 04	 add	 esp, 4
$L2599:

; 1247 : 	pfile_in_zip_read_info->read_buffer = NULL;
; 1248 : 	if (pfile_in_zip_read_info->stream_initialised)

  00046	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00049	85 c0		 test	 eax, eax
  0004b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00051	74 08		 je	 SHORT $L2601

; 1249 : 		inflateEnd(&pfile_in_zip_read_info->stream);

  00053	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00056	e8 00 00 00 00	 call	 @inflateEnd@4
$L2601:

; 1250 : 
; 1251 : 	pfile_in_zip_read_info->stream_initialised = 0;
; 1252 : 	TRYFREE(pfile_in_zip_read_info);

  0005b	56		 push	 esi
  0005c	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
  00063	e8 00 00 00 00	 call	 _free
  00068	83 c4 04	 add	 esp, 4
  0006b	5e		 pop	 esi

; 1253 : 
; 1254 :     s->pfile_in_zip_read=NULL;

  0006c	c7 47 7c 00 00
	00 00		 mov	 DWORD PTR [edi+124], 0
  00073	5f		 pop	 edi

; 1255 : 
; 1256 : 	return err;

  00074	8b c5		 mov	 eax, ebp
  00076	5d		 pop	 ebp

; 1257 : }

  00077	c3		 ret	 0
@unzCloseCurrentFile@4 ENDP
_TEXT	ENDS
PUBLIC	@unzGetGlobalComment@12
; Function compile flags: /Ogty
;	COMDAT @unzGetGlobalComment@12
_TEXT	SEGMENT
_uSizeBuf$ = 8						; size = 4
@unzGetGlobalComment@12 PROC NEAR			; COMDAT
; _file$ = ecx
; _szComment$ = edx

; 1269 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1270 : 	int err=UNZ_OK;
; 1271 : 	unz_s* s;
; 1272 : 	uLong uReadThis ;
; 1273 : 	if (file==NULL)

  00003	85 f6		 test	 esi, esi
  00005	57		 push	 edi
  00006	8b fa		 mov	 edi, edx
  00008	75 0a		 jne	 SHORT $L2613
  0000a	5f		 pop	 edi

; 1274 : 		return UNZ_PARAMERROR;

  0000b	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00010	5e		 pop	 esi

; 1294 : }

  00011	c2 04 00	 ret	 4
$L2613:

; 1275 : 	s=(unz_s*)file;
; 1276 : 
; 1277 : 	uReadThis = uSizeBuf;
; 1278 : 	if (uReadThis>s->gi.size_comment)

  00014	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00017	53		 push	 ebx
  00018	55		 push	 ebp
  00019	8b 6c 24 14	 mov	 ebp, DWORD PTR _uSizeBuf$[esp+12]
  0001d	3b e8		 cmp	 ebp, eax
  0001f	8b dd		 mov	 ebx, ebp
  00021	76 02		 jbe	 SHORT $L2615

; 1279 : 		uReadThis = s->gi.size_comment;

  00023	8b d8		 mov	 ebx, eax
$L2615:

; 1280 : 
; 1281 : 	if (fseek(s->file,s->central_pos+22,SEEK_SET)!=0)

  00025	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00028	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002a	6a 00		 push	 0
  0002c	83 c0 16	 add	 eax, 22			; 00000016H
  0002f	50		 push	 eax
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _fseek
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	85 c0		 test	 eax, eax

; 1282 : 		return UNZ_ERRNO;

  0003b	75 1a		 jne	 SHORT $L2861

; 1283 : 
; 1284 : 	if (uReadThis>0)

  0003d	85 db		 test	 ebx, ebx
  0003f	76 20		 jbe	 SHORT $L2858

; 1285 :     {
; 1286 :       *szComment='\0';

  00041	88 07		 mov	 BYTE PTR [edi], al

; 1287 : 	  if (fread(szComment,(uInt)uReadThis,1,s->file)!=1)

  00043	8b 16		 mov	 edx, DWORD PTR [esi]
  00045	52		 push	 edx
  00046	6a 01		 push	 1
  00048	53		 push	 ebx
  00049	57		 push	 edi
  0004a	e8 00 00 00 00	 call	 _fread
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	83 f8 01	 cmp	 eax, 1
  00055	74 0a		 je	 SHORT $L2858
$L2861:
  00057	5d		 pop	 ebp
  00058	5b		 pop	 ebx
  00059	5f		 pop	 edi

; 1288 : 		return UNZ_ERRNO;

  0005a	83 c8 ff	 or	 eax, -1
  0005d	5e		 pop	 esi

; 1294 : }

  0005e	c2 04 00	 ret	 4
$L2858:

; 1289 :     }
; 1290 : 
; 1291 : 	if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))

  00061	85 ff		 test	 edi, edi
  00063	74 0b		 je	 SHORT $L2621
  00065	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00068	3b ee		 cmp	 ebp, esi
  0006a	76 04		 jbe	 SHORT $L2621

; 1292 : 		*(szComment+s->gi.size_comment)='\0';

  0006c	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
$L2621:
  00070	5d		 pop	 ebp

; 1293 : 	return (int)uReadThis;

  00071	8b c3		 mov	 eax, ebx
  00073	5b		 pop	 ebx
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi

; 1294 : }

  00076	c2 04 00	 ret	 4
@unzGetGlobalComment@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	@unzOpen@4
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @unzOpen@4
_TEXT	SEGMENT
_number_disk$ = -140					; size = 4
_uL$ = -140						; size = 4
_number_disk_with_CD$ = -136				; size = 4
_number_entry_CD$ = -132				; size = 4
_us$ = -128						; size = 128
@unzOpen@4 PROC NEAR					; COMDAT
; _path$ = ecx

; 344  : {

  00000	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 345  : 	unz_s us;
; 346  : 	unz_s *s;
; 347  : 	uLong central_pos,uL;
; 348  : 	FILE * fin ;
; 349  : 
; 350  : 	uLong number_disk;          /* number of the current dist, used for 
; 351  : 								   spaning ZIP, unsupported, always 0*/
; 352  : 	uLong number_disk_with_CD;  /* number the the disk with central dir, used
; 353  : 								   for spaning ZIP, unsupported, always 0*/
; 354  : 	uLong number_entry_CD;      /* total number of entries in
; 355  : 	                               the central dir 
; 356  : 	                               (same than number_entry on nospan) */
; 357  : 
; 358  : 	int err=UNZ_OK;
; 359  : 
; 360  :     if (unz_copyright[0]!=' ')
; 361  :         return NULL;
; 362  : 
; 363  :     fin=fopen(path,"rb");

  00008	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  0000d	51		 push	 ecx
  0000e	33 f6		 xor	 esi, esi
  00010	e8 00 00 00 00	 call	 _fopen
  00015	8b f8		 mov	 edi, eax
  00017	83 c4 08	 add	 esp, 8

; 364  : 	if (fin==NULL)

  0001a	85 ff		 test	 edi, edi
  0001c	75 09		 jne	 SHORT $L2205
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 433  : }

  00020	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00026	c3		 ret	 0
$L2205:
  00027	53		 push	 ebx

; 365  : 		return NULL;
; 366  : 
; 367  : 	central_pos = unzlocal_SearchCentralDir(fin);

  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 @unzlocal_SearchCentralDir@4
  0002e	8b d8		 mov	 ebx, eax

; 368  : 	if (central_pos==0)

  00030	85 db		 test	 ebx, ebx
  00032	75 03		 jne	 SHORT $L2207

; 369  : 		err=UNZ_ERRNO;

  00034	83 ce ff	 or	 esi, -1
$L2207:

; 370  : 
; 371  : 	if (fseek(fin,central_pos,SEEK_SET)!=0)

  00037	6a 00		 push	 0
  00039	53		 push	 ebx
  0003a	57		 push	 edi
  0003b	e8 00 00 00 00	 call	 _fseek
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	85 c0		 test	 eax, eax
  00045	74 03		 je	 SHORT $L2208

; 372  : 		err=UNZ_ERRNO;

  00047	83 ce ff	 or	 esi, -1
$L2208:

; 373  : 
; 374  : 	/* the signature, already checked */
; 375  : 	if (unzlocal_getLong(fin,&uL)!=UNZ_OK)

  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR _uL$[esp+152]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  00054	85 c0		 test	 eax, eax
  00056	74 03		 je	 SHORT $L2209

; 376  : 		err=UNZ_ERRNO;

  00058	83 ce ff	 or	 esi, -1
$L2209:

; 377  : 
; 378  : 	/* number of this disk */
; 379  : 	if (unzlocal_getShort(fin,&number_disk)!=UNZ_OK)

  0005b	8d 4c 24 0c	 lea	 ecx, DWORD PTR _number_disk$[esp+152]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00065	85 c0		 test	 eax, eax
  00067	74 03		 je	 SHORT $L2210

; 380  : 		err=UNZ_ERRNO;

  00069	83 ce ff	 or	 esi, -1
$L2210:

; 381  : 
; 382  : 	/* number of the disk with the start of the central directory */
; 383  : 	if (unzlocal_getShort(fin,&number_disk_with_CD)!=UNZ_OK)

  0006c	8d 54 24 10	 lea	 edx, DWORD PTR _number_disk_with_CD$[esp+152]
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00076	85 c0		 test	 eax, eax
  00078	74 03		 je	 SHORT $L2211

; 384  : 		err=UNZ_ERRNO;

  0007a	83 ce ff	 or	 esi, -1
$L2211:

; 385  : 
; 386  : 	/* total number of entries in the central dir on this disk */
; 387  : 	if (unzlocal_getShort(fin,&us.gi.number_entry)!=UNZ_OK)

  0007d	8d 44 24 1c	 lea	 eax, DWORD PTR _us$[esp+156]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00087	85 c0		 test	 eax, eax
  00089	74 03		 je	 SHORT $L2212

; 388  : 		err=UNZ_ERRNO;

  0008b	83 ce ff	 or	 esi, -1
$L2212:

; 389  : 
; 390  : 	/* total number of entries in the central dir */
; 391  : 	if (unzlocal_getShort(fin,&number_entry_CD)!=UNZ_OK)

  0008e	8d 4c 24 14	 lea	 ecx, DWORD PTR _number_entry_CD$[esp+152]
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  00098	85 c0		 test	 eax, eax
  0009a	74 03		 je	 SHORT $L2213

; 392  : 		err=UNZ_ERRNO;

  0009c	83 ce ff	 or	 esi, -1
$L2213:

; 393  : 
; 394  : 	if ((number_entry_CD!=us.gi.number_entry) ||
; 395  : 		(number_disk_with_CD!=0) ||
; 396  : 		(number_disk!=0))

  0009f	8b 54 24 14	 mov	 edx, DWORD PTR _number_entry_CD$[esp+152]
  000a3	3b 54 24 1c	 cmp	 edx, DWORD PTR _us$[esp+156]
  000a7	75 10		 jne	 SHORT $L2215
  000a9	8b 44 24 10	 mov	 eax, DWORD PTR _number_disk_with_CD$[esp+152]
  000ad	85 c0		 test	 eax, eax
  000af	75 08		 jne	 SHORT $L2215
  000b1	8b 44 24 0c	 mov	 eax, DWORD PTR _number_disk$[esp+152]
  000b5	85 c0		 test	 eax, eax
  000b7	74 05		 je	 SHORT $L2214
$L2215:

; 397  : 		err=UNZ_BADZIPFILE;

  000b9	be 99 ff ff ff	 mov	 esi, -103		; ffffff99H
$L2214:

; 398  : 
; 399  : 	/* size of the central directory */
; 400  : 	if (unzlocal_getLong(fin,&us.size_central_dir)!=UNZ_OK)

  000be	8d 44 24 38	 lea	 eax, DWORD PTR _us$[esp+184]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  000c8	85 c0		 test	 eax, eax
  000ca	74 03		 je	 SHORT $L2216

; 401  : 		err=UNZ_ERRNO;

  000cc	83 ce ff	 or	 esi, -1
$L2216:

; 402  : 
; 403  : 	/* offset of start of central directory with respect to the 
; 404  : 	      starting disk number */
; 405  : 	if (unzlocal_getLong(fin,&us.offset_central_dir)!=UNZ_OK)

  000cf	8d 4c 24 3c	 lea	 ecx, DWORD PTR _us$[esp+188]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 @unzlocal_getLong@8
  000d9	85 c0		 test	 eax, eax
  000db	74 03		 je	 SHORT $L2217

; 406  : 		err=UNZ_ERRNO;

  000dd	83 ce ff	 or	 esi, -1
$L2217:

; 407  : 
; 408  : 	/* zipfile comment length */
; 409  : 	if (unzlocal_getShort(fin,&us.gi.size_comment)!=UNZ_OK)

  000e0	8d 54 24 20	 lea	 edx, DWORD PTR _us$[esp+160]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 @unzlocal_getShort@8
  000ea	85 c0		 test	 eax, eax
  000ec	74 03		 je	 SHORT $L2218

; 410  : 		err=UNZ_ERRNO;

  000ee	83 ce ff	 or	 esi, -1
$L2218:

; 411  : 
; 412  : 	if ((central_pos<us.offset_central_dir+us.size_central_dir) && 
; 413  : 		(err==UNZ_OK))

  000f1	8b 44 24 38	 mov	 eax, DWORD PTR _us$[esp+184]
  000f5	8b 4c 24 3c	 mov	 ecx, DWORD PTR _us$[esp+188]
  000f9	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  000fc	3b da		 cmp	 ebx, edx

; 414  : 		err=UNZ_BADZIPFILE;
; 415  : 
; 416  : 	if (err!=UNZ_OK)

  000fe	72 04		 jb	 SHORT $L2864
  00100	85 f6		 test	 esi, esi
  00102	74 15		 je	 SHORT $L2220
$L2864:

; 417  : 	{
; 418  : 		fclose(fin);

  00104	57		 push	 edi
  00105	e8 00 00 00 00	 call	 _fclose
  0010a	83 c4 04	 add	 esp, 4
  0010d	5b		 pop	 ebx
  0010e	5f		 pop	 edi

; 419  : 		return NULL;

  0010f	33 c0		 xor	 eax, eax
  00111	5e		 pop	 esi

; 433  : }

  00112	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00118	c3		 ret	 0
$L2220:

; 420  : 	}
; 421  : 
; 422  : 	us.file=fin;
; 423  : 	us.byte_before_the_zipfile = central_pos -
; 424  : 		                    (us.offset_central_dir+us.size_central_dir);

  00119	8b d3		 mov	 edx, ebx
  0011b	2b d0		 sub	 edx, eax
  0011d	2b d1		 sub	 edx, ecx

; 425  : 	us.central_pos = central_pos;
; 426  :     us.pfile_in_zip_read = NULL;
; 427  : 	
; 428  : 
; 429  : 	s=(unz_s*)ALLOC(sizeof(unz_s));

  0011f	68 80 00 00 00	 push	 128			; 00000080H
  00124	89 7c 24 1c	 mov	 DWORD PTR _us$[esp+156], edi
  00128	89 54 24 28	 mov	 DWORD PTR _us$[esp+168], edx
  0012c	89 5c 24 38	 mov	 DWORD PTR _us$[esp+184], ebx
  00130	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _us$[esp+280], 0
  0013b	e8 00 00 00 00	 call	 _malloc
  00140	8b d8		 mov	 ebx, eax

; 430  : 	*s=us;

  00142	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00147	8d 74 24 1c	 lea	 esi, DWORD PTR _us$[esp+156]
  0014b	8b fb		 mov	 edi, ebx
  0014d	f3 a5		 rep movsd
  0014f	83 c4 04	 add	 esp, 4

; 431  : 	unzGoToFirstFile((unzFile)s);	

  00152	8b cb		 mov	 ecx, ebx
  00154	e8 00 00 00 00	 call	 @unzGoToFirstFile@4

; 432  : 	return (unzFile)s;	

  00159	8b c3		 mov	 eax, ebx
  0015b	5b		 pop	 ebx
  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi

; 433  : }

  0015e	81 c4 8c 00 00
	00		 add	 esp, 140		; 0000008cH
  00164	c3		 ret	 0
@unzOpen@4 ENDP
_TEXT	ENDS
PUBLIC	@unzClose@4
; Function compile flags: /Ogty
;	COMDAT @unzClose@4
_TEXT	SEGMENT
@unzClose@4 PROC NEAR					; COMDAT
; _file$ = ecx

; 443  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 444  : 	unz_s* s;
; 445  : 	if (file==NULL)

  00003	85 f6		 test	 esi, esi
  00005	75 07		 jne	 SHORT $L2232

; 446  : 		return UNZ_PARAMERROR;

  00007	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  0000c	5e		 pop	 esi

; 455  : }

  0000d	c3		 ret	 0
$L2232:

; 447  : 	s=(unz_s*)file;
; 448  : 
; 449  :     if (s->pfile_in_zip_read!=NULL)

  0000e	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00011	85 c0		 test	 eax, eax
  00013	74 07		 je	 SHORT $L2235

; 450  :         unzCloseCurrentFile(file);

  00015	8b ce		 mov	 ecx, esi
  00017	e8 00 00 00 00	 call	 @unzCloseCurrentFile@4
$L2235:

; 451  : 
; 452  : 	fclose(s->file);

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _fclose

; 453  : 	TRYFREE(s);

  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 _free
  0002a	83 c4 08	 add	 esp, 8

; 454  : 	return UNZ_OK;

  0002d	33 c0		 xor	 eax, eax
  0002f	5e		 pop	 esi

; 455  : }

  00030	c3		 ret	 0
@unzClose@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_05DOIEBMOI@1?41?44?$AA@			; `string'
PUBLIC	@unzOpenCurrentFile@4
EXTRN	@inflateInit2_@16:NEAR
;	COMDAT ??_C@_05DOIEBMOI@1?41?44?$AA@
CONST	SEGMENT
??_C@_05DOIEBMOI@1?41?44?$AA@ DB '1.1.4', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @unzOpenCurrentFile@4
_TEXT	SEGMENT
_offset_local_extrafield$ = -12				; size = 4
_size_local_extrafield$ = -8				; size = 4
_iSizeVar$ = -4						; size = 4
@unzOpenCurrentFile@4 PROC NEAR				; COMDAT
; _file$ = ecx

; 897  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 898  : 	int err=UNZ_OK;
; 899  : 	int Store;
; 900  : 	uInt iSizeVar;
; 901  : 	unz_s* s;
; 902  : 	file_in_zip_read_info_s* pfile_in_zip_read_info;
; 903  : 	uLong offset_local_extrafield;  /* offset of the local extra field */
; 904  : 	uInt  size_local_extrafield;    /* size of the local extra field */
; 905  : 
; 906  : 	if (file==NULL)

  00007	33 db		 xor	 ebx, ebx
  00009	3b fb		 cmp	 edi, ebx

; 907  : 		return UNZ_PARAMERROR;

  0000b	74 05		 je	 SHORT $L2872

; 908  : 	s=(unz_s*)file;
; 909  : 	if (!s->current_file_ok)

  0000d	39 5f 18	 cmp	 DWORD PTR [edi+24], ebx
  00010	75 0b		 jne	 SHORT $L2464
$L2872:
  00012	5f		 pop	 edi

; 910  : 		return UNZ_PARAMERROR;

  00013	b8 9a ff ff ff	 mov	 eax, -102		; ffffff9aH
  00018	5b		 pop	 ebx

; 983  : }

  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	c3		 ret	 0
$L2464:

; 911  : 
; 912  :     if (s->pfile_in_zip_read != NULL)

  0001d	39 5f 7c	 cmp	 DWORD PTR [edi+124], ebx
  00020	74 07		 je	 SHORT $L2466

; 913  :         unzCloseCurrentFile(file);

  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 @unzCloseCurrentFile@4
$L2466:

; 914  : 
; 915  : 	if (unzlocal_CheckCurrentFileCoherencyHeader(s,&iSizeVar,
; 916  : 				&offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)

  00029	8d 44 24 0c	 lea	 eax, DWORD PTR _size_local_extrafield$[esp+20]
  0002d	50		 push	 eax
  0002e	8d 4c 24 0c	 lea	 ecx, DWORD PTR _offset_local_extrafield$[esp+24]
  00032	51		 push	 ecx
  00033	8d 54 24 18	 lea	 edx, DWORD PTR _iSizeVar$[esp+28]
  00037	52		 push	 edx
  00038	57		 push	 edi
  00039	e8 00 00 00 00	 call	 @unzlocal_CheckCurrentFileCoherencyHeader@16
  0003e	85 c0		 test	 eax, eax
  00040	74 0b		 je	 SHORT $L2467
  00042	5f		 pop	 edi

; 917  : 		return UNZ_BADZIPFILE;

  00043	b8 99 ff ff ff	 mov	 eax, -103		; ffffff99H
  00048	5b		 pop	 ebx

; 983  : }

  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	c3		 ret	 0
$L2467:
  0004d	56		 push	 esi

; 918  : 
; 919  : 	pfile_in_zip_read_info = (file_in_zip_read_info_s*)
; 920  : 									    ALLOC(sizeof(file_in_zip_read_info_s));

  0004e	6a 6c		 push	 108			; 0000006cH
  00050	e8 00 00 00 00	 call	 _malloc
  00055	8b f0		 mov	 esi, eax
  00057	83 c4 04	 add	 esp, 4

; 921  : 	if (pfile_in_zip_read_info==NULL)

  0005a	3b f3		 cmp	 esi, ebx

; 922  : 		return UNZ_INTERNALERROR;

  0005c	74 2d		 je	 SHORT $L2871

; 923  : 
; 924  : 	pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);

  0005e	68 00 40 00 00	 push	 16384			; 00004000H
  00063	e8 00 00 00 00	 call	 _malloc

; 925  : 	pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;

  00068	8b 4c 24 10	 mov	 ecx, DWORD PTR _offset_local_extrafield$[esp+28]

; 926  : 	pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;

  0006c	8b 54 24 14	 mov	 edx, DWORD PTR _size_local_extrafield$[esp+28]
  00070	83 c4 04	 add	 esp, 4

; 927  : 	pfile_in_zip_read_info->pos_local_extrafield=0;
; 928  : 
; 929  : 	if (pfile_in_zip_read_info->read_buffer==NULL)

  00073	3b c3		 cmp	 eax, ebx
  00075	89 06		 mov	 DWORD PTR [esi], eax
  00077	89 4e 44	 mov	 DWORD PTR [esi+68], ecx
  0007a	89 56 48	 mov	 DWORD PTR [esi+72], edx
  0007d	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
  00080	75 15		 jne	 SHORT $L2474

; 930  : 	{
; 931  : 		TRYFREE(pfile_in_zip_read_info);

  00082	56		 push	 esi
  00083	e8 00 00 00 00	 call	 _free
  00088	83 c4 04	 add	 esp, 4
$L2871:
  0008b	5e		 pop	 esi
  0008c	5f		 pop	 edi

; 932  : 		return UNZ_INTERNALERROR;

  0008d	b8 98 ff ff ff	 mov	 eax, -104		; ffffff98H
  00092	5b		 pop	 ebx

; 983  : }

  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
  00096	c3		 ret	 0
$L2474:

; 933  : 	}
; 934  : 
; 935  : 	pfile_in_zip_read_info->stream_initialised=0;

  00097	89 5e 40	 mov	 DWORD PTR [esi+64], ebx

; 936  : 	
; 937  : 	if ((s->cur_file_info.compression_method!=0) &&
; 938  :         (s->cur_file_info.compression_method!=Z_DEFLATED))
; 939  : 		err=UNZ_BADZIPFILE;
; 940  : 	Store = s->cur_file_info.compression_method==0;

  0009a	8b 57 34	 mov	 edx, DWORD PTR [edi+52]

; 941  : 
; 942  : 	pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;

  0009d	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  000a0	33 c0		 xor	 eax, eax
  000a2	3b d3		 cmp	 edx, ebx
  000a4	89 4e 54	 mov	 DWORD PTR [esi+84], ecx

; 943  : 	pfile_in_zip_read_info->crc32=0;

  000a7	89 5e 50	 mov	 DWORD PTR [esi+80], ebx

; 944  : 	pfile_in_zip_read_info->compression_method =
; 945  :             s->cur_file_info.compression_method;

  000aa	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  000ad	0f 94 c0	 sete	 al
  000b0	89 56 64	 mov	 DWORD PTR [esi+100], edx

; 946  : 	pfile_in_zip_read_info->file=s->file;

  000b3	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000b5	89 4e 60	 mov	 DWORD PTR [esi+96], ecx

; 947  : 	pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;

  000b8	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  000bb	89 56 68	 mov	 DWORD PTR [esi+104], edx

; 948  : 
; 949  :     pfile_in_zip_read_info->stream.total_out = 0;

  000be	89 5e 18	 mov	 DWORD PTR [esi+24], ebx

; 950  : 
; 951  : 	if (!Store)

  000c1	3b c3		 cmp	 eax, ebx
  000c3	75 28		 jne	 SHORT $L2483

; 952  : 	{
; 953  : 	  pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
; 954  : 	  pfile_in_zip_read_info->stream.zfree = (free_func)0;
; 955  : 	  pfile_in_zip_read_info->stream.opaque = (voidpf)0; 
; 956  :       
; 957  : 	  err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);

  000c5	6a 38		 push	 56			; 00000038H
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05DOIEBMOI@1?41?44?$AA@
  000cc	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000cf	ba f1 ff ff ff	 mov	 edx, -15		; fffffff1H
  000d4	89 5e 24	 mov	 DWORD PTR [esi+36], ebx
  000d7	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
  000da	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx
  000dd	e8 00 00 00 00	 call	 @inflateInit2_@16

; 958  : 	  if (err == Z_OK)

  000e2	85 c0		 test	 eax, eax
  000e4	75 07		 jne	 SHORT $L2483

; 959  : 	    pfile_in_zip_read_info->stream_initialised=1;

  000e6	c7 46 40 01 00
	00 00		 mov	 DWORD PTR [esi+64], 1
$L2483:

; 960  :         /* windowBits is passed < 0 to tell that there is no zlib header.
; 961  :          * Note that in this case inflate *requires* an extra "dummy" byte
; 962  :          * after the compressed stream in order to complete decompression and
; 963  :          * return Z_STREAM_END. 
; 964  :          * In unzip, i don't wait absolutely Z_STREAM_END because I known the 
; 965  :          * size of both compressed and uncompressed data
; 966  :          */
; 967  : 	}
; 968  : 	pfile_in_zip_read_info->rest_read_compressed = 
; 969  :             s->cur_file_info.compressed_size ;

  000ed	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  000f0	89 46 58	 mov	 DWORD PTR [esi+88], eax

; 970  : 	pfile_in_zip_read_info->rest_read_uncompressed = 
; 971  :             s->cur_file_info.uncompressed_size ;

  000f3	8b 4f 44	 mov	 ecx, DWORD PTR [edi+68]

; 972  : 
; 973  : 	
; 974  : 	pfile_in_zip_read_info->pos_in_zipfile = 
; 975  :             s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER + 
; 976  : 			  iSizeVar;

  000f6	8b 44 24 14	 mov	 eax, DWORD PTR _iSizeVar$[esp+24]
  000fa	89 4e 5c	 mov	 DWORD PTR [esi+92], ecx
  000fd	8b 57 78	 mov	 edx, DWORD PTR [edi+120]
  00100	8d 4c 02 1e	 lea	 ecx, DWORD PTR [edx+eax+30]

; 977  : 	
; 978  : 	pfile_in_zip_read_info->stream.avail_in = (uInt)0;

  00104	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00107	89 4e 3c	 mov	 DWORD PTR [esi+60], ecx

; 979  : 
; 980  : 
; 981  : 	s->pfile_in_zip_read = pfile_in_zip_read_info;

  0010a	89 77 7c	 mov	 DWORD PTR [edi+124], esi
  0010d	5e		 pop	 esi
  0010e	5f		 pop	 edi

; 982  :     return UNZ_OK;

  0010f	33 c0		 xor	 eax, eax
  00111	5b		 pop	 ebx

; 983  : }

  00112	83 c4 0c	 add	 esp, 12			; 0000000cH
  00115	c3		 ret	 0
@unzOpenCurrentFile@4 ENDP
_TEXT	ENDS
END
