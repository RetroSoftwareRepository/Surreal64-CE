; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\deflate.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_05DOIEBMOI@1?41?44?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT @deflateInit_@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @deflateInit2_@32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @deflateSetDictionary@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @deflateReset@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @deflateParams@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @putShortMSB@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @flush_pending@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @deflate@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @deflateEnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @deflateCopy@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @read_buf@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @lm_init@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @fill_window@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @deflate_stored@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @deflate_fast@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @deflate_slow@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_deflate_copyright
PUBLIC	??_C@_05DOIEBMOI@1?41?44?$AA@			; `string'
CONST	SEGMENT
_deflate_copyright DB ' deflate 1.1.4 Copyright 1995-2002 Jean-loup Gaill'
	DB	'y ', 00H
	ORG $+3
_configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DD	FLAT:@deflate_stored@8
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DD	FLAT:@deflate_fast@8
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DD	FLAT:@deflate_fast@8
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DD	FLAT:@deflate_fast@8
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DD	FLAT:@deflate_slow@8
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DD	FLAT:@deflate_slow@8
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DD	FLAT:@deflate_slow@8
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DD	FLAT:@deflate_slow@8
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DD	FLAT:@deflate_slow@8
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DD	FLAT:@deflate_slow@8
CONST	ENDS
;	COMDAT ??_C@_05DOIEBMOI@1?41?44?$AA@
CONST	SEGMENT
??_C@_05DOIEBMOI@1?41?44?$AA@ DB '1.1.4', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?my_version@?1??deflateInit2_@@9@9 DD FLAT:??_C@_05DOIEBMOI@1?41?44?$AA@ ; `deflateInit2_'::`2'::my_version
_DATA	ENDS
PUBLIC	@deflateSetDictionary@12
EXTRN	@adler32@12:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\deflate.c
;	COMDAT @deflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = -4						; size = 4
_dictLength$ = 8					; size = 4
@deflateSetDictionary@12 PROC NEAR			; COMDAT
; _strm$ = ecx
; _dictionary$ = edx

; 295  : {

  00000	51		 push	 ecx

; 296  :     deflate_state *s;
; 297  :     uInt length = dictLength;
; 298  :     uInt n;
; 299  :     IPos hash_head = 0;
; 300  : 
; 301  :     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
; 302  :         strm->state->status != INIT_STATE) return Z_STREAM_ERROR;

  00001	85 c9		 test	 ecx, ecx
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 18	 mov	 edi, DWORD PTR _dictLength$[esp+16]
  0000b	8b f2		 mov	 esi, edx
  0000d	89 4c 24 10	 mov	 DWORD PTR _strm$[esp+20], ecx
  00011	8b ef		 mov	 ebp, edi
  00013	0f 84 ce 00 00
	00		 je	 $L1883
  00019	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  0001c	85 db		 test	 ebx, ebx
  0001e	0f 84 c3 00 00
	00		 je	 $L1883
  00024	85 f6		 test	 esi, esi
  00026	0f 84 bb 00 00
	00		 je	 $L1883
  0002c	83 7b 04 2a	 cmp	 DWORD PTR [ebx+4], 42	; 0000002aH
  00030	0f 85 b1 00 00
	00		 jne	 $L1883

; 303  : 
; 304  :     s = strm->state;
; 305  :     strm->adler = adler32(strm->adler, dictionary, dictLength);

  00036	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 @adler32@12

; 306  : 
; 307  :     if (length < MIN_MATCH) return Z_OK;

  0003f	83 ff 03	 cmp	 edi, 3
  00042	8b 4c 24 10	 mov	 ecx, DWORD PTR _strm$[esp+20]
  00046	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00049	0f 82 8e 00 00
	00		 jb	 $L2234

; 308  :     if (length > MAX_DIST(s)) {

  0004f	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00052	05 fa fe ff ff	 add	 eax, -262		; fffffefaH
  00057	3b f8		 cmp	 edi, eax
  00059	76 06		 jbe	 SHORT $L1885

; 309  : 	length = MAX_DIST(s);

  0005b	8b e8		 mov	 ebp, eax

; 310  : #ifndef USE_DICT_HEAD
; 311  : 	dictionary += dictLength - length; /* use the tail of the dictionary */

  0005d	2b fd		 sub	 edi, ebp
  0005f	03 f7		 add	 esi, edi
$L1885:

; 312  : #endif
; 313  :     }
; 314  :     zmemcpy(s->window, dictionary, length);

  00061	8b 7b 30	 mov	 edi, DWORD PTR [ebx+48]
  00064	8b cd		 mov	 ecx, ebp
  00066	8b d1		 mov	 edx, ecx
  00068	c1 e9 02	 shr	 ecx, 2
  0006b	f3 a5		 rep movsd
  0006d	8b ca		 mov	 ecx, edx
  0006f	83 e1 03	 and	 ecx, 3
  00072	f3 a4		 rep movsb

; 315  :     s->strstart = length;
; 316  :     s->block_start = (long)length;
; 317  : 
; 318  :     /* Insert all strings in the hash table (except for the last two bytes).
; 319  :      * s->lookahead stays null, so s->ins_h will be recomputed at the next
; 320  :      * call of fill_window.
; 321  :      */
; 322  :     s->ins_h = s->window[0];

  00074	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]

; 323  :     UPDATE_HASH(s, s->ins_h, s->window[1]);

  00077	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  0007a	89 6b 64	 mov	 DWORD PTR [ebx+100], ebp
  0007d	89 6b 54	 mov	 DWORD PTR [ebx+84], ebp
  00080	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00083	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  00086	d3 e0		 shl	 eax, cl
  00088	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  0008c	33 c1		 xor	 eax, ecx
  0008e	23 43 4c	 and	 eax, DWORD PTR [ebx+76]
  00091	89 43 40	 mov	 DWORD PTR [ebx+64], eax

; 324  :     for (n = 0; n <= length - MIN_MATCH; n++) {

  00094	33 d2		 xor	 edx, edx
  00096	8d 75 fd	 lea	 esi, DWORD PTR [ebp-3]
  00099	8d a4 24 00 00
	00 00		 npad	 7
$L1887:

; 325  : 	INSERT_STRING(s, n, hash_head);

  000a0	8b 7b 40	 mov	 edi, DWORD PTR [ebx+64]
  000a3	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  000a6	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000a9	0f b6 44 10 02	 movzx	 eax, BYTE PTR [eax+edx+2]
  000ae	8b 6b 38	 mov	 ebp, DWORD PTR [ebx+56]
  000b1	d3 e7		 shl	 edi, cl
  000b3	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  000b6	33 c7		 xor	 eax, edi
  000b8	8b 7b 2c	 mov	 edi, DWORD PTR [ebx+44]
  000bb	23 c1		 and	 eax, ecx
  000bd	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  000c0	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  000c3	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  000c7	23 fa		 and	 edi, edx
  000c9	66 89 44 7d 00	 mov	 WORD PTR [ebp+edi*2], ax
  000ce	8b 4b 40	 mov	 ecx, DWORD PTR [ebx+64]
  000d1	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  000d4	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  000d8	42		 inc	 edx
  000d9	3b d6		 cmp	 edx, esi
  000db	76 c3		 jbe	 SHORT $L1887
$L2234:
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	5d		 pop	 ebp

; 326  :     }
; 327  :     if (hash_head) hash_head = 0;  /* to make compiler happy */
; 328  :     return Z_OK;

  000e0	33 c0		 xor	 eax, eax
  000e2	5b		 pop	 ebx

; 329  : }

  000e3	59		 pop	 ecx
  000e4	c2 04 00	 ret	 4
$L1883:
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5d		 pop	 ebp

; 296  :     deflate_state *s;
; 297  :     uInt length = dictLength;
; 298  :     uInt n;
; 299  :     IPos hash_head = 0;
; 300  : 
; 301  :     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
; 302  :         strm->state->status != INIT_STATE) return Z_STREAM_ERROR;

  000ea	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000ef	5b		 pop	 ebx

; 329  : }

  000f0	59		 pop	 ecx
  000f1	c2 04 00	 ret	 4
@deflateSetDictionary@12 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @putShortMSB@8
_TEXT	SEGMENT
@putShortMSB@8 PROC NEAR				; COMDAT
; _s$ = eax
; _b$ = ecx

; 405  : {

  00000	56		 push	 esi

; 406  :     put_byte(s, (Byte)(b >> 8));

  00001	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00004	8b d1		 mov	 edx, ecx
  00006	57		 push	 edi
  00007	8b 78 14	 mov	 edi, DWORD PTR [eax+20]
  0000a	c1 ea 08	 shr	 edx, 8
  0000d	88 14 3e	 mov	 BYTE PTR [esi+edi], dl
  00010	8b 50 14	 mov	 edx, DWORD PTR [eax+20]

; 407  :     put_byte(s, (Byte)(b & 0xff));

  00013	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00016	42		 inc	 edx
  00017	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0001a	88 0c 32	 mov	 BYTE PTR [edx+esi], cl
  0001d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00020	41		 inc	 ecx
  00021	5f		 pop	 edi
  00022	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00025	5e		 pop	 esi

; 408  : }   

  00026	c3		 ret	 0
@putShortMSB@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @flush_pending@4
_TEXT	SEGMENT
@flush_pending@4 PROC NEAR				; COMDAT
; _strm$ = eax

; 419  :     unsigned len = strm->state->pending;
; 420  : 
; 421  :     if (len > strm->avail_out) len = strm->avail_out;

  00000	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00003	56		 push	 esi
  00004	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00007	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0000a	3b d1		 cmp	 edx, ecx
  0000c	76 02		 jbe	 SHORT $L1925
  0000e	8b d1		 mov	 edx, ecx
$L1925:

; 422  :     if (len == 0) return;

  00010	85 d2		 test	 edx, edx
  00012	74 4e		 je	 SHORT $L1927

; 423  : 
; 424  :     zmemcpy(strm->next_out, strm->state->pending_out, len);

  00014	8b 76 10	 mov	 esi, DWORD PTR [esi+16]
  00017	53		 push	 ebx
  00018	57		 push	 edi
  00019	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0001c	8b ca		 mov	 ecx, edx
  0001e	8b d9		 mov	 ebx, ecx
  00020	c1 e9 02	 shr	 ecx, 2
  00023	f3 a5		 rep movsd
  00025	8b cb		 mov	 ecx, ebx
  00027	83 e1 03	 and	 ecx, 3
  0002a	f3 a4		 rep movsb

; 425  :     strm->next_out  += len;

  0002c	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]

; 426  :     strm->state->pending_out  += len;

  0002f	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00032	03 fa		 add	 edi, edx
  00034	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00037	01 51 10	 add	 DWORD PTR [ecx+16], edx

; 427  :     strm->total_out += len;

  0003a	8b 58 14	 mov	 ebx, DWORD PTR [eax+20]

; 428  :     strm->avail_out  -= len;

  0003d	8b 78 10	 mov	 edi, DWORD PTR [eax+16]

; 429  :     strm->state->pending -= len;

  00040	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00043	03 da		 add	 ebx, edx
  00045	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  00048	2b fa		 sub	 edi, edx
  0004a	89 78 10	 mov	 DWORD PTR [eax+16], edi
  0004d	29 51 14	 sub	 DWORD PTR [ecx+20], edx

; 430  :     if (strm->state->pending == 0) {

  00050	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00053	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00056	85 c9		 test	 ecx, ecx
  00058	5f		 pop	 edi
  00059	5b		 pop	 ebx
  0005a	75 06		 jne	 SHORT $L1927

; 431  :         strm->state->pending_out = strm->state->pending_buf;

  0005c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005f	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$L1927:
  00062	5e		 pop	 esi

; 432  :     }
; 433  : }

  00063	c3		 ret	 0
@flush_pending@4 ENDP
_TEXT	ENDS
PUBLIC	@deflate@8
EXTRN	_z_errmsg:BYTE
EXTRN	@_tr_align@4:NEAR
EXTRN	@_tr_stored_block@16:NEAR
; Function compile flags: /Ogty
;	COMDAT @deflate@8
_TEXT	SEGMENT
_old_flush$ = -4					; size = 4
@deflate@8 PROC NEAR					; COMDAT
; _strm$ = ecx
; _flush$ = edx

; 439  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	8b d9		 mov	 ebx, ecx

; 440  :     int old_flush; /* value of flush param for previous deflate call */
; 441  :     deflate_state *s;
; 442  : 
; 443  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 444  : 	flush > Z_FINISH || flush < 0) {

  00005	85 db		 test	 ebx, ebx
  00007	56		 push	 esi
  00008	8b ea		 mov	 ebp, edx
  0000a	0f 84 74 02 00
	00		 je	 $L1935
  00010	8b 73 1c	 mov	 esi, DWORD PTR [ebx+28]
  00013	85 f6		 test	 esi, esi
  00015	0f 84 69 02 00
	00		 je	 $L1935
  0001b	83 fd 04	 cmp	 ebp, 4
  0001e	0f 8f 60 02 00
	00		 jg	 $L1935
  00024	85 ed		 test	 ebp, ebp
  00026	0f 8c 58 02 00
	00		 jl	 $L1935

; 445  :         return Z_STREAM_ERROR;
; 446  :     }
; 447  :     s = strm->state;
; 448  : 
; 449  :     if (strm->next_out == Z_NULL ||
; 450  :         (strm->next_in == Z_NULL && strm->avail_in != 0) ||
; 451  : 	(s->status == FINISH_STATE && flush != Z_FINISH)) {

  0002c	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 45 02 00
	00		 je	 $L1937
  00037	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0003a	75 0b		 jne	 SHORT $L1938
  0003c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0003f	85 c0		 test	 eax, eax
  00041	0f 85 35 02 00
	00		 jne	 $L1937
$L1938:
  00047	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004a	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  0004f	75 09		 jne	 SHORT $L1936
  00051	83 fd 04	 cmp	 ebp, 4
  00054	0f 85 22 02 00
	00		 jne	 $L1937
$L1936:

; 453  :     }
; 454  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  0005a	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  0005d	85 c9		 test	 ecx, ecx
  0005f	75 12		 jne	 SHORT $L1940
  00061	a1 1c 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+28
  00066	5e		 pop	 esi
  00067	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  0006a	5d		 pop	 ebp
  0006b	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00070	5b		 pop	 ebx

; 567  : }

  00071	59		 pop	 ecx
  00072	c3		 ret	 0
$L1940:

; 455  : 
; 456  :     s->strm = strm; /* just in case */
; 457  :     old_flush = s->last_flush;
; 458  :     s->last_flush = flush;
; 459  : 
; 460  :     /* Write the zlib header */
; 461  :     if (s->status == INIT_STATE) {

  00073	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00076	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00079	57		 push	 edi
  0007a	89 1e		 mov	 DWORD PTR [esi], ebx
  0007c	89 4c 24 10	 mov	 DWORD PTR _old_flush$[esp+20], ecx
  00080	89 6e 20	 mov	 DWORD PTR [esi+32], ebp
  00083	75 72		 jne	 SHORT $L2242

; 462  : 
; 463  :         uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  00085	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]

; 464  :         uInt level_flags = (s->level-1) >> 1;

  00088	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  0008b	83 e9 08	 sub	 ecx, 8
  0008e	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00091	81 c1 00 08 00
	00		 add	 ecx, 2048		; 00000800H
  00097	48		 dec	 eax
  00098	d1 f8		 sar	 eax, 1

; 465  : 
; 466  :         if (level_flags > 3) level_flags = 3;

  0009a	83 f8 03	 cmp	 eax, 3
  0009d	76 05		 jbe	 SHORT $L1945
  0009f	b8 03 00 00 00	 mov	 eax, 3
$L1945:

; 467  :         header |= (level_flags << 6);

  000a4	c1 e0 06	 shl	 eax, 6
  000a7	0b c8		 or	 ecx, eax

; 468  : 	if (s->strstart != 0) header |= PRESET_DICT;

  000a9	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  000ac	85 c0		 test	 eax, eax
  000ae	74 03		 je	 SHORT $L1946
  000b0	83 c9 20	 or	 ecx, 32			; 00000020H
$L1946:

; 469  :         header += 31 - (header % 31);

  000b3	8b c1		 mov	 eax, ecx
  000b5	33 d2		 xor	 edx, edx
  000b7	bf 1f 00 00 00	 mov	 edi, 31			; 0000001fH
  000bc	f7 f7		 div	 edi

; 470  : 
; 471  :         s->status = BUSY_STATE;
; 472  :         putShortMSB(s, header);

  000be	8b c6		 mov	 eax, esi
  000c0	c7 46 04 71 00
	00 00		 mov	 DWORD PTR [esi+4], 113	; 00000071H
  000c7	2b ca		 sub	 ecx, edx
  000c9	03 cf		 add	 ecx, edi
  000cb	e8 00 00 00 00	 call	 @putShortMSB@8

; 473  : 
; 474  : 	/* Save the adler32 of the preset dictionary: */
; 475  : 	if (s->strstart != 0) {

  000d0	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  000d3	85 c0		 test	 eax, eax
  000d5	74 19		 je	 SHORT $L2241

; 476  : 	    putShortMSB(s, (uInt)(strm->adler >> 16));

  000d7	0f b7 4b 32	 movzx	 ecx, WORD PTR [ebx+50]
  000db	8b c6		 mov	 eax, esi
  000dd	e8 00 00 00 00	 call	 @putShortMSB@8

; 477  : 	    putShortMSB(s, (uInt)(strm->adler & 0xffff));

  000e2	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  000e5	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000eb	e8 00 00 00 00	 call	 @putShortMSB@8
$L2241:

; 478  : 	}
; 479  : 	strm->adler = 1L;

  000f0	c7 43 30 01 00
	00 00		 mov	 DWORD PTR [ebx+48], 1
$L2242:

; 480  :     }
; 481  : 
; 482  :     /* Flush as much pending output as possible */
; 483  :     if (s->pending != 0) {

  000f7	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000fa	85 c0		 test	 eax, eax
  000fc	74 1d		 je	 SHORT $L1950

; 484  :         flush_pending(strm);

  000fe	8b c3		 mov	 eax, ebx
  00100	e8 00 00 00 00	 call	 @flush_pending@4

; 485  :         if (strm->avail_out == 0) {

  00105	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00108	85 c0		 test	 eax, eax
  0010a	75 35		 jne	 SHORT $L2244
$L2250:

; 523  : 	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */

  0010c	c7 46 20 ff ff
	ff ff		 mov	 DWORD PTR [esi+32], -1
$L2251:
  00113	5f		 pop	 edi
  00114	5e		 pop	 esi
  00115	5d		 pop	 ebp

; 524  : 	    }
; 525  : 	    return Z_OK;

  00116	33 c0		 xor	 eax, eax
  00118	5b		 pop	 ebx

; 567  : }

  00119	59		 pop	 ecx
  0011a	c3		 ret	 0
$L1950:

; 486  : 	    /* Since avail_out is 0, deflate will be called again with
; 487  : 	     * more output space, but possibly with both pending and
; 488  : 	     * avail_in equal to zero. There won't be anything to do,
; 489  : 	     * but this is not an error situation so make sure we
; 490  : 	     * return OK instead of BUF_ERROR at next call of deflate:
; 491  :              */
; 492  : 	    s->last_flush = -1;
; 493  : 	    return Z_OK;
; 494  : 	}
; 495  : 
; 496  :     /* Make sure there is something to do and avoid duplicate consecutive
; 497  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 498  :      * returning Z_STREAM_END instead of Z_BUFF_ERROR.
; 499  :      */
; 500  :     } else if (strm->avail_in == 0 && flush <= old_flush &&
; 501  : 	       flush != Z_FINISH) {

  0011b	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0011e	85 c0		 test	 eax, eax
  00120	75 1f		 jne	 SHORT $L2244
  00122	3b 6c 24 10	 cmp	 ebp, DWORD PTR _old_flush$[esp+20]
  00126	7f 19		 jg	 SHORT $L2244
  00128	83 fd 04	 cmp	 ebp, 4
  0012b	74 14		 je	 SHORT $L2244

; 502  :         ERR_RETURN(strm, Z_BUF_ERROR);

  0012d	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR _z_errmsg+28
  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	5d		 pop	 ebp
  00136	89 53 18	 mov	 DWORD PTR [ebx+24], edx
  00139	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0013e	5b		 pop	 ebx

; 567  : }

  0013f	59		 pop	 ecx
  00140	c3		 ret	 0
$L2244:

; 503  :     }
; 504  : 
; 505  :     /* User must not provide more input after the first FINISH: */
; 506  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  00141	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00144	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  00149	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0014c	75 17		 jne	 SHORT $L1955
  0014e	85 c9		 test	 ecx, ecx
  00150	74 17		 je	 SHORT $L2249

; 507  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00152	a1 1c 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+28
  00157	5f		 pop	 edi
  00158	5e		 pop	 esi
  00159	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  0015c	5d		 pop	 ebp
  0015d	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00162	5b		 pop	 ebx

; 567  : }

  00163	59		 pop	 ecx
  00164	c3		 ret	 0
$L1955:

; 508  :     }
; 509  : 
; 510  :     /* Start a new block or continue the current one.
; 511  :      */
; 512  :     if (strm->avail_in != 0 || s->lookahead != 0 ||
; 513  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {

  00165	85 c9		 test	 ecx, ecx
  00167	75 1a		 jne	 SHORT $L1958
$L2249:
  00169	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0016c	85 c9		 test	 ecx, ecx
  0016e	75 13		 jne	 SHORT $L1958
  00170	85 ed		 test	 ebp, ebp
  00172	0f 84 98 00 00
	00		 je	 $L2245
  00178	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  0017d	0f 84 8d 00 00
	00		 je	 $L2245
$L1958:

; 514  :         block_state bstate;
; 515  : 
; 516  : 	bstate = (*(configuration_table[s->level].func))(s, flush);

  00183	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00186	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00189	8b d5		 mov	 edx, ebp
  0018b	8b ce		 mov	 ecx, esi
  0018d	ff 14 85 08 00
	00 00		 call	 DWORD PTR _configuration_table[eax*4+8]

; 517  : 
; 518  :         if (bstate == finish_started || bstate == finish_done) {

  00194	83 f8 02	 cmp	 eax, 2
  00197	74 05		 je	 SHORT $L2243
  00199	83 f8 03	 cmp	 eax, 3
  0019c	75 07		 jne	 SHORT $L1960
$L2243:

; 519  :             s->status = FINISH_STATE;

  0019e	c7 46 04 9a 02
	00 00		 mov	 DWORD PTR [esi+4], 666	; 0000029aH
$L1960:

; 520  :         }
; 521  :         if (bstate == need_more || bstate == finish_started) {

  001a5	85 c0		 test	 eax, eax
  001a7	0f 84 b5 00 00
	00		 je	 $L1963
  001ad	83 f8 02	 cmp	 eax, 2
  001b0	0f 84 ac 00 00
	00		 je	 $L1963

; 526  : 	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 527  : 	     * of deflate should use the same flush parameter to make sure
; 528  : 	     * that the flush is complete. So we don't have to output an
; 529  : 	     * empty block here, this will be done at next call. This also
; 530  : 	     * ensures that for a very small output buffer, we emit at most
; 531  : 	     * one empty block.
; 532  : 	     */
; 533  : 	}
; 534  :         if (bstate == block_done) {

  001b6	83 f8 01	 cmp	 eax, 1
  001b9	75 55		 jne	 SHORT $L2245

; 535  :             if (flush == Z_PARTIAL_FLUSH) {

  001bb	3b e8		 cmp	 ebp, eax

; 536  :                 _tr_align(s);

  001bd	8b ce		 mov	 ecx, esi
  001bf	75 07		 jne	 SHORT $L1966
  001c1	e8 00 00 00 00	 call	 @_tr_align@4

; 537  :             } else { /* FULL_FLUSH or SYNC_FLUSH */

  001c6	eb 36		 jmp	 SHORT $L1969
$L1966:

; 538  :                 _tr_stored_block(s, (char*)0, 0L, 0);

  001c8	6a 00		 push	 0
  001ca	6a 00		 push	 0
  001cc	33 d2		 xor	 edx, edx
  001ce	e8 00 00 00 00	 call	 @_tr_stored_block@16

; 539  :                 /* For a full flush, this empty block will be recognized
; 540  :                  * as a special marker by inflate_sync().
; 541  :                  */
; 542  :                 if (flush == Z_FULL_FLUSH) {

  001d3	83 fd 03	 cmp	 ebp, 3
  001d6	75 26		 jne	 SHORT $L1969

; 543  :                     CLEAR_HASH(s);             /* forget history */

  001d8	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  001db	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  001de	66 c7 44 4a fe
	00 00		 mov	 WORD PTR [edx+ecx*2-2], 0
  001e5	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  001e8	8b 7e 3c	 mov	 edi, DWORD PTR [esi+60]
  001eb	8d 4c 09 fe	 lea	 ecx, DWORD PTR [ecx+ecx-2]
  001ef	8b d1		 mov	 edx, ecx
  001f1	c1 e9 02	 shr	 ecx, 2
  001f4	33 c0		 xor	 eax, eax
  001f6	f3 ab		 rep stosd
  001f8	8b ca		 mov	 ecx, edx
  001fa	23 cd		 and	 ecx, ebp
  001fc	f3 aa		 rep stosb
$L1969:

; 544  :                 }
; 545  :             }
; 546  :             flush_pending(strm);

  001fe	8b c3		 mov	 eax, ebx
  00200	e8 00 00 00 00	 call	 @flush_pending@4

; 547  : 	    if (strm->avail_out == 0) {

  00205	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00208	85 c0		 test	 eax, eax

; 548  : 	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
; 549  : 	      return Z_OK;

  0020a	0f 84 fc fe ff
	ff		 je	 $L2250
$L2245:

; 550  : 	    }
; 551  :         }
; 552  :     }
; 553  :     Assert(strm->avail_out > 0, "bug2");
; 554  : 
; 555  :     if (flush != Z_FINISH) return Z_OK;

  00210	83 fd 04	 cmp	 ebp, 4
  00213	0f 85 fa fe ff
	ff		 jne	 $L2251

; 556  :     if (s->noheader) return Z_STREAM_END;

  00219	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0021c	85 c0		 test	 eax, eax
  0021e	74 0b		 je	 SHORT $L1974
  00220	5f		 pop	 edi
  00221	5e		 pop	 esi
  00222	5d		 pop	 ebp
  00223	b8 01 00 00 00	 mov	 eax, 1
  00228	5b		 pop	 ebx

; 567  : }

  00229	59		 pop	 ecx
  0022a	c3		 ret	 0
$L1974:

; 557  : 
; 558  :     /* Write the zlib trailer (adler32) */
; 559  :     putShortMSB(s, (uInt)(strm->adler >> 16));

  0022b	0f b7 4b 32	 movzx	 ecx, WORD PTR [ebx+50]
  0022f	8b c6		 mov	 eax, esi
  00231	e8 00 00 00 00	 call	 @putShortMSB@8

; 560  :     putShortMSB(s, (uInt)(strm->adler & 0xffff));

  00236	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  00239	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0023f	e8 00 00 00 00	 call	 @putShortMSB@8

; 561  :     flush_pending(strm);

  00244	8b c3		 mov	 eax, ebx
  00246	e8 00 00 00 00	 call	 @flush_pending@4

; 562  :     /* If avail_out is zero, the application will call deflate again
; 563  :      * to flush the rest.
; 564  :      */
; 565  :     s->noheader = -1; /* write the trailer only once! */
; 566  :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  0024b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0024e	5f		 pop	 edi
  0024f	c7 46 18 ff ff
	ff ff		 mov	 DWORD PTR [esi+24], -1
  00256	5e		 pop	 esi
  00257	33 c0		 xor	 eax, eax
  00259	85 c9		 test	 ecx, ecx
  0025b	5d		 pop	 ebp
  0025c	0f 94 c0	 sete	 al
  0025f	5b		 pop	 ebx

; 567  : }

  00260	59		 pop	 ecx
  00261	c3		 ret	 0
$L1963:

; 522  : 	    if (strm->avail_out == 0) {

  00262	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00265	85 c0		 test	 eax, eax
  00267	0f 85 a6 fe ff
	ff		 jne	 $L2251
  0026d	5f		 pop	 edi

; 523  : 	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */

  0026e	c7 46 20 ff ff
	ff ff		 mov	 DWORD PTR [esi+32], -1
  00275	5e		 pop	 esi
  00276	5d		 pop	 ebp

; 524  : 	    }
; 525  : 	    return Z_OK;

  00277	33 c0		 xor	 eax, eax
  00279	5b		 pop	 ebx

; 567  : }

  0027a	59		 pop	 ecx
  0027b	c3		 ret	 0
$L1937:

; 452  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  0027c	a1 10 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+16
  00281	89 43 18	 mov	 DWORD PTR [ebx+24], eax
$L1935:
  00284	5e		 pop	 esi
  00285	5d		 pop	 ebp
  00286	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0028b	5b		 pop	 ebx

; 567  : }

  0028c	59		 pop	 ecx
  0028d	c3		 ret	 0
@deflate@8 ENDP
_TEXT	ENDS
PUBLIC	@deflateEnd@4
; Function compile flags: /Ogty
;	COMDAT @deflateEnd@4
_TEXT	SEGMENT
@deflateEnd@4 PROC NEAR					; COMDAT
; _strm$ = ecx

; 572  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 573  :     int status;
; 574  : 
; 575  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	85 f6		 test	 esi, esi
  00005	0f 84 83 00 00
	00		 je	 $L1982
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	74 7c		 je	 SHORT $L1982
  00012	57		 push	 edi

; 576  : 
; 577  :     status = strm->state->status;

  00013	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 578  :     if (status != INIT_STATE && status != BUSY_STATE &&
; 579  : 	status != FINISH_STATE) {

  00016	83 ff 2a	 cmp	 edi, 42			; 0000002aH
  00019	74 15		 je	 SHORT $L1983
  0001b	83 ff 71	 cmp	 edi, 113		; 00000071H
  0001e	74 10		 je	 SHORT $L1983
  00020	81 ff 9a 02 00
	00		 cmp	 edi, 666		; 0000029aH
  00026	74 08		 je	 SHORT $L1983
  00028	5f		 pop	 edi

; 580  :       return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002e	5e		 pop	 esi

; 593  : }

  0002f	c3		 ret	 0
$L1983:

; 581  :     }
; 582  : 
; 583  :     /* Deallocate in reverse order of allocations: */
; 584  :     TRY_FREE(strm, strm->state->pending_buf);

  00030	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00033	85 c0		 test	 eax, eax
  00035	74 08		 je	 SHORT $L1984
  00037	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0003a	8b d0		 mov	 edx, eax
  0003c	ff 56 24	 call	 DWORD PTR [esi+36]
$L1984:

; 585  :     TRY_FREE(strm, strm->state->head);

  0003f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00042	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  00045	85 d2		 test	 edx, edx
  00047	74 06		 je	 SHORT $L1986
  00049	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0004c	ff 56 24	 call	 DWORD PTR [esi+36]
$L1986:

; 586  :     TRY_FREE(strm, strm->state->prev);

  0004f	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00052	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00055	85 d2		 test	 edx, edx
  00057	74 06		 je	 SHORT $L1988
  00059	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0005c	ff 56 24	 call	 DWORD PTR [esi+36]
$L1988:

; 587  :     TRY_FREE(strm, strm->state->window);

  0005f	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00062	8b 52 30	 mov	 edx, DWORD PTR [edx+48]
  00065	85 d2		 test	 edx, edx
  00067	74 06		 je	 SHORT $L1990
  00069	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0006c	ff 56 24	 call	 DWORD PTR [esi+36]
$L1990:

; 588  : 
; 589  :     ZFREE(strm, strm->state);

  0006f	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00072	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00075	ff 56 24	 call	 DWORD PTR [esi+36]

; 590  :     strm->state = Z_NULL;
; 591  : 
; 592  :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  00078	33 c0		 xor	 eax, eax
  0007a	83 ff 71	 cmp	 edi, 113		; 00000071H
  0007d	0f 95 c0	 setne	 al
  00080	5f		 pop	 edi
  00081	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00088	5e		 pop	 esi
  00089	48		 dec	 eax
  0008a	83 e0 fd	 and	 eax, -3			; fffffffdH

; 593  : }

  0008d	c3		 ret	 0
$L1982:

; 573  :     int status;
; 574  : 
; 575  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0008e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00093	5e		 pop	 esi

; 593  : }

  00094	c3		 ret	 0
@deflateEnd@4 ENDP
_TEXT	ENDS
PUBLIC	@deflateCopy@8
; Function compile flags: /Ogty
;	COMDAT @deflateCopy@8
_TEXT	SEGMENT
tv260 = -4						; size = 4
@deflateCopy@8 PROC NEAR				; COMDAT
; _dest$ = ecx
; _source$ = edx

; 603  : {

  00000	51		 push	 ecx

; 604  : #ifdef MAXSEG_64K
; 605  :     return Z_STREAM_ERROR;
; 606  : #else
; 607  :     deflate_state *ds;
; 608  :     deflate_state *ss;
; 609  :     ushf *overlay;
; 610  : 
; 611  : 
; 612  :     if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {

  00001	85 d2		 test	 edx, edx
  00003	55		 push	 ebp
  00004	8b e9		 mov	 ebp, ecx
  00006	0f 84 84 01 00
	00		 je	 $L2001
  0000c	85 ed		 test	 ebp, ebp
  0000e	0f 84 7c 01 00
	00		 je	 $L2001
  00014	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00017	85 c0		 test	 eax, eax
  00019	89 44 24 04	 mov	 DWORD PTR tv260[esp+8], eax
  0001d	0f 84 6d 01 00
	00		 je	 $L2001
  00023	53		 push	 ebx
  00024	56		 push	 esi
  00025	57		 push	 edi

; 614  :     }
; 615  : 
; 616  :     ss = source->state;
; 617  : 
; 618  :     *dest = *source;

  00026	8b f2		 mov	 esi, edx
  00028	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0002d	8b fd		 mov	 edi, ebp
  0002f	f3 a5		 rep movsd

; 619  : 
; 620  :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  00031	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  00034	68 b8 16 00 00	 push	 5816			; 000016b8H
  00039	ba 01 00 00 00	 mov	 edx, 1
  0003e	ff 55 20	 call	 DWORD PTR [ebp+32]
  00041	8b d8		 mov	 ebx, eax

; 621  :     if (ds == Z_NULL) return Z_MEM_ERROR;

  00043	85 db		 test	 ebx, ebx
  00045	0f 84 3a 01 00
	00		 je	 $L2260

; 622  :     dest->state = (struct internal_state FAR *) ds;
; 623  :     *ds = *ss;

  0004b	8b 74 24 10	 mov	 esi, DWORD PTR tv260[esp+20]
  0004f	89 5d 1c	 mov	 DWORD PTR [ebp+28], ebx
  00052	b9 ae 05 00 00	 mov	 ecx, 1454		; 000005aeH
  00057	8b fb		 mov	 edi, ebx
  00059	f3 a5		 rep movsd

; 624  :     ds->strm = dest;
; 625  : 
; 626  :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  0005b	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  0005e	89 2b		 mov	 DWORD PTR [ebx], ebp
  00060	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  00063	6a 02		 push	 2
  00065	ff 55 20	 call	 DWORD PTR [ebp+32]

; 627  :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  00068	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  0006b	89 43 30	 mov	 DWORD PTR [ebx+48], eax
  0006e	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  00071	6a 02		 push	 2
  00073	ff 55 20	 call	 DWORD PTR [ebp+32]

; 628  :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  00076	8b 53 44	 mov	 edx, DWORD PTR [ebx+68]
  00079	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  0007c	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  0007f	6a 02		 push	 2
  00081	ff 55 20	 call	 DWORD PTR [ebp+32]

; 629  :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  00084	8b 93 94 16 00
	00		 mov	 edx, DWORD PTR [ebx+5780]
  0008a	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  0008d	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  00090	6a 04		 push	 4
  00092	ff 55 20	 call	 DWORD PTR [ebp+32]

; 630  :     ds->pending_buf = (uchf *) overlay;
; 631  : 
; 632  :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
; 633  :         ds->pending_buf == Z_NULL) {

  00095	8b 7b 30	 mov	 edi, DWORD PTR [ebx+48]
  00098	85 ff		 test	 edi, edi
  0009a	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0009d	0f 84 db 00 00
	00		 je	 $L2016
  000a3	8b 4b 38	 mov	 ecx, DWORD PTR [ebx+56]
  000a6	85 c9		 test	 ecx, ecx
  000a8	0f 84 d0 00 00
	00		 je	 $L2016
  000ae	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  000b1	85 c9		 test	 ecx, ecx
  000b3	0f 84 c5 00 00
	00		 je	 $L2016
  000b9	85 c0		 test	 eax, eax
  000bb	0f 84 bd 00 00
	00		 je	 $L2016

; 636  :     }
; 637  :     /* following zmemcpy do not work for 16-bit MSDOS */
; 638  :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  000c1	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  000c4	8b 54 24 10	 mov	 edx, DWORD PTR tv260[esp+20]
  000c8	8b 72 30	 mov	 esi, DWORD PTR [edx+48]
  000cb	d1 e1		 shl	 ecx, 1
  000cd	8b e9		 mov	 ebp, ecx
  000cf	c1 e9 02	 shr	 ecx, 2
  000d2	f3 a5		 rep movsd
  000d4	8b cd		 mov	 ecx, ebp
  000d6	83 e1 03	 and	 ecx, 3
  000d9	f3 a4		 rep movsb

; 639  :     zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));

  000db	8b 72 38	 mov	 esi, DWORD PTR [edx+56]
  000de	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  000e1	8b 7b 38	 mov	 edi, DWORD PTR [ebx+56]
  000e4	d1 e1		 shl	 ecx, 1
  000e6	8b e9		 mov	 ebp, ecx
  000e8	c1 e9 02	 shr	 ecx, 2
  000eb	f3 a5		 rep movsd
  000ed	8b cd		 mov	 ecx, ebp
  000ef	83 e1 03	 and	 ecx, 3
  000f2	f3 a4		 rep movsb

; 640  :     zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));

  000f4	8b 72 3c	 mov	 esi, DWORD PTR [edx+60]
  000f7	8b 4b 44	 mov	 ecx, DWORD PTR [ebx+68]
  000fa	8b 7b 3c	 mov	 edi, DWORD PTR [ebx+60]
  000fd	d1 e1		 shl	 ecx, 1
  000ff	8b e9		 mov	 ebp, ecx
  00101	c1 e9 02	 shr	 ecx, 2
  00104	f3 a5		 rep movsd
  00106	8b cd		 mov	 ecx, ebp
  00108	83 e1 03	 and	 ecx, 3
  0010b	f3 a4		 rep movsb

; 641  :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  0010d	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00110	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00113	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  00116	8b e9		 mov	 ebp, ecx
  00118	c1 e9 02	 shr	 ecx, 2
  0011b	f3 a5		 rep movsd
  0011d	8b cd		 mov	 ecx, ebp
  0011f	83 e1 03	 and	 ecx, 3
  00122	f3 a4		 rep movsb

; 642  : 
; 643  :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  00124	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  00127	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0012a	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  0012d	2b cf		 sub	 ecx, edi
  0012f	03 ce		 add	 ecx, esi
  00131	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx

; 644  :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  00134	8b 8b 94 16 00
	00		 mov	 ecx, DWORD PTR [ebx+5780]
  0013a	8b d1		 mov	 edx, ecx
  0013c	d1 ea		 shr	 edx, 1
  0013e	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 645  :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  00141	8d 14 4e	 lea	 edx, DWORD PTR [esi+ecx*2]
  00144	03 d1		 add	 edx, ecx
  00146	89 83 9c 16 00
	00		 mov	 DWORD PTR [ebx+5788], eax
  0014c	5f		 pop	 edi
  0014d	89 93 90 16 00
	00		 mov	 DWORD PTR [ebx+5776], edx

; 646  : 
; 647  :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  00153	8d 83 8c 00 00
	00		 lea	 eax, DWORD PTR [ebx+140]

; 648  :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  00159	8d 8b 80 09 00
	00		 lea	 ecx, DWORD PTR [ebx+2432]

; 649  :     ds->bl_desc.dyn_tree = ds->bl_tree;

  0015f	8d 93 74 0a 00
	00		 lea	 edx, DWORD PTR [ebx+2676]
  00165	5e		 pop	 esi
  00166	89 83 10 0b 00
	00		 mov	 DWORD PTR [ebx+2832], eax
  0016c	89 8b 1c 0b 00
	00		 mov	 DWORD PTR [ebx+2844], ecx
  00172	89 93 28 0b 00
	00		 mov	 DWORD PTR [ebx+2856], edx
  00178	5b		 pop	 ebx

; 650  : 
; 651  :     return Z_OK;

  00179	33 c0		 xor	 eax, eax
  0017b	5d		 pop	 ebp

; 652  : #endif
; 653  : }

  0017c	59		 pop	 ecx
  0017d	c3		 ret	 0
$L2016:

; 634  :         deflateEnd (dest);

  0017e	8b cd		 mov	 ecx, ebp
  00180	e8 00 00 00 00	 call	 @deflateEnd@4
$L2260:
  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	5b		 pop	 ebx

; 635  :         return Z_MEM_ERROR;

  00188	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0018d	5d		 pop	 ebp

; 652  : #endif
; 653  : }

  0018e	59		 pop	 ecx
  0018f	c3		 ret	 0
$L2001:

; 613  :         return Z_STREAM_ERROR;

  00190	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00195	5d		 pop	 ebp

; 652  : #endif
; 653  : }

  00196	59		 pop	 ecx
  00197	c3		 ret	 0
@deflateCopy@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @read_buf@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_buf$ = 12						; size = 4
@read_buf@12 PROC NEAR					; COMDAT
; _size$ = ecx

; 666  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _strm$[esp+4]

; 667  :     unsigned len = strm->avail_in;

  00006	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00009	8b d8		 mov	 ebx, eax

; 668  : 
; 669  :     if (len > size) len = size;

  0000b	3b d9		 cmp	 ebx, ecx
  0000d	76 02		 jbe	 SHORT $L2029
  0000f	8b d9		 mov	 ebx, ecx
$L2029:

; 670  :     if (len == 0) return 0;

  00011	85 db		 test	 ebx, ebx
  00013	75 07		 jne	 SHORT $L2030
  00015	5d		 pop	 ebp
  00016	33 c0		 xor	 eax, eax
  00018	5b		 pop	 ebx

; 682  : }

  00019	c2 08 00	 ret	 8
$L2030:

; 671  : 
; 672  :     strm->avail_in  -= len;

  0001c	2b c3		 sub	 eax, ebx
  0001e	89 45 04	 mov	 DWORD PTR [ebp+4], eax

; 673  : 
; 674  :     if (!strm->state->noheader) {

  00021	8b 45 1c	 mov	 eax, DWORD PTR [ebp+28]
  00024	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00027	85 c9		 test	 ecx, ecx
  00029	75 0f		 jne	 SHORT $L2031

; 675  :         strm->adler = adler32(strm->adler, strm->next_in, len);

  0002b	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  0002e	8b 4d 30	 mov	 ecx, DWORD PTR [ebp+48]
  00031	53		 push	 ebx
  00032	e8 00 00 00 00	 call	 @adler32@12
  00037	89 45 30	 mov	 DWORD PTR [ebp+48], eax
$L2031:
  0003a	56		 push	 esi

; 676  :     }
; 677  :     zmemcpy(buf, strm->next_in, len);

  0003b	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  0003e	57		 push	 edi
  0003f	8b 7c 24 18	 mov	 edi, DWORD PTR _buf$[esp+12]
  00043	8b cb		 mov	 ecx, ebx
  00045	8b d1		 mov	 edx, ecx
  00047	c1 e9 02	 shr	 ecx, 2
  0004a	f3 a5		 rep movsd
  0004c	8b ca		 mov	 ecx, edx
  0004e	83 e1 03	 and	 ecx, 3
  00051	f3 a4		 rep movsb

; 678  :     strm->next_in  += len;

  00053	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]

; 679  :     strm->total_in += len;

  00056	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00059	5f		 pop	 edi
  0005a	03 c3		 add	 eax, ebx
  0005c	03 cb		 add	 ecx, ebx
  0005e	5e		 pop	 esi
  0005f	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  00062	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  00065	5d		 pop	 ebp

; 680  : 
; 681  :     return (int)len;

  00066	8b c3		 mov	 eax, ebx
  00068	5b		 pop	 ebx

; 682  : }

  00069	c2 08 00	 ret	 8
@read_buf@12 ENDP
_TEXT	ENDS
EXTRN	@match_init@0:NEAR
; Function compile flags: /Ogty
;	COMDAT @lm_init@4
_TEXT	SEGMENT
@lm_init@4 PROC NEAR					; COMDAT
; _s$ = edx

; 690  :     s->window_size = (ulg)2L*s->w_size;

  00000	8b 42 24	 mov	 eax, DWORD PTR [edx+36]

; 691  : 
; 692  :     CLEAR_HASH(s);

  00003	8b 4a 44	 mov	 ecx, DWORD PTR [edx+68]
  00006	d1 e0		 shl	 eax, 1
  00008	89 42 34	 mov	 DWORD PTR [edx+52], eax
  0000b	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	33 f6		 xor	 esi, esi
  00012	66 89 74 48 fe	 mov	 WORD PTR [eax+ecx*2-2], si
  00017	8b 4a 44	 mov	 ecx, DWORD PTR [edx+68]
  0001a	8d 4c 09 fe	 lea	 ecx, DWORD PTR [ecx+ecx-2]
  0001e	8b d9		 mov	 ebx, ecx
  00020	c1 e9 02	 shr	 ecx, 2
  00023	57		 push	 edi
  00024	8b 7a 3c	 mov	 edi, DWORD PTR [edx+60]
  00027	33 c0		 xor	 eax, eax
  00029	f3 ab		 rep stosd
  0002b	8b cb		 mov	 ecx, ebx
  0002d	83 e1 03	 and	 ecx, 3
  00030	f3 aa		 rep stosb

; 693  : 
; 694  :     /* Set the default configuration parameters:
; 695  :      */
; 696  :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  00032	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00035	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00038	c1 e0 02	 shl	 eax, 2
  0003b	0f b7 88 02 00
	00 00		 movzx	 ecx, WORD PTR _configuration_table[eax+2]
  00042	89 4a 78	 mov	 DWORD PTR [edx+120], ecx

; 697  :     s->good_match       = configuration_table[s->level].good_length;

  00045	0f b7 88 00 00
	00 00		 movzx	 ecx, WORD PTR _configuration_table[eax]
  0004c	89 8a 84 00 00
	00		 mov	 DWORD PTR [edx+132], ecx

; 698  :     s->nice_match       = configuration_table[s->level].nice_length;

  00052	0f b7 88 04 00
	00 00		 movzx	 ecx, WORD PTR _configuration_table[eax+4]
  00059	89 8a 88 00 00
	00		 mov	 DWORD PTR [edx+136], ecx

; 699  :     s->max_chain_length = configuration_table[s->level].max_chain;

  0005f	0f b7 80 06 00
	00 00		 movzx	 eax, WORD PTR _configuration_table[eax+6]
  00066	5f		 pop	 edi
  00067	89 42 74	 mov	 DWORD PTR [edx+116], eax

; 700  : 
; 701  :     s->strstart = 0;

  0006a	89 72 64	 mov	 DWORD PTR [edx+100], esi

; 702  :     s->block_start = 0L;

  0006d	89 72 54	 mov	 DWORD PTR [edx+84], esi

; 703  :     s->lookahead = 0;

  00070	89 72 6c	 mov	 DWORD PTR [edx+108], esi

; 704  :     s->match_length = s->prev_length = MIN_MATCH-1;

  00073	b8 02 00 00 00	 mov	 eax, 2

; 705  :     s->match_available = 0;

  00078	89 72 60	 mov	 DWORD PTR [edx+96], esi

; 706  :     s->ins_h = 0;

  0007b	89 72 40	 mov	 DWORD PTR [edx+64], esi
  0007e	5e		 pop	 esi
  0007f	89 42 70	 mov	 DWORD PTR [edx+112], eax
  00082	89 42 58	 mov	 DWORD PTR [edx+88], eax
  00085	5b		 pop	 ebx

; 707  : #ifdef ASMV
; 708  :     match_init(); /* initialize the asm code */

  00086	e9 00 00 00 00	 jmp	 @match_init@0
@lm_init@4 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @fill_window@4
_TEXT	SEGMENT
_len$2275 = -8						; size = 4
_wsize$ = -4						; size = 4
@fill_window@4 PROC NEAR				; COMDAT
; _s$ = ebx

; 963  : {

  00000	83 ec 08	 sub	 esp, 8

; 964  :     register unsigned n, m;
; 965  :     register Posf *p;
; 966  :     unsigned more;    /* Amount of free space at the end of the window. */
; 967  :     uInt wsize = s->w_size;

  00003	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	89 44 24 0c	 mov	 DWORD PTR _wsize$[esp+16], eax
  0000c	57		 push	 edi
  0000d	8d 49 00	 npad	 3
$L2048:

; 968  : 
; 969  :     do {
; 970  :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00010	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  00013	8b 53 34	 mov	 edx, DWORD PTR [ebx+52]
  00016	8b 73 6c	 mov	 esi, DWORD PTR [ebx+108]
  00019	2b d1		 sub	 edx, ecx
  0001b	2b d6		 sub	 edx, esi

; 971  : 
; 972  :         /* Deal with !@#$% 64K limit: */
; 973  :         if (more == 0 && s->strstart == 0 && s->lookahead == 0) {

  0001d	75 0f		 jne	 SHORT $L2054
  0001f	85 c9		 test	 ecx, ecx
  00021	75 1a		 jne	 SHORT $L2286
  00023	85 f6		 test	 esi, esi
  00025	75 16		 jne	 SHORT $L2286

; 974  :             more = wsize;

  00027	8b d0		 mov	 edx, eax

; 975  : 
; 976  :         } else if (more == (unsigned)(-1)) {

  00029	e9 8c 00 00 00	 jmp	 $L2287
$L2054:
  0002e	83 fa ff	 cmp	 edx, -1
  00031	75 0a		 jne	 SHORT $L2286

; 977  :             /* Very unlikely, but possible on 16 bit machine if strstart == 0
; 978  :              * and lookahead == 1 (input done one byte at time)
; 979  :              */
; 980  :             more--;

  00033	ba fe ff ff ff	 mov	 edx, -2			; fffffffeH

; 981  : 
; 982  :         /* If the window is almost full and there is insufficient lookahead,
; 983  :          * move the upper half to the lower one to make room in the upper half.
; 984  :          */
; 985  :         } else if (s->strstart >= wsize+MAX_DIST(s)) {

  00038	e9 7d 00 00 00	 jmp	 $L2287
$L2286:
  0003d	8b 73 24	 mov	 esi, DWORD PTR [ebx+36]
  00040	8d b4 30 fa fe
	ff ff		 lea	 esi, DWORD PTR [eax+esi-262]
  00047	3b ce		 cmp	 ecx, esi
  00049	72 6f		 jb	 SHORT $L2287

; 986  : 
; 987  :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);

  0004b	8b 7b 30	 mov	 edi, DWORD PTR [ebx+48]
  0004e	8b c8		 mov	 ecx, eax
  00050	8b e9		 mov	 ebp, ecx
  00052	c1 e9 02	 shr	 ecx, 2
  00055	8d 34 07	 lea	 esi, DWORD PTR [edi+eax]
  00058	f3 a5		 rep movsd
  0005a	8b cd		 mov	 ecx, ebp
  0005c	83 e1 03	 and	 ecx, 3
  0005f	f3 a4		 rep movsb

; 988  :             s->match_start -= wsize;

  00061	8b 7b 68	 mov	 edi, DWORD PTR [ebx+104]

; 989  :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */

  00064	8b 73 64	 mov	 esi, DWORD PTR [ebx+100]

; 990  :             s->block_start -= (long) wsize;

  00067	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  0006a	2b f8		 sub	 edi, eax
  0006c	2b f0		 sub	 esi, eax
  0006e	2b c8		 sub	 ecx, eax
  00070	89 7b 68	 mov	 DWORD PTR [ebx+104], edi

; 991  : 
; 992  :             /* Slide the hash table (could be avoided with 32 bit values
; 993  :                at the expense of memory usage). We slide even when level == 0
; 994  :                to keep the hash table consistent if we switch back to level > 0
; 995  :                later. (Using level 0 permanently is not an optimal usage of
; 996  :                zlib, so we don't care about this pathological case.)
; 997  :              */
; 998  : 	    n = s->hash_size;

  00073	8b 7b 44	 mov	 edi, DWORD PTR [ebx+68]
  00076	89 4b 54	 mov	 DWORD PTR [ebx+84], ecx

; 999  : 	    p = &s->head[n];

  00079	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  0007c	89 73 64	 mov	 DWORD PTR [ebx+100], esi
  0007f	8d 34 79	 lea	 esi, DWORD PTR [ecx+edi*2]
$L2062:

; 1000 : 	    do {
; 1001 : 		m = *--p;

  00082	0f b7 4e fe	 movzx	 ecx, WORD PTR [esi-2]
  00086	83 ee 02	 sub	 esi, 2

; 1002 : 		*p = (Pos)(m >= wsize ? m-wsize : NIL);

  00089	3b c8		 cmp	 ecx, eax
  0008b	72 04		 jb	 SHORT $L2268
  0008d	2b c8		 sub	 ecx, eax
  0008f	eb 02		 jmp	 SHORT $L2269
$L2268:
  00091	33 c9		 xor	 ecx, ecx
$L2269:

; 1003 : 	    } while (--n);

  00093	4f		 dec	 edi
  00094	66 89 0e	 mov	 WORD PTR [esi], cx
  00097	75 e9		 jne	 SHORT $L2062

; 1004 : 
; 1005 : 	    n = wsize;
; 1006 : #ifndef FASTEST
; 1007 : 	    p = &s->prev[n];

  00099	8b 4b 38	 mov	 ecx, DWORD PTR [ebx+56]
  0009c	8b f8		 mov	 edi, eax
  0009e	8d 34 41	 lea	 esi, DWORD PTR [ecx+eax*2]
$L2066:

; 1008 : 	    do {
; 1009 : 		m = *--p;

  000a1	0f b7 4e fe	 movzx	 ecx, WORD PTR [esi-2]
  000a5	83 ee 02	 sub	 esi, 2

; 1010 : 		*p = (Pos)(m >= wsize ? m-wsize : NIL);

  000a8	3b c8		 cmp	 ecx, eax
  000aa	72 04		 jb	 SHORT $L2270
  000ac	2b c8		 sub	 ecx, eax
  000ae	eb 02		 jmp	 SHORT $L2271
$L2270:
  000b0	33 c9		 xor	 ecx, ecx
$L2271:

; 1011 : 		/* If n is not on any hash chain, prev[n] is garbage but
; 1012 : 		 * its value will never be used.
; 1013 : 		 */
; 1014 : 	    } while (--n);

  000b2	4f		 dec	 edi
  000b3	66 89 0e	 mov	 WORD PTR [esi], cx
  000b6	75 e9		 jne	 SHORT $L2066

; 1015 : #endif
; 1016 :             more += wsize;

  000b8	03 d0		 add	 edx, eax
$L2287:

; 1017 :         }
; 1018 :         if (s->strm->avail_in == 0) return;

  000ba	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  000bc	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  000bf	85 c9		 test	 ecx, ecx
  000c1	0f 84 b5 00 00
	00		 je	 $L2050

; 1019 : 
; 1020 :         /* If there was no sliding:
; 1021 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1022 :          *    more == window_size - lookahead - strstart
; 1023 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1024 :          * => more >= window_size - 2*WSIZE + 2
; 1025 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1026 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1027 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1028 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1029 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1030 :          */
; 1031 :         Assert(more >= 2, "more < 2");
; 1032 : 
; 1033 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  000c7	8b 73 64	 mov	 esi, DWORD PTR [ebx+100]
  000ca	8b 7b 6c	 mov	 edi, DWORD PTR [ebx+108]
  000cd	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  000d0	03 fe		 add	 edi, esi
  000d2	03 f9		 add	 edi, ecx
  000d4	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  000d7	8b f1		 mov	 esi, ecx
  000d9	3b f2		 cmp	 esi, edx
  000db	89 74 24 0c	 mov	 DWORD PTR _len$2275[esp+20], esi
  000df	76 06		 jbe	 SHORT $L2276
  000e1	89 54 24 0c	 mov	 DWORD PTR _len$2275[esp+20], edx
  000e5	8b f2		 mov	 esi, edx
$L2276:
  000e7	85 f6		 test	 esi, esi
  000e9	75 04		 jne	 SHORT $L2277
  000eb	33 c9		 xor	 ecx, ecx
  000ed	eb 49		 jmp	 SHORT $L2274
$L2277:
  000ef	8b 55 1c	 mov	 edx, DWORD PTR [ebp+28]
  000f2	2b ce		 sub	 ecx, esi
  000f4	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  000f7	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  000fa	85 c9		 test	 ecx, ecx
  000fc	75 13		 jne	 SHORT $L2278
  000fe	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00101	8b 4d 30	 mov	 ecx, DWORD PTR [ebp+48]
  00104	56		 push	 esi
  00105	e8 00 00 00 00	 call	 @adler32@12
  0010a	89 45 30	 mov	 DWORD PTR [ebp+48], eax
  0010d	8b 44 24 10	 mov	 eax, DWORD PTR _wsize$[esp+20]
$L2278:
  00111	8b ce		 mov	 ecx, esi
  00113	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  00116	8b d1		 mov	 edx, ecx
  00118	c1 e9 02	 shr	 ecx, 2
  0011b	f3 a5		 rep movsd
  0011d	8b ca		 mov	 ecx, edx
  0011f	83 e1 03	 and	 ecx, 3
  00122	f3 a4		 rep movsb
  00124	8b 4c 24 0c	 mov	 ecx, DWORD PTR _len$2275[esp+20]
  00128	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  0012b	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  0012e	03 f1		 add	 esi, ecx
  00130	03 d1		 add	 edx, ecx
  00132	89 75 00	 mov	 DWORD PTR [ebp], esi
  00135	89 55 08	 mov	 DWORD PTR [ebp+8], edx
$L2274:

; 1034 :         s->lookahead += n;

  00138	8b 53 6c	 mov	 edx, DWORD PTR [ebx+108]
  0013b	03 d1		 add	 edx, ecx
  0013d	8b fa		 mov	 edi, edx

; 1035 : 
; 1036 :         /* Initialize the hash value now that we have some input: */
; 1037 :         if (s->lookahead >= MIN_MATCH) {

  0013f	83 ff 03	 cmp	 edi, 3
  00142	89 53 6c	 mov	 DWORD PTR [ebx+108], edx
  00145	72 20		 jb	 SHORT $L2049

; 1038 :             s->ins_h = s->window[s->strstart];

  00147	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  0014a	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  0014d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00150	0f b6 16	 movzx	 edx, BYTE PTR [esi]

; 1039 :             UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  00153	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  00156	89 53 40	 mov	 DWORD PTR [ebx+64], edx
  00159	d3 e2		 shl	 edx, cl
  0015b	0f b6 4e 01	 movzx	 ecx, BYTE PTR [esi+1]
  0015f	33 d1		 xor	 edx, ecx
  00161	23 53 4c	 and	 edx, DWORD PTR [ebx+76]
  00164	89 53 40	 mov	 DWORD PTR [ebx+64], edx
$L2049:

; 1040 : #if MIN_MATCH != 3
; 1041 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1042 : #endif
; 1043 :         }
; 1044 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1045 :          * but this is not important since only literal bytes will be emitted.
; 1046 :          */
; 1047 : 
; 1048 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  00167	81 ff 06 01 00
	00		 cmp	 edi, 262		; 00000106H
  0016d	73 0d		 jae	 SHORT $L2050
  0016f	8b 13		 mov	 edx, DWORD PTR [ebx]
  00171	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00174	85 c9		 test	 ecx, ecx
  00176	0f 85 94 fe ff
	ff		 jne	 $L2048
$L2050:
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5d		 pop	 ebp

; 1049 : }

  0017f	83 c4 08	 add	 esp, 8
  00182	c3		 ret	 0
@fill_window@4 ENDP
_TEXT	ENDS
EXTRN	@_tr_flush_block@16:NEAR
; Function compile flags: /Ogty
;	COMDAT @deflate_stored@8
_TEXT	SEGMENT
_max_block_size$ = -8					; size = 4
_flush$ = -4						; size = 4
@deflate_stored@8 PROC NEAR				; COMDAT
; _s$ = ecx
; _flush$ = edx

; 1084 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx

; 1085 :     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
; 1086 :      * to pending_buf_size, and each stored block has a 5 byte header:
; 1087 :      */
; 1088 :     ulg max_block_size = 0xffff;
; 1089 :     ulg max_start;
; 1090 : 
; 1091 :     if (max_block_size > s->pending_buf_size - 5) {

  00006	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00009	55		 push	 ebp
  0000a	83 c0 fb	 add	 eax, -5			; fffffffbH
  0000d	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	89 54 24 14	 mov	 DWORD PTR _flush$[esp+24], edx
  00018	c7 44 24 10 ff
	ff 00 00	 mov	 DWORD PTR _max_block_size$[esp+24], 65535 ; 0000ffffH
  00020	73 04		 jae	 SHORT $L2083

; 1092 :         max_block_size = s->pending_buf_size - 5;

  00022	89 44 24 10	 mov	 DWORD PTR _max_block_size$[esp+24], eax
$L2083:

; 1093 :     }
; 1094 : 
; 1095 :     /* Copy as much as possible from input to output: */
; 1096 :     for (;;) {
; 1097 :         /* Fill the window as much as possible: */
; 1098 :         if (s->lookahead <= 1) {

  00026	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]
  00029	83 f8 01	 cmp	 eax, 1
  0002c	77 10		 ja	 SHORT $L2087

; 1099 : 
; 1100 :             Assert(s->strstart < s->w_size+MAX_DIST(s) ||
; 1101 : 		   s->block_start >= (long)s->w_size, "slide too late");
; 1102 : 
; 1103 :             fill_window(s);

  0002e	e8 00 00 00 00	 call	 @fill_window@4

; 1104 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  00033	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]
  00036	85 c0		 test	 eax, eax
  00038	0f 84 65 01 00
	00		 je	 $L2318
$L2087:

; 1105 : 
; 1106 :             if (s->lookahead == 0) break; /* flush the current block */
; 1107 :         }
; 1108 : 	Assert(s->block_start >= 0L, "block gone");
; 1109 : 
; 1110 : 	s->strstart += s->lookahead;

  0003e	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  00041	03 c8		 add	 ecx, eax

; 1111 : 	s->lookahead = 0;
; 1112 : 
; 1113 : 	/* Emit a stored block if pending_buf will be full: */
; 1114 :  	max_start = s->block_start + max_block_size;

  00043	8b 44 24 10	 mov	 eax, DWORD PTR _max_block_size$[esp+24]
  00047	89 4b 64	 mov	 DWORD PTR [ebx+100], ecx
  0004a	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]

; 1115 :         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {

  0004d	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  00050	c7 43 6c 00 00
	00 00		 mov	 DWORD PTR [ebx+108], 0
  00057	8d 04 01	 lea	 eax, DWORD PTR [ecx+eax]
  0005a	74 08		 je	 SHORT $L2090
  0005c	3b d0		 cmp	 edx, eax
  0005e	0f 82 93 00 00
	00		 jb	 $L2098
$L2090:

; 1116 : 	    /* strstart == 0 is possible when wraparound on 16-bit machine */
; 1117 : 	    s->lookahead = (uInt)(s->strstart - max_start);

  00064	2b d0		 sub	 edx, eax

; 1118 : 	    s->strstart = (uInt)max_start;
; 1119 :             FLUSH_BLOCK(s, 0);

  00066	85 c9		 test	 ecx, ecx
  00068	89 53 6c	 mov	 DWORD PTR [ebx+108], edx
  0006b	89 43 64	 mov	 DWORD PTR [ebx+100], eax
  0006e	7c 07		 jl	 SHORT $L2290
  00070	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  00073	03 d1		 add	 edx, ecx
  00075	eb 02		 jmp	 SHORT $L2291
$L2290:
  00077	33 d2		 xor	 edx, edx
$L2291:
  00079	2b c1		 sub	 eax, ecx
  0007b	6a 00		 push	 0
  0007d	50		 push	 eax
  0007e	8b cb		 mov	 ecx, ebx
  00080	e8 00 00 00 00	 call	 @_tr_flush_block@16
  00085	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  00088	8b 03		 mov	 eax, DWORD PTR [ebx]
  0008a	89 4b 54	 mov	 DWORD PTR [ebx+84], ecx
  0008d	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00090	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00093	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00096	3b d1		 cmp	 edx, ecx
  00098	76 02		 jbe	 SHORT $L2300
  0009a	8b d1		 mov	 edx, ecx
$L2300:
  0009c	85 d2		 test	 edx, edx
  0009e	74 4a		 je	 SHORT $L2319
  000a0	8b 76 10	 mov	 esi, DWORD PTR [esi+16]
  000a3	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  000a6	8b ca		 mov	 ecx, edx
  000a8	8b e9		 mov	 ebp, ecx
  000aa	c1 e9 02	 shr	 ecx, 2
  000ad	f3 a5		 rep movsd
  000af	8b cd		 mov	 ecx, ebp
  000b1	83 e1 03	 and	 ecx, 3
  000b4	f3 a4		 rep movsb
  000b6	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  000b9	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000bc	03 fa		 add	 edi, edx
  000be	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  000c1	01 51 10	 add	 DWORD PTR [ecx+16], edx
  000c4	8b 68 14	 mov	 ebp, DWORD PTR [eax+20]
  000c7	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  000ca	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000cd	03 ea		 add	 ebp, edx
  000cf	89 68 14	 mov	 DWORD PTR [eax+20], ebp
  000d2	2b fa		 sub	 edi, edx
  000d4	89 78 10	 mov	 DWORD PTR [eax+16], edi
  000d7	29 51 14	 sub	 DWORD PTR [ecx+20], edx
  000da	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000dd	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000e0	85 c9		 test	 ecx, ecx
  000e2	75 06		 jne	 SHORT $L2319
  000e4	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000e7	89 50 10	 mov	 DWORD PTR [eax+16], edx
$L2319:
  000ea	8b 03		 mov	 eax, DWORD PTR [ebx]
  000ec	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ef	85 c9		 test	 ecx, ecx
  000f1	0f 84 a2 00 00
	00		 je	 $L2317
$L2098:

; 1120 : 	}
; 1121 : 	/* Flush if we may have to slide, otherwise block_start may become
; 1122 :          * negative and the data will be gone:
; 1123 :          */
; 1124 :         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {

  000f7	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  000fa	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]
  000fd	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  00100	2b c1		 sub	 eax, ecx
  00102	81 ea 06 01 00
	00		 sub	 edx, 262		; 00000106H
  00108	3b c2		 cmp	 eax, edx
  0010a	0f 82 16 ff ff
	ff		 jb	 $L2083

; 1125 :             FLUSH_BLOCK(s, 0);

  00110	85 c9		 test	 ecx, ecx
  00112	7c 07		 jl	 SHORT $L2292
  00114	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  00117	03 d1		 add	 edx, ecx
  00119	eb 02		 jmp	 SHORT $L2293
$L2292:
  0011b	33 d2		 xor	 edx, edx
$L2293:
  0011d	6a 00		 push	 0
  0011f	50		 push	 eax
  00120	8b cb		 mov	 ecx, ebx
  00122	e8 00 00 00 00	 call	 @_tr_flush_block@16
  00127	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]
  0012a	89 43 54	 mov	 DWORD PTR [ebx+84], eax
  0012d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0012f	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00132	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00135	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00138	3b d1		 cmp	 edx, ecx
  0013a	76 02		 jbe	 SHORT $L2308
  0013c	8b d1		 mov	 edx, ecx
$L2308:
  0013e	85 d2		 test	 edx, edx
  00140	74 4a		 je	 SHORT $L2320
  00142	8b 76 10	 mov	 esi, DWORD PTR [esi+16]
  00145	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  00148	8b ca		 mov	 ecx, edx
  0014a	8b e9		 mov	 ebp, ecx
  0014c	c1 e9 02	 shr	 ecx, 2
  0014f	f3 a5		 rep movsd
  00151	8b cd		 mov	 ecx, ebp
  00153	83 e1 03	 and	 ecx, 3
  00156	f3 a4		 rep movsb
  00158	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  0015b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0015e	03 fa		 add	 edi, edx
  00160	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00163	01 51 10	 add	 DWORD PTR [ecx+16], edx
  00166	8b 68 14	 mov	 ebp, DWORD PTR [eax+20]
  00169	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  0016c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0016f	03 ea		 add	 ebp, edx
  00171	89 68 14	 mov	 DWORD PTR [eax+20], ebp
  00174	2b fa		 sub	 edi, edx
  00176	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00179	29 51 14	 sub	 DWORD PTR [ecx+20], edx
  0017c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0017f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00182	85 c9		 test	 ecx, ecx
  00184	75 06		 jne	 SHORT $L2320
  00186	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00189	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$L2320:
  0018c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0018e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00191	85 c0		 test	 eax, eax
  00193	0f 85 8d fe ff
	ff		 jne	 $L2083
$L2317:
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5d		 pop	 ebp
  0019c	33 c0		 xor	 eax, eax
  0019e	5b		 pop	 ebx

; 1130 : }

  0019f	83 c4 08	 add	 esp, 8
  001a2	c3		 ret	 0
$L2318:

; 1104 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  001a3	8b 7c 24 14	 mov	 edi, DWORD PTR _flush$[esp+24]
  001a7	85 ff		 test	 edi, edi
  001a9	74 ee		 je	 SHORT $L2317

; 1126 : 	}
; 1127 :     }
; 1128 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  001ab	8b 73 54	 mov	 esi, DWORD PTR [ebx+84]
  001ae	85 f6		 test	 esi, esi
  001b0	7c 07		 jl	 SHORT $L2294
  001b2	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  001b5	03 d6		 add	 edx, esi
  001b7	eb 02		 jmp	 SHORT $L2295
$L2294:
  001b9	33 d2		 xor	 edx, edx
$L2295:
  001bb	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  001be	33 c0		 xor	 eax, eax
  001c0	83 ff 04	 cmp	 edi, 4
  001c3	0f 94 c0	 sete	 al
  001c6	2b ce		 sub	 ecx, esi
  001c8	50		 push	 eax
  001c9	51		 push	 ecx
  001ca	8b cb		 mov	 ecx, ebx
  001cc	e8 00 00 00 00	 call	 @_tr_flush_block@16
  001d1	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  001d4	8b 03		 mov	 eax, DWORD PTR [ebx]
  001d6	89 53 54	 mov	 DWORD PTR [ebx+84], edx
  001d9	e8 00 00 00 00	 call	 @flush_pending@4
  001de	8b 03		 mov	 eax, DWORD PTR [ebx]
  001e0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001e3	33 c0		 xor	 eax, eax
  001e5	85 c9		 test	 ecx, ecx
  001e7	75 12		 jne	 SHORT $L2112
  001e9	83 ff 04	 cmp	 edi, 4
  001ec	0f 95 c0	 setne	 al
  001ef	5f		 pop	 edi
  001f0	5e		 pop	 esi
  001f1	5d		 pop	 ebp
  001f2	5b		 pop	 ebx
  001f3	48		 dec	 eax
  001f4	83 e0 02	 and	 eax, 2

; 1130 : }

  001f7	83 c4 08	 add	 esp, 8
  001fa	c3		 ret	 0
$L2112:

; 1129 :     return flush == Z_FINISH ? finish_done : block_done;

  001fb	83 ff 04	 cmp	 edi, 4
  001fe	0f 94 c0	 sete	 al
  00201	5f		 pop	 edi
  00202	5e		 pop	 esi
  00203	5d		 pop	 ebp
  00204	5b		 pop	 ebx
  00205	8d 44 00 01	 lea	 eax, DWORD PTR [eax+eax+1]

; 1130 : }

  00209	83 c4 08	 add	 esp, 8
  0020c	c3		 ret	 0
@deflate_stored@8 ENDP
_TEXT	ENDS
EXTRN	__length_code:BYTE
EXTRN	__dist_code:BYTE
EXTRN	@longest_match@8:NEAR
; Function compile flags: /Ogty
;	COMDAT @deflate_fast@8
_TEXT	SEGMENT
_hash_head$ = -8					; size = 4
_flush$ = -4						; size = 4
@deflate_fast@8 PROC NEAR				; COMDAT
; _s$ = ecx
; _flush$ = edx

; 1142 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b ea		 mov	 ebp, edx

; 1143 :     IPos hash_head = NIL; /* head of the hash chain */

  00009	33 ff		 xor	 edi, edi
  0000b	89 6c 24 14	 mov	 DWORD PTR _flush$[esp+24], ebp
  0000f	8b d9		 mov	 ebx, ecx
  00011	89 7c 24 10	 mov	 DWORD PTR _hash_head$[esp+24], edi
$L2120:

; 1144 :     int bflush;           /* set if current block must be flushed */
; 1145 : 
; 1146 :     for (;;) {
; 1147 :         /* Make sure that we always have enough lookahead, except
; 1148 :          * at the end of the input file. We need MAX_MATCH bytes
; 1149 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1150 :          * string following the next match.
; 1151 :          */
; 1152 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00015	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]
  00018	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0001d	73 1f		 jae	 SHORT $L2347

; 1153 :             fill_window(s);

  0001f	e8 00 00 00 00	 call	 @fill_window@4

; 1154 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00024	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]
  00027	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0002c	73 08		 jae	 SHORT $L2346
  0002e	85 ed		 test	 ebp, ebp
  00030	0f 84 c8 02 00
	00		 je	 $L2343
$L2346:

; 1155 : 	        return need_more;
; 1156 : 	    }
; 1157 :             if (s->lookahead == 0) break; /* flush the current block */

  00036	85 c0		 test	 eax, eax
  00038	0f 84 ca 02 00
	00		 je	 $L2342
$L2347:

; 1158 :         }
; 1159 : 
; 1160 :         /* Insert the string window[strstart .. strstart+2] in the
; 1161 :          * dictionary, and set hash_head to the head of the hash chain:
; 1162 :          */
; 1163 :         if (s->lookahead >= MIN_MATCH) {

  0003e	83 f8 03	 cmp	 eax, 3
  00041	72 42		 jb	 SHORT $L2125

; 1164 :             INSERT_STRING(s, s->strstart, hash_head);

  00043	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  00046	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  00049	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  0004c	8b 73 4c	 mov	 esi, DWORD PTR [ebx+76]
  0004f	d3 e0		 shl	 eax, cl
  00051	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  00054	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [ecx+edx+2]
  00059	33 c1		 xor	 eax, ecx
  0005b	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  0005e	23 c6		 and	 eax, esi
  00060	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  00063	0f b7 3c 41	 movzx	 edi, WORD PTR [ecx+eax*2]
  00067	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  0006a	8b 4b 38	 mov	 ecx, DWORD PTR [ebx+56]
  0006d	23 c2		 and	 eax, edx
  0006f	66 89 3c 41	 mov	 WORD PTR [ecx+eax*2], di
  00073	8b 53 40	 mov	 edx, DWORD PTR [ebx+64]
  00076	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  00079	66 8b 4b 64	 mov	 cx, WORD PTR [ebx+100]
  0007d	89 7c 24 10	 mov	 DWORD PTR _hash_head$[esp+24], edi
  00081	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
$L2125:

; 1165 :         }
; 1166 : 
; 1167 :         /* Find the longest match, discarding those <= prev_length.
; 1168 :          * At this point we have always match_length < MIN_MATCH
; 1169 :          */
; 1170 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  00085	85 ff		 test	 edi, edi
  00087	74 26		 je	 SHORT $L2128
  00089	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  0008c	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0008f	2b d7		 sub	 edx, edi
  00091	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  00096	3b d0		 cmp	 edx, eax
  00098	77 15		 ja	 SHORT $L2128

; 1171 :             /* To simplify the code, we prevent matches with the string
; 1172 :              * of window index 0 (in particular we have to avoid a match
; 1173 :              * of the string with itself at the start of the input file).
; 1174 :              */
; 1175 :             if (s->strategy != Z_HUFFMAN_ONLY) {

  0009a	83 bb 80 00 00
	00 02		 cmp	 DWORD PTR [ebx+128], 2
  000a1	74 0c		 je	 SHORT $L2128

; 1176 :                 s->match_length = longest_match (s, hash_head);

  000a3	8b d7		 mov	 edx, edi
  000a5	8b cb		 mov	 ecx, ebx
  000a7	e8 00 00 00 00	 call	 @longest_match@8
  000ac	89 43 58	 mov	 DWORD PTR [ebx+88], eax
$L2128:

; 1177 :             }
; 1178 :             /* longest_match() sets match_start */
; 1179 :         }
; 1180 :         if (s->match_length >= MIN_MATCH) {

  000af	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  000b2	83 f8 03	 cmp	 eax, 3
  000b5	0f 82 34 01 00
	00		 jb	 $L2129

; 1181 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1182 : 
; 1183 :             _tr_tally_dist(s, s->strstart - s->match_start,
; 1184 :                            s->match_length - MIN_MATCH, bflush);

  000bb	8b 93 98 16 00
	00		 mov	 edx, DWORD PTR [ebx+5784]
  000c1	8b b3 9c 16 00
	00		 mov	 esi, DWORD PTR [ebx+5788]
  000c7	8a c8		 mov	 cl, al
  000c9	66 8b 43 64	 mov	 ax, WORD PTR [ebx+100]
  000cd	66 2b 43 68	 sub	 ax, WORD PTR [ebx+104]
  000d1	80 e9 03	 sub	 cl, 3
  000d4	66 89 04 56	 mov	 WORD PTR [esi+edx*2], ax
  000d8	8b 93 90 16 00
	00		 mov	 edx, DWORD PTR [ebx+5776]
  000de	8b b3 98 16 00
	00		 mov	 esi, DWORD PTR [ebx+5784]
  000e4	88 0c 32	 mov	 BYTE PTR [edx+esi], cl
  000e7	8b 93 98 16 00
	00		 mov	 edx, DWORD PTR [ebx+5784]
  000ed	42		 inc	 edx
  000ee	0f b6 c9	 movzx	 ecx, cl
  000f1	89 93 98 16 00
	00		 mov	 DWORD PTR [ebx+5784], edx
  000f7	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR __length_code[ecx]
  000fe	05 ff ff 00 00	 add	 eax, 65535		; 0000ffffH
  00103	66 ff 84 93 90
	04 00 00	 inc	 WORD PTR [ebx+edx*4+1168]
  0010b	66 3d 00 01	 cmp	 ax, 256			; 00000100H
  0010f	8d 8c 93 90 04
	00 00		 lea	 ecx, DWORD PTR [ebx+edx*4+1168]
  00116	73 0c		 jae	 SHORT $L2324
  00118	0f b7 c0	 movzx	 eax, ax
  0011b	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __dist_code[eax]
  00122	eb 0d		 jmp	 SHORT $L2325
$L2324:
  00124	0f b7 c8	 movzx	 ecx, ax
  00127	c1 e9 07	 shr	 ecx, 7
  0012a	0f b6 81 00 01
	00 00		 movzx	 eax, BYTE PTR __dist_code[ecx+256]
$L2325:
  00131	66 ff 84 83 80
	09 00 00	 inc	 WORD PTR [ebx+eax*4+2432]
  00139	8b 93 94 16 00
	00		 mov	 edx, DWORD PTR [ebx+5780]
  0013f	8b b3 98 16 00
	00		 mov	 esi, DWORD PTR [ebx+5784]

; 1185 : 
; 1186 :             s->lookahead -= s->match_length;

  00145	8b 4b 6c	 mov	 ecx, DWORD PTR [ebx+108]
  00148	33 c0		 xor	 eax, eax
  0014a	4a		 dec	 edx
  0014b	3b f2		 cmp	 esi, edx

; 1187 : 
; 1188 :             /* Insert new strings in the hash table only if the match length
; 1189 :              * is not too large. This saves time but degrades compression.
; 1190 :              */
; 1191 : #ifndef FASTEST
; 1192 :             if (s->match_length <= s->max_insert_length &&
; 1193 :                 s->lookahead >= MIN_MATCH) {

  0014d	8b 53 78	 mov	 edx, DWORD PTR [ebx+120]
  00150	0f 94 c0	 sete	 al
  00153	8b f0		 mov	 esi, eax
  00155	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  00158	2b c8		 sub	 ecx, eax
  0015a	3b c2		 cmp	 eax, edx
  0015c	89 4b 6c	 mov	 DWORD PTR [ebx+108], ecx
  0015f	77 61		 ja	 SHORT $L2132
  00161	83 f9 03	 cmp	 ecx, 3
  00164	72 5c		 jb	 SHORT $L2132

; 1194 :                 s->match_length--; /* string at strstart already in hash table */

  00166	48		 dec	 eax
  00167	89 43 58	 mov	 DWORD PTR [ebx+88], eax
  0016a	8d 9b 00 00 00
	00		 npad	 6
$L2133:

; 1195 :                 do {
; 1196 :                     s->strstart++;

  00170	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]

; 1197 :                     INSERT_STRING(s, s->strstart, hash_head);

  00173	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  00176	8b 7b 40	 mov	 edi, DWORD PTR [ebx+64]
  00179	42		 inc	 edx
  0017a	89 53 64	 mov	 DWORD PTR [ebx+100], edx
  0017d	0f b6 44 0a 02	 movzx	 eax, BYTE PTR [edx+ecx+2]
  00182	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  00185	d3 e7		 shl	 edi, cl
  00187	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  0018a	33 c7		 xor	 eax, edi
  0018c	23 43 4c	 and	 eax, DWORD PTR [ebx+76]
  0018f	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  00192	0f b7 3c 41	 movzx	 edi, WORD PTR [ecx+eax*2]
  00196	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  00199	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  0019c	23 d1		 and	 edx, ecx
  0019e	66 89 3c 50	 mov	 WORD PTR [eax+edx*2], di
  001a2	66 8b 43 64	 mov	 ax, WORD PTR [ebx+100]
  001a6	8b 4b 40	 mov	 ecx, DWORD PTR [ebx+64]
  001a9	8b 53 3c	 mov	 edx, DWORD PTR [ebx+60]
  001ac	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax

; 1198 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1199 :                      * always MIN_MATCH bytes ahead.
; 1200 :                      */
; 1201 :                 } while (--s->match_length != 0);

  001b0	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  001b3	48		 dec	 eax
  001b4	89 7c 24 10	 mov	 DWORD PTR _hash_head$[esp+24], edi
  001b8	89 43 58	 mov	 DWORD PTR [ebx+88], eax
  001bb	75 b3		 jne	 SHORT $L2133

; 1202 :                 s->strstart++; 
; 1203 :             } else

  001bd	e9 93 00 00 00	 jmp	 $L2348
$L2132:

; 1204 : #endif
; 1205 : 	    {
; 1206 :                 s->strstart += s->match_length;

  001c2	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]

; 1207 :                 s->match_length = 0;
; 1208 :                 s->ins_h = s->window[s->strstart];

  001c5	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  001c8	03 c8		 add	 ecx, eax
  001ca	03 d1		 add	 edx, ecx
  001cc	89 4b 64	 mov	 DWORD PTR [ebx+100], ecx

; 1209 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  001cf	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  001d2	c7 43 58 00 00
	00 00		 mov	 DWORD PTR [ebx+88], 0
  001d9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001dc	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  001df	d3 e0		 shl	 eax, cl
  001e1	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  001e5	33 c1		 xor	 eax, ecx
  001e7	23 43 4c	 and	 eax, DWORD PTR [ebx+76]
  001ea	89 43 40	 mov	 DWORD PTR [ebx+64], eax

; 1210 : #if MIN_MATCH != 3
; 1211 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1212 : #endif
; 1213 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1214 :                  * matter since it will be recomputed at next deflate call.
; 1215 :                  */
; 1216 :             }
; 1217 :         } else {

  001ed	eb 69		 jmp	 SHORT $L2138
$L2129:

; 1218 :             /* No match, output a literal byte */
; 1219 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1220 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  001ef	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  001f2	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  001f5	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  001f8	8b 8b 98 16 00
	00		 mov	 ecx, DWORD PTR [ebx+5784]
  001fe	8b 93 9c 16 00
	00		 mov	 edx, DWORD PTR [ebx+5788]
  00204	66 c7 04 4a 00
	00		 mov	 WORD PTR [edx+ecx*2], 0
  0020a	8b 93 98 16 00
	00		 mov	 edx, DWORD PTR [ebx+5784]
  00210	8b 8b 90 16 00
	00		 mov	 ecx, DWORD PTR [ebx+5776]
  00216	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00219	8b 93 98 16 00
	00		 mov	 edx, DWORD PTR [ebx+5784]
  0021f	42		 inc	 edx
  00220	0f b6 c0	 movzx	 eax, al
  00223	89 93 98 16 00
	00		 mov	 DWORD PTR [ebx+5784], edx
  00229	66 ff 84 83 8c
	00 00 00	 inc	 WORD PTR [ebx+eax*4+140]
  00231	8b 8b 94 16 00
	00		 mov	 ecx, DWORD PTR [ebx+5780]
  00237	8b b3 98 16 00
	00		 mov	 esi, DWORD PTR [ebx+5784]
  0023d	8d 84 83 8c 00
	00 00		 lea	 eax, DWORD PTR [ebx+eax*4+140]
  00244	49		 dec	 ecx
  00245	33 d2		 xor	 edx, edx
  00247	3b f1		 cmp	 esi, ecx

; 1221 :             s->lookahead--;

  00249	8b 4b 6c	 mov	 ecx, DWORD PTR [ebx+108]
  0024c	0f 94 c2	 sete	 dl
  0024f	49		 dec	 ecx
  00250	89 4b 6c	 mov	 DWORD PTR [ebx+108], ecx
  00253	8b f2		 mov	 esi, edx
$L2348:

; 1222 :             s->strstart++; 

  00255	ff 43 64	 inc	 DWORD PTR [ebx+100]
$L2138:

; 1223 :         }
; 1224 :         if (bflush) FLUSH_BLOCK(s, 0);

  00258	85 f6		 test	 esi, esi
  0025a	0f 84 b5 fd ff
	ff		 je	 $L2120
  00260	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  00263	85 c0		 test	 eax, eax
  00265	7c 07		 jl	 SHORT $L2326
  00267	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  0026a	03 d0		 add	 edx, eax
  0026c	eb 02		 jmp	 SHORT $L2327
$L2326:
  0026e	33 d2		 xor	 edx, edx
$L2327:
  00270	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  00273	2b c8		 sub	 ecx, eax
  00275	6a 00		 push	 0
  00277	51		 push	 ecx
  00278	8b cb		 mov	 ecx, ebx
  0027a	e8 00 00 00 00	 call	 @_tr_flush_block@16
  0027f	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  00282	8b 03		 mov	 eax, DWORD PTR [ebx]
  00284	89 53 54	 mov	 DWORD PTR [ebx+84], edx
  00287	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  0028a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0028d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00290	3b d1		 cmp	 edx, ecx
  00292	76 02		 jbe	 SHORT $L2334
  00294	8b d1		 mov	 edx, ecx
$L2334:
  00296	85 d2		 test	 edx, edx
  00298	74 57		 je	 SHORT $L2336
  0029a	8b 76 10	 mov	 esi, DWORD PTR [esi+16]
  0029d	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  002a0	8b ca		 mov	 ecx, edx
  002a2	8b e9		 mov	 ebp, ecx
  002a4	c1 e9 02	 shr	 ecx, 2
  002a7	f3 a5		 rep movsd
  002a9	8b cd		 mov	 ecx, ebp
  002ab	83 e1 03	 and	 ecx, 3
  002ae	f3 a4		 rep movsb
  002b0	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  002b3	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  002b6	03 fa		 add	 edi, edx
  002b8	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  002bb	01 51 10	 add	 DWORD PTR [ecx+16], edx
  002be	8b 68 14	 mov	 ebp, DWORD PTR [eax+20]
  002c1	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  002c4	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  002c7	03 ea		 add	 ebp, edx
  002c9	89 68 14	 mov	 DWORD PTR [eax+20], ebp
  002cc	8b 6c 24 14	 mov	 ebp, DWORD PTR _flush$[esp+24]
  002d0	2b fa		 sub	 edi, edx
  002d2	89 78 10	 mov	 DWORD PTR [eax+16], edi
  002d5	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  002d8	8b 7c 24 10	 mov	 edi, DWORD PTR _hash_head$[esp+24]
  002dc	2b f2		 sub	 esi, edx
  002de	89 71 14	 mov	 DWORD PTR [ecx+20], esi
  002e1	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  002e4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002e7	85 c9		 test	 ecx, ecx
  002e9	75 06		 jne	 SHORT $L2336
  002eb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002ee	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$L2336:
  002f1	8b 13		 mov	 edx, DWORD PTR [ebx]
  002f3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002f6	85 c0		 test	 eax, eax
  002f8	0f 85 17 fd ff
	ff		 jne	 $L2120
$L2343:
  002fe	5f		 pop	 edi
  002ff	5e		 pop	 esi
  00300	5d		 pop	 ebp
  00301	33 c0		 xor	 eax, eax
  00303	5b		 pop	 ebx

; 1228 : }

  00304	83 c4 08	 add	 esp, 8
  00307	c3		 ret	 0
$L2342:

; 1225 :     }
; 1226 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00308	8b 73 54	 mov	 esi, DWORD PTR [ebx+84]
  0030b	85 f6		 test	 esi, esi
  0030d	7c 07		 jl	 SHORT $L2328
  0030f	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  00312	03 d6		 add	 edx, esi
  00314	eb 02		 jmp	 SHORT $L2329
$L2328:
  00316	33 d2		 xor	 edx, edx
$L2329:
  00318	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  0031b	33 c0		 xor	 eax, eax
  0031d	83 fd 04	 cmp	 ebp, 4
  00320	0f 94 c0	 sete	 al
  00323	2b ce		 sub	 ecx, esi
  00325	50		 push	 eax
  00326	51		 push	 ecx
  00327	8b cb		 mov	 ecx, ebx
  00329	e8 00 00 00 00	 call	 @_tr_flush_block@16
  0032e	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  00331	8b 03		 mov	 eax, DWORD PTR [ebx]
  00333	89 53 54	 mov	 DWORD PTR [ebx+84], edx
  00336	e8 00 00 00 00	 call	 @flush_pending@4
  0033b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0033d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00340	33 c0		 xor	 eax, eax
  00342	85 c9		 test	 ecx, ecx
  00344	75 12		 jne	 SHORT $L2152
  00346	83 fd 04	 cmp	 ebp, 4
  00349	0f 95 c0	 setne	 al
  0034c	5f		 pop	 edi
  0034d	5e		 pop	 esi
  0034e	5d		 pop	 ebp
  0034f	5b		 pop	 ebx
  00350	48		 dec	 eax
  00351	83 e0 02	 and	 eax, 2

; 1228 : }

  00354	83 c4 08	 add	 esp, 8
  00357	c3		 ret	 0
$L2152:

; 1227 :     return flush == Z_FINISH ? finish_done : block_done;

  00358	83 fd 04	 cmp	 ebp, 4
  0035b	0f 94 c0	 sete	 al
  0035e	5f		 pop	 edi
  0035f	5e		 pop	 esi
  00360	5d		 pop	 ebp
  00361	5b		 pop	 ebx
  00362	8d 44 00 01	 lea	 eax, DWORD PTR [eax+eax+1]

; 1228 : }

  00366	83 c4 08	 add	 esp, 8
  00369	c3		 ret	 0
@deflate_fast@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @deflate_slow@8
_TEXT	SEGMENT
_flush$ = -4						; size = 4
@deflate_slow@8 PROC NEAR				; COMDAT
; _s$ = ecx
; _flush$ = edx

; 1238 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b fa		 mov	 edi, edx
  00007	89 7c 24 10	 mov	 DWORD PTR _flush$[esp+20], edi
  0000b	8b d9		 mov	 ebx, ecx

; 1239 :     IPos hash_head = NIL;    /* head of hash chain */

  0000d	33 ed		 xor	 ebp, ebp
  0000f	eb 04		 jmp	 SHORT $L2160
$L2366:
  00011	8b 7c 24 10	 mov	 edi, DWORD PTR _flush$[esp+20]
$L2160:

; 1240 :     int bflush;              /* set if current block must be flushed */
; 1241 : 
; 1242 :     /* Process the input block. */
; 1243 :     for (;;) {
; 1244 :         /* Make sure that we always have enough lookahead, except
; 1245 :          * at the end of the input file. We need MAX_MATCH bytes
; 1246 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1247 :          * string following the next match.
; 1248 :          */
; 1249 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00015	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]
  00018	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0001d	73 1f		 jae	 SHORT $L2164

; 1250 :             fill_window(s);

  0001f	e8 00 00 00 00	 call	 @fill_window@4

; 1251 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00024	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]
  00027	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0002c	73 08		 jae	 SHORT $L2369
  0002e	85 ff		 test	 edi, edi
  00030	0f 84 2c 02 00
	00		 je	 $L2365
$L2369:

; 1252 : 	        return need_more;
; 1253 : 	    }
; 1254 :             if (s->lookahead == 0) break; /* flush the current block */

  00036	85 c0		 test	 eax, eax
  00038	0f 84 fb 02 00
	00		 je	 $L2363
$L2164:

; 1255 :         }
; 1256 : 
; 1257 :         /* Insert the string window[strstart .. strstart+2] in the
; 1258 :          * dictionary, and set hash_head to the head of the hash chain:
; 1259 :          */
; 1260 :         if (s->lookahead >= MIN_MATCH) {

  0003e	83 f8 03	 cmp	 eax, 3
  00041	72 3e		 jb	 SHORT $L2165

; 1261 :             INSERT_STRING(s, s->strstart, hash_head);

  00043	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  00046	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  00049	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  0004c	8b 73 4c	 mov	 esi, DWORD PTR [ebx+76]
  0004f	d3 e0		 shl	 eax, cl
  00051	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  00054	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [ecx+edx+2]
  00059	33 c1		 xor	 eax, ecx
  0005b	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  0005e	23 c6		 and	 eax, esi
  00060	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  00063	0f b7 2c 41	 movzx	 ebp, WORD PTR [ecx+eax*2]
  00067	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  0006a	8b 4b 38	 mov	 ecx, DWORD PTR [ebx+56]
  0006d	23 c2		 and	 eax, edx
  0006f	66 89 2c 41	 mov	 WORD PTR [ecx+eax*2], bp
  00073	8b 53 40	 mov	 edx, DWORD PTR [ebx+64]
  00076	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  00079	66 8b 4b 64	 mov	 cx, WORD PTR [ebx+100]
  0007d	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
$L2165:

; 1262 :         }
; 1263 : 
; 1264 :         /* Find the longest match, discarding those <= prev_length.
; 1265 :          */
; 1266 :         s->prev_length = s->match_length, s->prev_match = s->match_start;
; 1267 :         s->match_length = MIN_MATCH-1;
; 1268 : 
; 1269 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
; 1270 :             s->strstart - hash_head <= MAX_DIST(s)) {

  00081	85 ed		 test	 ebp, ebp
  00083	8b 53 58	 mov	 edx, DWORD PTR [ebx+88]
  00086	8b 43 68	 mov	 eax, DWORD PTR [ebx+104]
  00089	be 02 00 00 00	 mov	 esi, 2
  0008e	89 53 70	 mov	 DWORD PTR [ebx+112], edx
  00091	89 43 5c	 mov	 DWORD PTR [ebx+92], eax
  00094	89 73 58	 mov	 DWORD PTR [ebx+88], esi
  00097	74 55		 je	 SHORT $L2370
  00099	8b 43 78	 mov	 eax, DWORD PTR [ebx+120]
  0009c	8b ca		 mov	 ecx, edx
  0009e	3b c8		 cmp	 ecx, eax
  000a0	73 4c		 jae	 SHORT $L2370
  000a2	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  000a5	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  000a8	2b d5		 sub	 edx, ebp
  000aa	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000af	3b d0		 cmp	 edx, eax
  000b1	77 3b		 ja	 SHORT $L2370

; 1271 :             /* To simplify the code, we prevent matches with the string
; 1272 :              * of window index 0 (in particular we have to avoid a match
; 1273 :              * of the string with itself at the start of the input file).
; 1274 :              */
; 1275 :             if (s->strategy != Z_HUFFMAN_ONLY) {

  000b3	39 b3 80 00 00
	00		 cmp	 DWORD PTR [ebx+128], esi
  000b9	74 0c		 je	 SHORT $L2168

; 1276 :                 s->match_length = longest_match (s, hash_head);

  000bb	8b d5		 mov	 edx, ebp
  000bd	8b cb		 mov	 ecx, ebx
  000bf	e8 00 00 00 00	 call	 @longest_match@8
  000c4	89 43 58	 mov	 DWORD PTR [ebx+88], eax
$L2168:

; 1277 :             }
; 1278 :             /* longest_match() sets match_start */
; 1279 : 
; 1280 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
; 1281 :                  (s->match_length == MIN_MATCH &&
; 1282 :                   s->strstart - s->match_start > TOO_FAR))) {

  000c7	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  000ca	83 f8 05	 cmp	 eax, 5
  000cd	77 1f		 ja	 SHORT $L2370
  000cf	83 bb 80 00 00
	00 01		 cmp	 DWORD PTR [ebx+128], 1
  000d6	74 13		 je	 SHORT $L2368
  000d8	83 f8 03	 cmp	 eax, 3
  000db	75 11		 jne	 SHORT $L2370
  000dd	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  000e0	2b 4b 68	 sub	 ecx, DWORD PTR [ebx+104]
  000e3	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000e9	76 03		 jbe	 SHORT $L2370
$L2368:

; 1283 : 
; 1284 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1285 :                  * but we will ignore the current match anyway.
; 1286 :                  */
; 1287 :                 s->match_length = MIN_MATCH-1;

  000eb	89 73 58	 mov	 DWORD PTR [ebx+88], esi
$L2370:

; 1288 :             }
; 1289 :         }
; 1290 :         /* If there was a match at the previous step and the current
; 1291 :          * match is not better, output the previous match:
; 1292 :          */
; 1293 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  000ee	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  000f1	83 f8 03	 cmp	 eax, 3
  000f4	0f 82 70 01 00
	00		 jb	 $L2171
  000fa	39 43 58	 cmp	 DWORD PTR [ebx+88], eax
  000fd	0f 87 67 01 00
	00		 ja	 $L2171

; 1294 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  00103	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  00106	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]

; 1295 :             /* Do not insert strings in hash table beyond this. */
; 1296 : 
; 1297 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1298 : 
; 1299 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,
; 1300 : 			   s->prev_length - MIN_MATCH, bflush);

  00109	8a 4b 70	 mov	 cl, BYTE PTR [ebx+112]
  0010c	8b bb 9c 16 00
	00		 mov	 edi, DWORD PTR [ebx+5788]
  00112	8d 74 02 fd	 lea	 esi, DWORD PTR [edx+eax-3]
  00116	33 c0		 xor	 eax, eax
  00118	66 8b c2	 mov	 ax, dx
  0011b	66 2b 43 5c	 sub	 ax, WORD PTR [ebx+92]
  0011f	8b 93 98 16 00
	00		 mov	 edx, DWORD PTR [ebx+5784]
  00125	80 e9 03	 sub	 cl, 3
  00128	48		 dec	 eax
  00129	66 89 04 57	 mov	 WORD PTR [edi+edx*2], ax
  0012d	8b 93 90 16 00
	00		 mov	 edx, DWORD PTR [ebx+5776]
  00133	8b bb 98 16 00
	00		 mov	 edi, DWORD PTR [ebx+5784]
  00139	88 0c 3a	 mov	 BYTE PTR [edx+edi], cl
  0013c	8b 93 98 16 00
	00		 mov	 edx, DWORD PTR [ebx+5784]
  00142	42		 inc	 edx
  00143	0f b6 c9	 movzx	 ecx, cl
  00146	89 93 98 16 00
	00		 mov	 DWORD PTR [ebx+5784], edx
  0014c	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR __length_code[ecx]
  00153	05 ff ff 00 00	 add	 eax, 65535		; 0000ffffH
  00158	66 ff 84 93 90
	04 00 00	 inc	 WORD PTR [ebx+edx*4+1168]
  00160	66 3d 00 01	 cmp	 ax, 256			; 00000100H
  00164	8d 8c 93 90 04
	00 00		 lea	 ecx, DWORD PTR [ebx+edx*4+1168]
  0016b	73 0c		 jae	 SHORT $L2351
  0016d	0f b7 c0	 movzx	 eax, ax
  00170	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __dist_code[eax]
  00177	eb 0d		 jmp	 SHORT $L2352
$L2351:
  00179	0f b7 c8	 movzx	 ecx, ax
  0017c	c1 e9 07	 shr	 ecx, 7
  0017f	0f b6 81 00 01
	00 00		 movzx	 eax, BYTE PTR __dist_code[ecx+256]
$L2352:
  00186	66 ff 84 83 80
	09 00 00	 inc	 WORD PTR [ebx+eax*4+2432]
  0018e	8b 93 94 16 00
	00		 mov	 edx, DWORD PTR [ebx+5780]
  00194	8b bb 98 16 00
	00		 mov	 edi, DWORD PTR [ebx+5784]
  0019a	4a		 dec	 edx
  0019b	33 c0		 xor	 eax, eax
  0019d	3b fa		 cmp	 edi, edx

; 1301 : 
; 1302 :             /* Insert in hash table all strings up to the end of the match.
; 1303 :              * strstart-1 and strstart are already inserted. If there is not
; 1304 :              * enough lookahead, the last two strings are not inserted in
; 1305 :              * the hash table.
; 1306 :              */
; 1307 :             s->lookahead -= s->prev_length-1;

  0019f	8b 53 6c	 mov	 edx, DWORD PTR [ebx+108]
  001a2	0f 94 c0	 sete	 al
  001a5	b9 01 00 00 00	 mov	 ecx, 1
  001aa	8b f8		 mov	 edi, eax
  001ac	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  001af	2b c8		 sub	 ecx, eax
  001b1	03 d1		 add	 edx, ecx

; 1308 :             s->prev_length -= 2;

  001b3	83 c0 fe	 add	 eax, -2			; fffffffeH
  001b6	89 53 6c	 mov	 DWORD PTR [ebx+108], edx
  001b9	89 43 70	 mov	 DWORD PTR [ebx+112], eax
  001bc	8d 64 24 00	 npad	 4
$L2175:

; 1309 :             do {
; 1310 :                 if (++s->strstart <= max_insert) {

  001c0	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  001c3	41		 inc	 ecx
  001c4	8b d1		 mov	 edx, ecx
  001c6	3b d6		 cmp	 edx, esi
  001c8	89 4b 64	 mov	 DWORD PTR [ebx+100], ecx
  001cb	77 3b		 ja	 SHORT $L2176

; 1311 :                     INSERT_STRING(s, s->strstart, hash_head);

  001cd	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  001d0	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  001d3	8b 6b 4c	 mov	 ebp, DWORD PTR [ebx+76]
  001d6	d3 e0		 shl	 eax, cl
  001d8	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  001db	0f b6 4c 11 02	 movzx	 ecx, BYTE PTR [ecx+edx+2]
  001e0	33 c1		 xor	 eax, ecx
  001e2	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  001e5	23 c5		 and	 eax, ebp
  001e7	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  001ea	0f b7 2c 41	 movzx	 ebp, WORD PTR [ecx+eax*2]
  001ee	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  001f1	8b 4b 38	 mov	 ecx, DWORD PTR [ebx+56]
  001f4	23 c2		 and	 eax, edx
  001f6	66 89 2c 41	 mov	 WORD PTR [ecx+eax*2], bp
  001fa	8b 53 40	 mov	 edx, DWORD PTR [ebx+64]
  001fd	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  00200	66 8b 4b 64	 mov	 cx, WORD PTR [ebx+100]
  00204	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
$L2176:

; 1312 :                 }
; 1313 :             } while (--s->prev_length != 0);

  00208	ff 4b 70	 dec	 DWORD PTR [ebx+112]
  0020b	75 b3		 jne	 SHORT $L2175

; 1314 :             s->match_available = 0;
; 1315 :             s->match_length = MIN_MATCH-1;
; 1316 :             s->strstart++;

  0020d	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  00210	42		 inc	 edx

; 1317 : 
; 1318 :             if (bflush) FLUSH_BLOCK(s, 0);

  00211	85 ff		 test	 edi, edi
  00213	c7 43 60 00 00
	00 00		 mov	 DWORD PTR [ebx+96], 0
  0021a	c7 43 58 02 00
	00 00		 mov	 DWORD PTR [ebx+88], 2
  00221	89 53 64	 mov	 DWORD PTR [ebx+100], edx
  00224	8b c2		 mov	 eax, edx
  00226	0f 84 e5 fd ff
	ff		 je	 $L2366
  0022c	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  0022f	85 c9		 test	 ecx, ecx
  00231	7c 07		 jl	 SHORT $L2353
  00233	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  00236	03 d1		 add	 edx, ecx
  00238	eb 02		 jmp	 SHORT $L2354
$L2353:
  0023a	33 d2		 xor	 edx, edx
$L2354:
  0023c	2b c1		 sub	 eax, ecx
  0023e	6a 00		 push	 0
  00240	50		 push	 eax
  00241	8b cb		 mov	 ecx, ebx
  00243	e8 00 00 00 00	 call	 @_tr_flush_block@16
  00248	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  0024b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0024d	89 53 54	 mov	 DWORD PTR [ebx+84], edx
  00250	e8 00 00 00 00	 call	 @flush_pending@4
  00255	8b 03		 mov	 eax, DWORD PTR [ebx]
  00257	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0025a	85 c9		 test	 ecx, ecx
  0025c	0f 85 af fd ff
	ff		 jne	 $L2366
$L2365:
  00262	5f		 pop	 edi
  00263	5e		 pop	 esi
  00264	5d		 pop	 ebp

; 1332 :             if (s->strm->avail_out == 0) return need_more;

  00265	33 c0		 xor	 eax, eax
  00267	5b		 pop	 ebx

; 1350 : }

  00268	59		 pop	 ecx
  00269	c3		 ret	 0
$L2171:

; 1319 : 
; 1320 :         } else if (s->match_available) {

  0026a	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  0026d	85 c0		 test	 eax, eax
  0026f	0f 84 aa 00 00
	00		 je	 $L2188

; 1321 :             /* If there was no match at the previous position, output a
; 1322 :              * single literal. If there was a match but the current match
; 1323 :              * is longer, truncate the previous match to a single literal.
; 1324 :              */
; 1325 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1326 : 	    _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00275	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  00278	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  0027b	8a 44 11 ff	 mov	 al, BYTE PTR [ecx+edx-1]
  0027f	8b 8b 98 16 00
	00		 mov	 ecx, DWORD PTR [ebx+5784]
  00285	8b 93 9c 16 00
	00		 mov	 edx, DWORD PTR [ebx+5788]
  0028b	66 c7 04 4a 00
	00		 mov	 WORD PTR [edx+ecx*2], 0
  00291	8b 8b 90 16 00
	00		 mov	 ecx, DWORD PTR [ebx+5776]
  00297	8b 93 98 16 00
	00		 mov	 edx, DWORD PTR [ebx+5784]
  0029d	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  002a0	8b 8b 98 16 00
	00		 mov	 ecx, DWORD PTR [ebx+5784]
  002a6	41		 inc	 ecx
  002a7	0f b6 c0	 movzx	 eax, al
  002aa	89 8b 98 16 00
	00		 mov	 DWORD PTR [ebx+5784], ecx
  002b0	66 ff 84 83 8c
	00 00 00	 inc	 WORD PTR [ebx+eax*4+140]
  002b8	8b 8b 94 16 00
	00		 mov	 ecx, DWORD PTR [ebx+5780]
  002be	8d 84 83 8c 00
	00 00		 lea	 eax, DWORD PTR [ebx+eax*4+140]
  002c5	8b 83 98 16 00
	00		 mov	 eax, DWORD PTR [ebx+5784]
  002cb	49		 dec	 ecx
  002cc	3b c1		 cmp	 eax, ecx

; 1327 : 	    if (bflush) {

  002ce	75 2c		 jne	 SHORT $L2190

; 1328 :                 FLUSH_BLOCK_ONLY(s, 0);

  002d0	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  002d3	85 c0		 test	 eax, eax
  002d5	7c 07		 jl	 SHORT $L2355
  002d7	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  002da	03 d0		 add	 edx, eax
  002dc	eb 02		 jmp	 SHORT $L2356
$L2355:
  002de	33 d2		 xor	 edx, edx
$L2356:
  002e0	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  002e3	2b c8		 sub	 ecx, eax
  002e5	6a 00		 push	 0
  002e7	51		 push	 ecx
  002e8	8b cb		 mov	 ecx, ebx
  002ea	e8 00 00 00 00	 call	 @_tr_flush_block@16
  002ef	8b 53 64	 mov	 edx, DWORD PTR [ebx+100]
  002f2	8b 03		 mov	 eax, DWORD PTR [ebx]
  002f4	89 53 54	 mov	 DWORD PTR [ebx+84], edx
  002f7	e8 00 00 00 00	 call	 @flush_pending@4
$L2190:

; 1329 :             }
; 1330 :             s->strstart++;

  002fc	8b 73 64	 mov	 esi, DWORD PTR [ebx+100]

; 1331 :             s->lookahead--;

  002ff	8b 53 6c	 mov	 edx, DWORD PTR [ebx+108]

; 1332 :             if (s->strm->avail_out == 0) return need_more;

  00302	8b 03		 mov	 eax, DWORD PTR [ebx]
  00304	46		 inc	 esi
  00305	4a		 dec	 edx
  00306	89 73 64	 mov	 DWORD PTR [ebx+100], esi
  00309	89 53 6c	 mov	 DWORD PTR [ebx+108], edx
  0030c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0030f	85 c9		 test	 ecx, ecx
  00311	0f 85 fe fc ff
	ff		 jne	 $L2160
  00317	5f		 pop	 edi
  00318	5e		 pop	 esi
  00319	5d		 pop	 ebp
  0031a	33 c0		 xor	 eax, eax
  0031c	5b		 pop	 ebx

; 1350 : }

  0031d	59		 pop	 ecx
  0031e	c3		 ret	 0
$L2188:

; 1333 :         } else {
; 1334 :             /* There is no previous match to compare with, wait for
; 1335 :              * the next step to decide.
; 1336 :              */
; 1337 :             s->match_available = 1;
; 1338 :             s->strstart++;

  0031f	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]

; 1339 :             s->lookahead--;

  00322	8b 43 6c	 mov	 eax, DWORD PTR [ebx+108]
  00325	41		 inc	 ecx
  00326	48		 dec	 eax
  00327	c7 43 60 01 00
	00 00		 mov	 DWORD PTR [ebx+96], 1
  0032e	89 4b 64	 mov	 DWORD PTR [ebx+100], ecx
  00331	89 43 6c	 mov	 DWORD PTR [ebx+108], eax

; 1340 :         }
; 1341 :     }

  00334	e9 dc fc ff ff	 jmp	 $L2160
$L2363:

; 1342 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 1343 :     if (s->match_available) {

  00339	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  0033c	85 c0		 test	 eax, eax
  0033e	74 4c		 je	 SHORT $L2198

; 1344 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1345 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00340	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  00343	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  00346	8a 44 11 ff	 mov	 al, BYTE PTR [ecx+edx-1]
  0034a	8b 8b 98 16 00
	00		 mov	 ecx, DWORD PTR [ebx+5784]
  00350	8b 93 9c 16 00
	00		 mov	 edx, DWORD PTR [ebx+5788]
  00356	66 c7 04 4a 00
	00		 mov	 WORD PTR [edx+ecx*2], 0
  0035c	8b 93 98 16 00
	00		 mov	 edx, DWORD PTR [ebx+5784]
  00362	8b 8b 90 16 00
	00		 mov	 ecx, DWORD PTR [ebx+5776]
  00368	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  0036b	8b 93 98 16 00
	00		 mov	 edx, DWORD PTR [ebx+5784]
  00371	0f b6 c0	 movzx	 eax, al
  00374	42		 inc	 edx
  00375	8d 84 83 8c 00
	00 00		 lea	 eax, DWORD PTR [ebx+eax*4+140]
  0037c	89 93 98 16 00
	00		 mov	 DWORD PTR [ebx+5784], edx
  00382	66 ff 00	 inc	 WORD PTR [eax]

; 1346 :         s->match_available = 0;

  00385	c7 43 60 00 00
	00 00		 mov	 DWORD PTR [ebx+96], 0
$L2198:

; 1347 :     }
; 1348 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  0038c	8b 73 54	 mov	 esi, DWORD PTR [ebx+84]
  0038f	85 f6		 test	 esi, esi
  00391	7c 07		 jl	 SHORT $L2357
  00393	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  00396	03 d6		 add	 edx, esi
  00398	eb 02		 jmp	 SHORT $L2358
$L2357:
  0039a	33 d2		 xor	 edx, edx
$L2358:
  0039c	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]
  0039f	33 c9		 xor	 ecx, ecx
  003a1	83 ff 04	 cmp	 edi, 4
  003a4	0f 94 c1	 sete	 cl
  003a7	2b c6		 sub	 eax, esi
  003a9	51		 push	 ecx
  003aa	50		 push	 eax
  003ab	8b cb		 mov	 ecx, ebx
  003ad	e8 00 00 00 00	 call	 @_tr_flush_block@16
  003b2	8b 4b 64	 mov	 ecx, DWORD PTR [ebx+100]
  003b5	8b 03		 mov	 eax, DWORD PTR [ebx]
  003b7	89 4b 54	 mov	 DWORD PTR [ebx+84], ecx
  003ba	e8 00 00 00 00	 call	 @flush_pending@4
  003bf	8b 13		 mov	 edx, DWORD PTR [ebx]
  003c1	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  003c4	85 c0		 test	 eax, eax
  003c6	75 12		 jne	 SHORT $L2205
  003c8	33 c0		 xor	 eax, eax
  003ca	83 ff 04	 cmp	 edi, 4
  003cd	0f 95 c0	 setne	 al
  003d0	5f		 pop	 edi
  003d1	5e		 pop	 esi
  003d2	5d		 pop	 ebp
  003d3	5b		 pop	 ebx
  003d4	48		 dec	 eax
  003d5	83 e0 02	 and	 eax, 2

; 1350 : }

  003d8	59		 pop	 ecx
  003d9	c3		 ret	 0
$L2205:

; 1349 :     return flush == Z_FINISH ? finish_done : block_done;

  003da	33 c0		 xor	 eax, eax
  003dc	83 ff 04	 cmp	 edi, 4
  003df	0f 94 c0	 sete	 al
  003e2	5f		 pop	 edi
  003e3	5e		 pop	 esi
  003e4	5d		 pop	 ebp
  003e5	5b		 pop	 ebx
  003e6	8d 44 00 01	 lea	 eax, DWORD PTR [eax+eax+1]

; 1350 : }

  003ea	59		 pop	 ecx
  003eb	c3		 ret	 0
@deflate_slow@8 ENDP
_TEXT	ENDS
PUBLIC	@deflateReset@4
EXTRN	@_tr_init@4:NEAR
; Function compile flags: /Ogty
;	COMDAT @deflateReset@4
_TEXT	SEGMENT
@deflateReset@4 PROC NEAR				; COMDAT
; _strm$ = ecx

; 335  :     deflate_state *s;
; 336  :     
; 337  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 338  :         strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;

  00000	33 c0		 xor	 eax, eax
  00002	3b c8		 cmp	 ecx, eax
  00004	56		 push	 esi
  00005	74 5e		 je	 SHORT $L1897
  00007	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  0000a	3b f0		 cmp	 esi, eax
  0000c	74 57		 je	 SHORT $L1897
  0000e	39 41 20	 cmp	 DWORD PTR [ecx+32], eax
  00011	74 52		 je	 SHORT $L1897
  00013	39 41 24	 cmp	 DWORD PTR [ecx+36], eax
  00016	74 4d		 je	 SHORT $L1897

; 339  : 
; 340  :     strm->total_in = strm->total_out = 0;

  00018	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0001b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 341  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */

  0001e	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 342  :     strm->data_type = Z_UNKNOWN;

  00021	c7 41 2c 02 00
	00 00		 mov	 DWORD PTR [ecx+44], 2

; 343  : 
; 344  :     s = (deflate_state *)strm->state;
; 345  :     s->pending = 0;
; 346  :     s->pending_out = s->pending_buf;

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002b	89 56 10	 mov	 DWORD PTR [esi+16], edx

; 347  : 
; 348  :     if (s->noheader < 0) {

  0002e	39 46 18	 cmp	 DWORD PTR [esi+24], eax
  00031	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00034	7d 03		 jge	 SHORT $L1899

; 349  :         s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */

  00036	89 46 18	 mov	 DWORD PTR [esi+24], eax
$L1899:

; 350  :     }
; 351  :     s->status = s->noheader ? BUSY_STATE : INIT_STATE;

  00039	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0003c	f7 da		 neg	 edx
  0003e	1b d2		 sbb	 edx, edx
  00040	83 e2 47	 and	 edx, 71			; 00000047H
  00043	83 c2 2a	 add	 edx, 42			; 0000002aH
  00046	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 352  :     strm->adler = 1;

  00049	c7 41 30 01 00
	00 00		 mov	 DWORD PTR [ecx+48], 1

; 353  :     s->last_flush = Z_NO_FLUSH;
; 354  : 
; 355  :     _tr_init(s);

  00050	8b ce		 mov	 ecx, esi
  00052	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00055	e8 00 00 00 00	 call	 @_tr_init@4

; 356  :     lm_init(s);

  0005a	8b d6		 mov	 edx, esi
  0005c	e8 00 00 00 00	 call	 @lm_init@4

; 357  : 
; 358  :     return Z_OK;

  00061	33 c0		 xor	 eax, eax
  00063	5e		 pop	 esi

; 359  : }

  00064	c3		 ret	 0
$L1897:

; 335  :     deflate_state *s;
; 336  :     
; 337  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 338  :         strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;

  00065	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0006a	5e		 pop	 esi

; 359  : }

  0006b	c3		 ret	 0
@deflateReset@4 ENDP
_TEXT	ENDS
PUBLIC	@deflateParams@12
; Function compile flags: /Ogty
;	COMDAT @deflateParams@12
_TEXT	SEGMENT
_level$ = -8						; size = 4
tv305 = -4						; size = 4
_strategy$ = 8						; size = 4
@deflateParams@12 PROC NEAR				; COMDAT
; _strm$ = ecx
; _level$ = edx

; 366  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 367  :     deflate_state *s;
; 368  :     compress_func func;
; 369  :     int err = Z_OK;

  00007	33 c0		 xor	 eax, eax

; 370  : 
; 371  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	85 ff		 test	 edi, edi
  0000b	89 54 24 08	 mov	 DWORD PTR _level$[esp+16], edx
  0000f	0f 84 5f 02 00
	00		 je	 $L1909
  00015	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  00018	85 f6		 test	 esi, esi
  0001a	0f 84 54 02 00
	00		 je	 $L1909

; 372  :     s = strm->state;
; 373  : 
; 374  :     if (level == Z_DEFAULT_COMPRESSION) {

  00020	83 fa ff	 cmp	 edx, -1
  00023	75 0a		 jne	 SHORT $L1910

; 375  : 	level = 6;

  00025	c7 44 24 08 06
	00 00 00	 mov	 DWORD PTR _level$[esp+16], 6

; 376  :     }
; 377  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {

  0002d	eb 11		 jmp	 SHORT $L2416
$L1910:
  0002f	85 d2		 test	 edx, edx
  00031	0f 8c 3d 02 00
	00		 jl	 $L1909
  00037	83 fa 09	 cmp	 edx, 9
  0003a	0f 8f 34 02 00
	00		 jg	 $L1909
$L2416:
  00040	8b 4c 24 14	 mov	 ecx, DWORD PTR _strategy$[esp+12]
  00044	85 c9		 test	 ecx, ecx
  00046	0f 8c 28 02 00
	00		 jl	 $L1909
  0004c	83 f9 02	 cmp	 ecx, 2
  0004f	0f 8f 1f 02 00
	00		 jg	 $L1909

; 378  : 	return Z_STREAM_ERROR;
; 379  :     }
; 380  :     func = configuration_table[s->level].func;

  00055	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00058	53		 push	 ebx
  00059	55		 push	 ebp

; 381  : 
; 382  :     if (func != configuration_table[level].func && strm->total_in != 0) {

  0005a	8b 6c 24 10	 mov	 ebp, DWORD PTR _level$[esp+24]
  0005e	8d 6c 6d 00	 lea	 ebp, DWORD PTR [ebp+ebp*2]
  00062	c1 e5 02	 shl	 ebp, 2
  00065	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00068	8b 14 8d 08 00
	00 00		 mov	 edx, DWORD PTR _configuration_table[ecx*4+8]
  0006f	3b 95 08 00 00
	00		 cmp	 edx, DWORD PTR _configuration_table[ebp+8]
  00075	89 6c 24 14	 mov	 DWORD PTR tv305[esp+24], ebp
  00079	0f 84 a7 01 00
	00		 je	 $L2380
  0007f	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00082	85 c9		 test	 ecx, ecx
  00084	0f 84 9c 01 00
	00		 je	 $L2380

; 383  : 	/* Flush the last buffer: */
; 384  : 	err = deflate(strm, Z_PARTIAL_FLUSH);

  0008a	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0008d	85 c0		 test	 eax, eax
  0008f	0f 84 83 01 00
	00		 je	 $L2386
  00095	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00098	75 0b		 jne	 SHORT $L2387
  0009a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0009d	85 c0		 test	 eax, eax
  0009f	0f 85 73 01 00
	00		 jne	 $L2386
$L2387:
  000a5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a8	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  000ad	0f 84 65 01 00
	00		 je	 $L2386
  000b3	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  000b6	85 c9		 test	 ecx, ecx
  000b8	75 12		 jne	 SHORT $L2388
  000ba	a1 1c 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+28
  000bf	89 47 18	 mov	 DWORD PTR [edi+24], eax
  000c2	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  000c7	e9 5a 01 00 00	 jmp	 $L2380
$L2388:
  000cc	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  000cf	8b 5e 20	 mov	 ebx, DWORD PTR [esi+32]
  000d2	89 3e		 mov	 DWORD PTR [esi], edi
  000d4	c7 46 20 01 00
	00 00		 mov	 DWORD PTR [esi+32], 1
  000db	75 76		 jne	 SHORT $L2389
  000dd	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  000e0	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  000e3	83 e9 08	 sub	 ecx, 8
  000e6	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  000e9	81 c1 00 08 00
	00		 add	 ecx, 2048		; 00000800H
  000ef	48		 dec	 eax
  000f0	d1 f8		 sar	 eax, 1
  000f2	83 f8 03	 cmp	 eax, 3
  000f5	76 05		 jbe	 SHORT $L2392
  000f7	b8 03 00 00 00	 mov	 eax, 3
$L2392:
  000fc	c1 e0 06	 shl	 eax, 6
  000ff	0b c8		 or	 ecx, eax
  00101	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  00104	85 c0		 test	 eax, eax
  00106	74 03		 je	 SHORT $L2393
  00108	83 c9 20	 or	 ecx, 32			; 00000020H
$L2393:
  0010b	8b c1		 mov	 eax, ecx
  0010d	33 d2		 xor	 edx, edx
  0010f	bd 1f 00 00 00	 mov	 ebp, 31			; 0000001fH
  00114	f7 f5		 div	 ebp
  00116	8b c6		 mov	 eax, esi
  00118	c7 46 04 71 00
	00 00		 mov	 DWORD PTR [esi+4], 113	; 00000071H
  0011f	2b ca		 sub	 ecx, edx
  00121	03 cd		 add	 ecx, ebp
  00123	e8 00 00 00 00	 call	 @putShortMSB@8
  00128	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  0012b	85 c0		 test	 eax, eax
  0012d	74 19		 je	 SHORT $L2394
  0012f	0f b7 4f 32	 movzx	 ecx, WORD PTR [edi+50]
  00133	8b c6		 mov	 eax, esi
  00135	e8 00 00 00 00	 call	 @putShortMSB@8
  0013a	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  0013d	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00143	e8 00 00 00 00	 call	 @putShortMSB@8
$L2394:
  00148	8b 6c 24 14	 mov	 ebp, DWORD PTR tv305[esp+24]
  0014c	c7 47 30 01 00
	00 00		 mov	 DWORD PTR [edi+48], 1
$L2389:
  00153	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00156	85 c0		 test	 eax, eax
  00158	74 1c		 je	 SHORT $L2395
  0015a	8b c7		 mov	 eax, edi
  0015c	e8 00 00 00 00	 call	 @flush_pending@4
  00161	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00164	85 c0		 test	 eax, eax
  00166	75 2a		 jne	 SHORT $L2417
  00168	c7 46 20 ff ff
	ff ff		 mov	 DWORD PTR [esi+32], -1
  0016f	33 c0		 xor	 eax, eax
  00171	e9 b0 00 00 00	 jmp	 $L2380
$L2395:
  00176	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00179	85 c0		 test	 eax, eax
  0017b	75 15		 jne	 SHORT $L2417
  0017d	83 fb 01	 cmp	 ebx, 1
  00180	7c 10		 jl	 SHORT $L2417
  00182	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR _z_errmsg+28
  00188	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0018d	e9 91 00 00 00	 jmp	 $L2420
$L2417:
  00192	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00195	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  0019a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0019d	75 14		 jne	 SHORT $L2419
  0019f	85 c9		 test	 ecx, ecx
  001a1	74 14		 je	 SHORT $L2422
  001a3	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR _z_errmsg+28
  001a9	89 57 18	 mov	 DWORD PTR [edi+24], edx
  001ac	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  001b1	eb 73		 jmp	 SHORT $L2380
$L2419:
  001b3	85 c9		 test	 ecx, ecx
  001b5	75 0e		 jne	 SHORT $L2401
$L2422:
  001b7	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  001ba	85 c9		 test	 ecx, ecx
  001bc	75 07		 jne	 SHORT $L2401
  001be	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  001c3	74 4f		 je	 SHORT $L2418
$L2401:
  001c5	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  001c8	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  001cb	ba 01 00 00 00	 mov	 edx, 1
  001d0	8b ce		 mov	 ecx, esi
  001d2	ff 14 85 08 00
	00 00		 call	 DWORD PTR _configuration_table[eax*4+8]
  001d9	83 f8 02	 cmp	 eax, 2
  001dc	74 05		 je	 SHORT $L2404
  001de	83 f8 03	 cmp	 eax, 3
  001e1	75 07		 jne	 SHORT $L2403
$L2404:
  001e3	c7 46 04 9a 02
	00 00		 mov	 DWORD PTR [esi+4], 666	; 0000029aH
$L2403:
  001ea	85 c0		 test	 eax, eax
  001ec	74 18		 je	 SHORT $L2406
  001ee	83 f8 02	 cmp	 eax, 2
  001f1	74 13		 je	 SHORT $L2406
  001f3	83 f8 01	 cmp	 eax, 1
  001f6	75 1c		 jne	 SHORT $L2418
  001f8	8b ce		 mov	 ecx, esi
  001fa	e8 00 00 00 00	 call	 @_tr_align@4
  001ff	8b c7		 mov	 eax, edi
  00201	e8 00 00 00 00	 call	 @flush_pending@4
$L2406:
  00206	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00209	85 c0		 test	 eax, eax
  0020b	75 07		 jne	 SHORT $L2418
  0020d	c7 46 20 ff ff
	ff ff		 mov	 DWORD PTR [esi+32], -1
$L2418:
  00214	33 c0		 xor	 eax, eax
  00216	eb 0e		 jmp	 SHORT $L2380
$L2386:
  00218	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _z_errmsg+16
  0021e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
$L2420:
  00223	89 4f 18	 mov	 DWORD PTR [edi+24], ecx
$L2380:

; 385  :     }
; 386  :     if (s->level != level) {

  00226	8b 4c 24 10	 mov	 ecx, DWORD PTR _level$[esp+24]
  0022a	39 4e 7c	 cmp	 DWORD PTR [esi+124], ecx
  0022d	74 31		 je	 SHORT $L1914

; 387  : 	s->level = level;

  0022f	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx

; 388  : 	s->max_lazy_match   = configuration_table[level].max_lazy;

  00232	0f b7 95 02 00
	00 00		 movzx	 edx, WORD PTR _configuration_table[ebp+2]
  00239	89 56 78	 mov	 DWORD PTR [esi+120], edx

; 389  : 	s->good_match       = configuration_table[level].good_length;

  0023c	0f b7 8d 00 00
	00 00		 movzx	 ecx, WORD PTR _configuration_table[ebp]
  00243	89 8e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ecx

; 390  : 	s->nice_match       = configuration_table[level].nice_length;

  00249	0f b7 95 04 00
	00 00		 movzx	 edx, WORD PTR _configuration_table[ebp+4]
  00250	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx

; 391  : 	s->max_chain_length = configuration_table[level].max_chain;

  00256	0f b7 8d 06 00
	00 00		 movzx	 ecx, WORD PTR _configuration_table[ebp+6]
  0025d	89 4e 74	 mov	 DWORD PTR [esi+116], ecx
$L1914:

; 392  :     }
; 393  :     s->strategy = strategy;

  00260	8b 54 24 1c	 mov	 edx, DWORD PTR _strategy$[esp+20]
  00264	5d		 pop	 ebp
  00265	5b		 pop	 ebx
  00266	5f		 pop	 edi
  00267	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  0026d	5e		 pop	 esi

; 394  :     return err;
; 395  : }

  0026e	83 c4 08	 add	 esp, 8
  00271	c2 04 00	 ret	 4
$L1909:
  00274	5f		 pop	 edi

; 370  : 
; 371  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00275	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0027a	5e		 pop	 esi

; 394  :     return err;
; 395  : }

  0027b	83 c4 08	 add	 esp, 8
  0027e	c2 04 00	 ret	 4
@deflateParams@12 ENDP
_TEXT	ENDS
PUBLIC	@deflateInit2_@32
EXTRN	@zcalloc@12:NEAR
EXTRN	@zcfree@8:NEAR
; Function compile flags: /Ogty
;	COMDAT @deflateInit2_@32
_TEXT	SEGMENT
_level$ = -4						; size = 4
_method$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_memLevel$ = 16						; size = 4
_strategy$ = 20						; size = 4
_version$ = 24						; size = 4
_stream_size$ = 28					; size = 4
@deflateInit2_@32 PROC NEAR				; COMDAT
; _strm$ = ecx
; _level$ = edx

; 212  : {

  00000	51		 push	 ecx

; 213  :     deflate_state *s;
; 214  :     int noheader = 0;
; 215  :     static const char* my_version = ZLIB_VERSION;
; 216  : 
; 217  :     ushf *overlay;
; 218  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 219  :      * output size for (length,distance) codes is <= 24 bits.
; 220  :      */
; 221  : 
; 222  :     if (version == Z_NULL || version[0] != my_version[0] ||
; 223  :         stream_size != sizeof(z_stream)) {

  00001	8b 44 24 18	 mov	 eax, DWORD PTR _version$[esp]
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	33 c9		 xor	 ecx, ecx
  0000d	33 ed		 xor	 ebp, ebp
  0000f	3b c1		 cmp	 eax, ecx
  00011	89 54 24 10	 mov	 DWORD PTR _level$[esp+20], edx
  00015	0f 84 ea 01 00
	00		 je	 $L1843
  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?my_version@?1??deflateInit2_@@9@9
  00021	8a 00		 mov	 al, BYTE PTR [eax]
  00023	3a 06		 cmp	 al, BYTE PTR [esi]
  00025	0f 85 da 01 00
	00		 jne	 $L1843
  0002b	83 7c 24 2c 38	 cmp	 DWORD PTR _stream_size$[esp+16], 56 ; 00000038H
  00030	0f 85 cf 01 00
	00		 jne	 $L1843

; 225  :     }
; 226  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00036	3b f9		 cmp	 edi, ecx
  00038	0f 84 ba 01 00
	00		 je	 $L1851

; 227  : 
; 228  :     strm->msg = Z_NULL;
; 229  :     if (strm->zalloc == Z_NULL) {

  0003e	39 4f 20	 cmp	 DWORD PTR [edi+32], ecx
  00041	89 4f 18	 mov	 DWORD PTR [edi+24], ecx
  00044	75 0a		 jne	 SHORT $L1845

; 230  : 	strm->zalloc = zcalloc;

  00046	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], OFFSET FLAT:@zcalloc@12

; 231  : 	strm->opaque = (voidpf)0;

  0004d	89 4f 28	 mov	 DWORD PTR [edi+40], ecx
$L1845:

; 232  :     }
; 233  :     if (strm->zfree == Z_NULL) strm->zfree = zcfree;

  00050	39 4f 24	 cmp	 DWORD PTR [edi+36], ecx
  00053	75 07		 jne	 SHORT $L1847
  00055	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], OFFSET FLAT:@zcfree@8
$L1847:

; 234  : 
; 235  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  0005c	83 fa ff	 cmp	 edx, -1
  0005f	75 0c		 jne	 SHORT $L1848
  00061	c7 44 24 10 06
	00 00 00	 mov	 DWORD PTR _level$[esp+20], 6
  00069	8b 54 24 10	 mov	 edx, DWORD PTR _level$[esp+20]
$L1848:

; 236  : #ifdef FASTEST
; 237  :     level = 1;
; 238  : #endif
; 239  : 
; 240  :     if (windowBits < 0) { /* undocumented feature: suppress zlib header */

  0006d	8b 5c 24 1c	 mov	 ebx, DWORD PTR _windowBits$[esp+16]
  00071	3b d9		 cmp	 ebx, ecx
  00073	7d 07		 jge	 SHORT $L2425

; 241  :         noheader = 1;

  00075	bd 01 00 00 00	 mov	 ebp, 1

; 242  :         windowBits = -windowBits;

  0007a	f7 db		 neg	 ebx
$L2425:

; 243  :     }
; 244  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 245  :         windowBits < 9 || windowBits > 15 || level < 0 || level > 9 ||
; 246  : 	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {

  0007c	8b 44 24 20	 mov	 eax, DWORD PTR _memLevel$[esp+16]
  00080	83 f8 01	 cmp	 eax, 1
  00083	0f 8c 6f 01 00
	00		 jl	 $L1851
  00089	83 f8 09	 cmp	 eax, 9
  0008c	0f 8f 66 01 00
	00		 jg	 $L1851
  00092	83 7c 24 18 08	 cmp	 DWORD PTR _method$[esp+16], 8
  00097	0f 85 5b 01 00
	00		 jne	 $L1851
  0009d	83 fb 09	 cmp	 ebx, 9
  000a0	0f 8c 52 01 00
	00		 jl	 $L1851
  000a6	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  000a9	0f 8f 49 01 00
	00		 jg	 $L1851
  000af	3b d1		 cmp	 edx, ecx
  000b1	0f 8c 41 01 00
	00		 jl	 $L1851
  000b7	83 fa 09	 cmp	 edx, 9
  000ba	0f 8f 38 01 00
	00		 jg	 $L1851
  000c0	8b 44 24 24	 mov	 eax, DWORD PTR _strategy$[esp+16]
  000c4	3b c1		 cmp	 eax, ecx
  000c6	0f 8c 2c 01 00
	00		 jl	 $L1851
  000cc	83 f8 02	 cmp	 eax, 2
  000cf	0f 8f 23 01 00
	00		 jg	 $L1851

; 248  :     }
; 249  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  000d5	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  000d8	68 b8 16 00 00	 push	 5816			; 000016b8H
  000dd	ba 01 00 00 00	 mov	 edx, 1
  000e2	ff 57 20	 call	 DWORD PTR [edi+32]
  000e5	8b f0		 mov	 esi, eax

; 250  :     if (s == Z_NULL) return Z_MEM_ERROR;

  000e7	85 f6		 test	 esi, esi
  000e9	0f 84 fc 00 00
	00		 je	 $L2426

; 251  :     strm->state = (struct internal_state FAR *)s;

  000ef	89 77 1c	 mov	 DWORD PTR [edi+28], esi

; 252  :     s->strm = strm;
; 253  : 
; 254  :     s->noheader = noheader;

  000f2	89 6e 18	 mov	 DWORD PTR [esi+24], ebp

; 255  :     s->w_bits = windowBits;
; 256  :     s->w_size = 1 << s->w_bits;

  000f5	8b cb		 mov	 ecx, ebx
  000f7	bd 01 00 00 00	 mov	 ebp, 1
  000fc	d3 e5		 shl	 ebp, cl
  000fe	89 5e 28	 mov	 DWORD PTR [esi+40], ebx

; 257  :     s->w_mask = s->w_size - 1;
; 258  : 
; 259  :     s->hash_bits = memLevel + 7;

  00101	8b 5c 24 20	 mov	 ebx, DWORD PTR _memLevel$[esp+16]

; 260  :     s->hash_size = 1 << s->hash_bits;

  00105	b8 01 00 00 00	 mov	 eax, 1
  0010a	8d 4d ff	 lea	 ecx, DWORD PTR [ebp-1]
  0010d	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00110	8d 4b 07	 lea	 ecx, DWORD PTR [ebx+7]
  00113	d3 e0		 shl	 eax, cl
  00115	89 4e 48	 mov	 DWORD PTR [esi+72], ecx

; 261  :     s->hash_mask = s->hash_size - 1;
; 262  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

  00118	83 c1 02	 add	 ecx, 2
  0011b	89 3e		 mov	 DWORD PTR [esi], edi
  0011d	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00120	48		 dec	 eax
  00121	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00124	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00129	f7 e1		 mul	 ecx
  0012b	d1 ea		 shr	 edx, 1
  0012d	89 56 50	 mov	 DWORD PTR [esi+80], edx
  00130	89 6e 24	 mov	 DWORD PTR [esi+36], ebp

; 263  : 
; 264  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  00133	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00136	6a 02		 push	 2
  00138	8b d5		 mov	 edx, ebp
  0013a	ff 57 20	 call	 DWORD PTR [edi+32]

; 265  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  0013d	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00140	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00143	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00146	6a 02		 push	 2
  00148	ff 57 20	 call	 DWORD PTR [edi+32]

; 266  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  0014b	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  0014e	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00151	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00154	6a 02		 push	 2
  00156	ff 57 20	 call	 DWORD PTR [edi+32]

; 267  : 
; 268  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  00159	8d 4b 06	 lea	 ecx, DWORD PTR [ebx+6]
  0015c	ba 01 00 00 00	 mov	 edx, 1
  00161	d3 e2		 shl	 edx, cl
  00163	89 46 3c	 mov	 DWORD PTR [esi+60], eax

; 269  : 
; 270  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  00166	6a 04		 push	 4
  00168	89 96 94 16 00
	00		 mov	 DWORD PTR [esi+5780], edx
  0016e	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00171	ff 57 20	 call	 DWORD PTR [edi+32]

; 271  :     s->pending_buf = (uchf *) overlay;
; 272  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  00174	8b 8e 94 16 00
	00		 mov	 ecx, DWORD PTR [esi+5780]
  0017a	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  00181	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 273  : 
; 274  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
; 275  :         s->pending_buf == Z_NULL) {

  00184	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00187	85 d2		 test	 edx, edx
  00189	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0018c	74 4e		 je	 SHORT $L1868
  0018e	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00191	85 d2		 test	 edx, edx
  00193	74 47		 je	 SHORT $L1868
  00195	8b 56 3c	 mov	 edx, DWORD PTR [esi+60]
  00198	85 d2		 test	 edx, edx
  0019a	74 40		 je	 SHORT $L1868
  0019c	85 c0		 test	 eax, eax
  0019e	74 3c		 je	 SHORT $L1868

; 279  :     }
; 280  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  001a0	8b d1		 mov	 edx, ecx
  001a2	d1 ea		 shr	 edx, 1
  001a4	8d 14 50	 lea	 edx, DWORD PTR [eax+edx*2]

; 281  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  001a7	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  001aa	03 c1		 add	 eax, ecx

; 282  : 
; 283  :     s->level = level;

  001ac	8b 4c 24 10	 mov	 ecx, DWORD PTR _level$[esp+20]
  001b0	89 96 9c 16 00
	00		 mov	 DWORD PTR [esi+5788], edx

; 284  :     s->strategy = strategy;

  001b6	8b 54 24 24	 mov	 edx, DWORD PTR _strategy$[esp+16]
  001ba	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx

; 285  :     s->method = (Byte)method;
; 286  : 
; 287  :     return deflateReset(strm);

  001bd	8b cf		 mov	 ecx, edi
  001bf	89 86 90 16 00
	00		 mov	 DWORD PTR [esi+5776], eax
  001c5	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  001cb	c6 46 1d 08	 mov	 BYTE PTR [esi+29], 8
  001cf	e8 00 00 00 00	 call	 @deflateReset@4
  001d4	5f		 pop	 edi
  001d5	5e		 pop	 esi
  001d6	5d		 pop	 ebp
  001d7	5b		 pop	 ebx

; 288  : }

  001d8	59		 pop	 ecx
  001d9	c2 18 00	 ret	 24			; 00000018H
$L1868:

; 276  :         strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);

  001dc	a1 18 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+24

; 277  :         deflateEnd (strm);

  001e1	8b cf		 mov	 ecx, edi
  001e3	89 47 18	 mov	 DWORD PTR [edi+24], eax
  001e6	e8 00 00 00 00	 call	 @deflateEnd@4
$L2426:
  001eb	5f		 pop	 edi
  001ec	5e		 pop	 esi
  001ed	5d		 pop	 ebp

; 278  :         return Z_MEM_ERROR;

  001ee	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  001f3	5b		 pop	 ebx

; 288  : }

  001f4	59		 pop	 ecx
  001f5	c2 18 00	 ret	 24			; 00000018H
$L1851:
  001f8	5f		 pop	 edi
  001f9	5e		 pop	 esi
  001fa	5d		 pop	 ebp

; 247  :         return Z_STREAM_ERROR;

  001fb	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00200	5b		 pop	 ebx

; 288  : }

  00201	59		 pop	 ecx
  00202	c2 18 00	 ret	 24			; 00000018H
$L1843:
  00205	5f		 pop	 edi
  00206	5e		 pop	 esi
  00207	5d		 pop	 ebp

; 224  : 	return Z_VERSION_ERROR;

  00208	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  0020d	5b		 pop	 ebx

; 288  : }

  0020e	59		 pop	 ecx
  0020f	c2 18 00	 ret	 24			; 00000018H
@deflateInit2_@32 ENDP
_TEXT	ENDS
PUBLIC	@deflateInit_@16
; Function compile flags: /Ogty
;	COMDAT @deflateInit_@16
_TEXT	SEGMENT
_version$ = 8						; size = 4
_stream_size$ = 12					; size = 4
@deflateInit_@16 PROC NEAR				; COMDAT
; _strm$ = ecx
; _level$ = edx

; 196  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
; 197  : 			 Z_DEFAULT_STRATEGY, version, stream_size);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _stream_size$[esp-4]
  00004	50		 push	 eax
  00005	8b 44 24 08	 mov	 eax, DWORD PTR _version$[esp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	6a 08		 push	 8
  0000e	6a 0f		 push	 15			; 0000000fH
  00010	6a 08		 push	 8
  00012	e8 00 00 00 00	 call	 @deflateInit2_@32

; 198  :     /* To do: ignore strm->next_in if we use it as window */
; 199  : }

  00017	c2 08 00	 ret	 8
@deflateInit_@16 ENDP
_TEXT	ENDS
END
