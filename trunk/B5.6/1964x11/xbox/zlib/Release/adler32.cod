; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\adler32.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT @adler32@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	@adler32@12
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\adler32.c
;	COMDAT @adler32@12
_TEXT	SEGMENT
_len$ = 8						; size = 4
@adler32@12 PROC NEAR					; COMDAT
; _adler$ = ecx
; _buf$ = edx

; 25   : {

  00000	56		 push	 esi

; 26   :     unsigned long s1 = adler & 0xffff;

  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi
  00004	8b fa		 mov	 edi, edx
  00006	81 e6 ff ff 00
	00		 and	 esi, 65535		; 0000ffffH

; 27   :     unsigned long s2 = (adler >> 16) & 0xffff;

  0000c	c1 e9 10	 shr	 ecx, 16			; 00000010H

; 28   :     int k;
; 29   : 
; 30   :     if (buf == Z_NULL) return 1L;

  0000f	85 ff		 test	 edi, edi
  00011	75 0a		 jne	 SHORT $L898
  00013	5f		 pop	 edi
  00014	b8 01 00 00 00	 mov	 eax, 1
  00019	5e		 pop	 esi

; 48   : }

  0001a	c2 04 00	 ret	 4
$L898:
  0001d	53		 push	 ebx

; 31   : 
; 32   :     while (len > 0) {

  0001e	8b 5c 24 10	 mov	 ebx, DWORD PTR _len$[esp+8]
  00022	85 db		 test	 ebx, ebx
  00024	0f 86 f4 00 00
	00		 jbe	 $L879
  0002a	55		 push	 ebp
  0002b	eb 03 8d 49 00	 npad	 5
$L878:

; 33   :         k = len < NMAX ? len : NMAX;

  00030	81 fb b0 15 00
	00		 cmp	 ebx, 5552		; 000015b0H
  00036	8b c3		 mov	 eax, ebx
  00038	72 05		 jb	 SHORT $L895
  0003a	b8 b0 15 00 00	 mov	 eax, 5552		; 000015b0H
$L895:

; 34   :         len -= k;

  0003f	2b d8		 sub	 ebx, eax

; 35   :         while (k >= 16) {

  00041	83 f8 10	 cmp	 eax, 16			; 00000010H
  00044	0f 8c 9f 00 00
	00		 jl	 $L882
  0004a	8b d0		 mov	 edx, eax
  0004c	c1 ea 04	 shr	 edx, 4
  0004f	8b ea		 mov	 ebp, edx
  00051	f7 dd		 neg	 ebp
  00053	c1 e5 04	 shl	 ebp, 4
  00056	03 c5		 add	 eax, ebp
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L881:

; 36   :             DO16(buf);

  00060	0f b6 2f	 movzx	 ebp, BYTE PTR [edi]
  00063	03 f5		 add	 esi, ebp
  00065	0f b6 6f 01	 movzx	 ebp, BYTE PTR [edi+1]
  00069	03 ce		 add	 ecx, esi
  0006b	03 f5		 add	 esi, ebp
  0006d	0f b6 6f 02	 movzx	 ebp, BYTE PTR [edi+2]
  00071	03 ce		 add	 ecx, esi
  00073	03 f5		 add	 esi, ebp
  00075	0f b6 6f 03	 movzx	 ebp, BYTE PTR [edi+3]
  00079	03 ce		 add	 ecx, esi
  0007b	03 f5		 add	 esi, ebp
  0007d	0f b6 6f 04	 movzx	 ebp, BYTE PTR [edi+4]
  00081	03 ce		 add	 ecx, esi
  00083	03 f5		 add	 esi, ebp
  00085	0f b6 6f 05	 movzx	 ebp, BYTE PTR [edi+5]
  00089	03 ce		 add	 ecx, esi
  0008b	03 f5		 add	 esi, ebp
  0008d	0f b6 6f 06	 movzx	 ebp, BYTE PTR [edi+6]
  00091	03 ce		 add	 ecx, esi
  00093	03 f5		 add	 esi, ebp
  00095	0f b6 6f 07	 movzx	 ebp, BYTE PTR [edi+7]
  00099	03 ce		 add	 ecx, esi
  0009b	03 f5		 add	 esi, ebp
  0009d	0f b6 6f 08	 movzx	 ebp, BYTE PTR [edi+8]
  000a1	03 ce		 add	 ecx, esi
  000a3	03 f5		 add	 esi, ebp
  000a5	0f b6 6f 09	 movzx	 ebp, BYTE PTR [edi+9]
  000a9	03 ce		 add	 ecx, esi
  000ab	03 f5		 add	 esi, ebp
  000ad	0f b6 6f 0a	 movzx	 ebp, BYTE PTR [edi+10]
  000b1	03 ce		 add	 ecx, esi
  000b3	03 f5		 add	 esi, ebp
  000b5	0f b6 6f 0b	 movzx	 ebp, BYTE PTR [edi+11]
  000b9	03 ce		 add	 ecx, esi
  000bb	03 f5		 add	 esi, ebp
  000bd	0f b6 6f 0c	 movzx	 ebp, BYTE PTR [edi+12]
  000c1	03 ce		 add	 ecx, esi
  000c3	03 f5		 add	 esi, ebp
  000c5	0f b6 6f 0d	 movzx	 ebp, BYTE PTR [edi+13]
  000c9	03 ce		 add	 ecx, esi
  000cb	03 f5		 add	 esi, ebp
  000cd	0f b6 6f 0e	 movzx	 ebp, BYTE PTR [edi+14]
  000d1	03 ce		 add	 ecx, esi
  000d3	03 f5		 add	 esi, ebp
  000d5	0f b6 6f 0f	 movzx	 ebp, BYTE PTR [edi+15]
  000d9	03 ce		 add	 ecx, esi
  000db	03 f5		 add	 esi, ebp
  000dd	03 ce		 add	 ecx, esi

; 37   : 	    buf += 16;

  000df	83 c7 10	 add	 edi, 16			; 00000010H
  000e2	4a		 dec	 edx
  000e3	0f 85 77 ff ff
	ff		 jne	 $L881
$L882:

; 38   :             k -= 16;
; 39   :         }
; 40   :         if (k != 0) do {

  000e9	85 c0		 test	 eax, eax
  000eb	74 0e		 je	 SHORT $L886
  000ed	8d 49 00	 npad	 3
$L884:

; 41   :             s1 += *buf++;

  000f0	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  000f3	03 f2		 add	 esi, edx
  000f5	47		 inc	 edi

; 42   : 	    s2 += s1;

  000f6	03 ce		 add	 ecx, esi

; 43   :         } while (--k);

  000f8	48		 dec	 eax
  000f9	75 f5		 jne	 SHORT $L884
$L886:

; 44   :         s1 %= BASE;

  000fb	8b c6		 mov	 eax, esi
  000fd	33 d2		 xor	 edx, edx
  000ff	be f1 ff 00 00	 mov	 esi, 65521		; 0000fff1H
  00104	f7 f6		 div	 esi

; 45   :         s2 %= BASE;

  00106	8b c1		 mov	 eax, ecx
  00108	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0010d	8b f2		 mov	 esi, edx
  0010f	33 d2		 xor	 edx, edx
  00111	f7 f1		 div	 ecx
  00113	85 db		 test	 ebx, ebx
  00115	8b ca		 mov	 ecx, edx
  00117	0f 87 13 ff ff
	ff		 ja	 $L878
  0011d	5d		 pop	 ebp
$L879:

; 46   :     }
; 47   :     return (s2 << 16) | s1;

  0011e	8b c1		 mov	 eax, ecx
  00120	5b		 pop	 ebx
  00121	c1 e0 10	 shl	 eax, 16			; 00000010H
  00124	5f		 pop	 edi
  00125	0b c6		 or	 eax, esi
  00127	5e		 pop	 esi

; 48   : }

  00128	c2 04 00	 ret	 4
@adler32@12 ENDP
_TEXT	ENDS
END
