; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\infutil.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT @inflate_flush@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_inflate_mask
_DATA	SEGMENT
_inflate_mask DD 00H
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
_DATA	ENDS
PUBLIC	@inflate_flush@12
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\infutil.c
;	COMDAT @inflate_flush@12
_TEXT	SEGMENT
_n$ = -12						; size = 4
_p$ = -8						; size = 4
_q$ = -4						; size = 4
_r$ = 8							; size = 4
@inflate_flush@12 PROC NEAR				; COMDAT
; _s$ = ecx
; _z$ = edx

; 27   : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b d9		 mov	 ebx, ecx

; 28   :   uInt n;
; 29   :   Bytef *p;
; 30   :   Bytef *q;
; 31   : 
; 32   :   /* local copies of source and destination pointers */
; 33   :   p = z->next_out;
; 34   :   q = s->read;
; 35   : 
; 36   :   /* compute number of bytes to copy as far as end of window */
; 37   :   n = (uInt)((q <= s->write ? s->write : s->end) - q);

  00008	8b 73 34	 mov	 esi, DWORD PTR [ebx+52]
  0000b	57		 push	 edi
  0000c	8b 7b 30	 mov	 edi, DWORD PTR [ebx+48]
  0000f	3b fe		 cmp	 edi, esi
  00011	8b ea		 mov	 ebp, edx
  00013	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  00016	89 44 24 14	 mov	 DWORD PTR _p$[esp+28], eax
  0001a	89 7c 24 18	 mov	 DWORD PTR _q$[esp+28], edi
  0001e	76 03		 jbe	 SHORT $L1784
  00020	8b 73 2c	 mov	 esi, DWORD PTR [ebx+44]
$L1784:

; 38   :   if (n > z->avail_out) n = z->avail_out;

  00023	8b 45 10	 mov	 eax, DWORD PTR [ebp+16]
  00026	2b f7		 sub	 esi, edi
  00028	3b f0		 cmp	 esi, eax
  0002a	89 74 24 10	 mov	 DWORD PTR _n$[esp+28], esi
  0002e	76 06		 jbe	 SHORT $L1767
  00030	89 44 24 10	 mov	 DWORD PTR _n$[esp+28], eax
  00034	8b f0		 mov	 esi, eax
$L1767:

; 39   :   if (n && r == Z_BUF_ERROR) r = Z_OK;

  00036	85 f6		 test	 esi, esi
  00038	74 0f		 je	 SHORT $L1787
  0003a	83 7c 24 20 fb	 cmp	 DWORD PTR _r$[esp+24], -5 ; fffffffbH
  0003f	75 08		 jne	 SHORT $L1787
  00041	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _r$[esp+24], 0
$L1787:

; 40   : 
; 41   :   /* update counters */
; 42   :   z->avail_out -= n;
; 43   :   z->total_out += n;

  00049	8b 55 14	 mov	 edx, DWORD PTR [ebp+20]
  0004c	2b c6		 sub	 eax, esi
  0004e	03 d6		 add	 edx, esi
  00050	89 45 10	 mov	 DWORD PTR [ebp+16], eax
  00053	89 55 14	 mov	 DWORD PTR [ebp+20], edx

; 44   : 
; 45   :   /* update check information */
; 46   :   if (s->checkfn != Z_NULL)

  00056	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00059	85 c0		 test	 eax, eax
  0005b	74 0e		 je	 SHORT $L1769

; 47   :     z->adler = s->check = (*s->checkfn)(s->check, q, n);

  0005d	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  00060	56		 push	 esi
  00061	8b d7		 mov	 edx, edi
  00063	ff d0		 call	 eax
  00065	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  00068	89 45 30	 mov	 DWORD PTR [ebp+48], eax
$L1769:

; 48   : 
; 49   :   /* copy as far as end of window */
; 50   :   zmemcpy(p, q, n);
; 51   :   p += n;
; 52   :   q += n;

  0006b	8b 44 24 18	 mov	 eax, DWORD PTR _q$[esp+28]
  0006f	8b ce		 mov	 ecx, esi
  00071	8b d1		 mov	 edx, ecx
  00073	c1 e9 02	 shr	 ecx, 2
  00076	8b f7		 mov	 esi, edi
  00078	8b 7c 24 14	 mov	 edi, DWORD PTR _p$[esp+28]
  0007c	f3 a5		 rep movsd
  0007e	8b ca		 mov	 ecx, edx
  00080	83 e1 03	 and	 ecx, 3
  00083	f3 a4		 rep movsb
  00085	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+28]
  00089	8b 7c 24 14	 mov	 edi, DWORD PTR _p$[esp+28]
  0008d	03 f9		 add	 edi, ecx
  0008f	03 c1		 add	 eax, ecx

; 53   : 
; 54   :   /* see if more to copy at beginning of window */
; 55   :   if (q == s->end)

  00091	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  00094	3b c1		 cmp	 eax, ecx
  00096	89 7c 24 14	 mov	 DWORD PTR _p$[esp+28], edi
  0009a	0f 85 88 00 00
	00		 jne	 $L1770

; 56   :   {
; 57   :     /* wrap pointers */
; 58   :     q = s->window;
; 59   :     if (s->write == s->end)

  000a0	39 4b 34	 cmp	 DWORD PTR [ebx+52], ecx
  000a3	8b 73 28	 mov	 esi, DWORD PTR [ebx+40]
  000a6	89 74 24 18	 mov	 DWORD PTR _q$[esp+28], esi
  000aa	75 03		 jne	 SHORT $L1771

; 60   :       s->write = s->window;

  000ac	89 73 34	 mov	 DWORD PTR [ebx+52], esi
$L1771:

; 61   : 
; 62   :     /* compute bytes to copy */
; 63   :     n = (uInt)(s->write - q);

  000af	8b 7b 34	 mov	 edi, DWORD PTR [ebx+52]

; 64   :     if (n > z->avail_out) n = z->avail_out;

  000b2	8b 45 10	 mov	 eax, DWORD PTR [ebp+16]
  000b5	2b fe		 sub	 edi, esi
  000b7	3b f8		 cmp	 edi, eax
  000b9	89 7c 24 10	 mov	 DWORD PTR _n$[esp+28], edi
  000bd	76 06		 jbe	 SHORT $L1773
  000bf	89 44 24 10	 mov	 DWORD PTR _n$[esp+28], eax
  000c3	8b f8		 mov	 edi, eax
$L1773:

; 65   :     if (n && r == Z_BUF_ERROR) r = Z_OK;

  000c5	85 ff		 test	 edi, edi
  000c7	74 0f		 je	 SHORT $L1774
  000c9	83 7c 24 20 fb	 cmp	 DWORD PTR _r$[esp+24], -5 ; fffffffbH
  000ce	75 08		 jne	 SHORT $L1774
  000d0	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _r$[esp+24], 0
$L1774:

; 66   : 
; 67   :     /* update counters */
; 68   :     z->avail_out -= n;
; 69   :     z->total_out += n;

  000d8	8b 55 14	 mov	 edx, DWORD PTR [ebp+20]
  000db	2b c7		 sub	 eax, edi
  000dd	03 d7		 add	 edx, edi
  000df	89 45 10	 mov	 DWORD PTR [ebp+16], eax
  000e2	89 55 14	 mov	 DWORD PTR [ebp+20], edx

; 70   : 
; 71   :     /* update check information */
; 72   :     if (s->checkfn != Z_NULL)

  000e5	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  000e8	85 c0		 test	 eax, eax
  000ea	74 0e		 je	 SHORT $L1775

; 73   :       z->adler = s->check = (*s->checkfn)(s->check, q, n);

  000ec	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  000ef	57		 push	 edi
  000f0	8b d6		 mov	 edx, esi
  000f2	ff d0		 call	 eax
  000f4	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  000f7	89 45 30	 mov	 DWORD PTR [ebp+48], eax
$L1775:

; 74   : 
; 75   :     /* copy */
; 76   :     zmemcpy(p, q, n);
; 77   :     p += n;

  000fa	8b 54 24 14	 mov	 edx, DWORD PTR _p$[esp+28]
  000fe	8b cf		 mov	 ecx, edi
  00100	8b 7c 24 14	 mov	 edi, DWORD PTR _p$[esp+28]
  00104	8b c1		 mov	 eax, ecx
  00106	c1 e9 02	 shr	 ecx, 2
  00109	f3 a5		 rep movsd
  0010b	8b c8		 mov	 ecx, eax
  0010d	8b 44 24 10	 mov	 eax, DWORD PTR _n$[esp+28]
  00111	83 e1 03	 and	 ecx, 3
  00114	f3 a4		 rep movsb

; 78   :     q += n;

  00116	8b 4c 24 18	 mov	 ecx, DWORD PTR _q$[esp+28]
  0011a	03 d0		 add	 edx, eax
  0011c	03 c8		 add	 ecx, eax
  0011e	89 54 24 14	 mov	 DWORD PTR _p$[esp+28], edx
  00122	89 4c 24 18	 mov	 DWORD PTR _q$[esp+28], ecx
  00126	8b c1		 mov	 eax, ecx
$L1770:

; 79   :   }
; 80   : 
; 81   :   /* update pointers */
; 82   :   z->next_out = p;

  00128	8b 4c 24 14	 mov	 ecx, DWORD PTR _p$[esp+28]
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	89 4d 0c	 mov	 DWORD PTR [ebp+12], ecx

; 83   :   s->read = q;

  00131	89 43 30	 mov	 DWORD PTR [ebx+48], eax

; 84   : 
; 85   :   /* done */
; 86   :   return r;

  00134	8b 44 24 18	 mov	 eax, DWORD PTR _r$[esp+16]
  00138	5d		 pop	 ebp
  00139	5b		 pop	 ebx

; 87   : }

  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013d	c2 04 00	 ret	 4
@inflate_flush@12 ENDP
_TEXT	ENDS
END
