; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\gzio.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_05DOIEBMOI@1?41?44?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT @gz_open@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzopen@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzdopen@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzsetparams@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @get_byte@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @check_header@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @destroy@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzread@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzgetc@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzgets@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzwrite@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _gzprintf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzputc@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzputs@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @do_flush@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzflush@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzseek@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzrewind@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gztell@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzeof@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @putLong@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @getLong@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzclose@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gzerror@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_gz_magic DD	01fH
	DD	08bH
_DATA	ENDS
PUBLIC	@gzsetparams@12
EXTRN	@deflateParams@12:NEAR
EXTRN	_fwrite:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\gzio.c
;	COMDAT @gzsetparams@12
_TEXT	SEGMENT
_strategy$ = 8						; size = 4
@gzsetparams@12 PROC NEAR				; COMDAT
; _file$ = ecx
; _level$ = edx

; 213  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 214  :     gz_stream *s = (gz_stream*)file;
; 215  : 
; 216  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  00003	85 f6		 test	 esi, esi
  00005	57		 push	 edi
  00006	8b fa		 mov	 edi, edx
  00008	74 4f		 je	 SHORT $L2119
  0000a	80 7e 5c 77	 cmp	 BYTE PTR [esi+92], 119	; 00000077H
  0000e	75 49		 jne	 SHORT $L2119

; 217  : 
; 218  :     /* Make room to allow flushing */
; 219  :     if (s->stream.avail_out == 0) {

  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	85 c0		 test	 eax, eax
  00015	75 2f		 jne	 SHORT $L2120

; 220  : 
; 221  : 	s->stream.next_out = s->outbuf;
; 222  : 	if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {

  00017	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0001a	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  0001d	51		 push	 ecx
  0001e	68 00 40 00 00	 push	 16384			; 00004000H
  00023	6a 01		 push	 1
  00025	50		 push	 eax
  00026	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00029	e8 00 00 00 00	 call	 _fwrite
  0002e	83 c4 10	 add	 esp, 16			; 00000010H
  00031	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00036	74 07		 je	 SHORT $L2121

; 223  : 	    s->z_err = Z_ERRNO;

  00038	c7 46 38 ff ff
	ff ff		 mov	 DWORD PTR [esi+56], -1
$L2121:

; 224  : 	}
; 225  : 	s->stream.avail_out = Z_BUFSIZE;

  0003f	c7 46 10 00 40
	00 00		 mov	 DWORD PTR [esi+16], 16384 ; 00004000H
$L2120:

; 226  :     }
; 227  : 
; 228  :     return deflateParams (&(s->stream), level, strategy);

  00046	8b 54 24 0c	 mov	 edx, DWORD PTR _strategy$[esp+4]
  0004a	52		 push	 edx
  0004b	8b d7		 mov	 edx, edi
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 @deflateParams@12
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 229  : }

  00056	c2 04 00	 ret	 4
$L2119:
  00059	5f		 pop	 edi

; 214  :     gz_stream *s = (gz_stream*)file;
; 215  : 
; 216  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  0005a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0005f	5e		 pop	 esi

; 229  : }

  00060	c2 04 00	 ret	 4
@gzsetparams@12 ENDP
_TEXT	ENDS
EXTRN	__errno:NEAR
EXTRN	_fread:NEAR
; Function compile flags: /Ogty
;	COMDAT @get_byte@4
_TEXT	SEGMENT
@get_byte@4 PROC NEAR					; COMDAT
; _s$ = esi

; 239  :     if (s->z_eof) return EOF;

  00000	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00003	85 c0		 test	 eax, eax
  00005	74 04		 je	 SHORT $L2125
  00007	83 c8 ff	 or	 eax, -1

; 252  : }

  0000a	c3		 ret	 0
$L2125:

; 240  :     if (s->stream.avail_in == 0) {

  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000e	85 c0		 test	 eax, eax
  00010	75 47		 jne	 SHORT $L2126

; 241  : 	errno = 0;

  00012	e8 00 00 00 00	 call	 __errno
  00017	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 242  : 	s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);

  0001d	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00020	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00023	50		 push	 eax
  00024	68 00 40 00 00	 push	 16384			; 00004000H
  00029	6a 01		 push	 1
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 _fread
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 243  : 	if (s->stream.avail_in == 0) {

  00034	85 c0		 test	 eax, eax
  00036	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00039	75 19		 jne	 SHORT $L2127

; 244  : 	    s->z_eof = 1;
; 245  : 	    if (ferror(s->file)) s->z_err = Z_ERRNO;

  0003b	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  0003e	c7 46 3c 01 00
	00 00		 mov	 DWORD PTR [esi+60], 1
  00045	8a 4a 0c	 mov	 cl, BYTE PTR [edx+12]
  00048	83 c8 ff	 or	 eax, -1
  0004b	f6 c1 20	 test	 cl, 32			; 00000020H
  0004e	74 16		 je	 SHORT $L2124
  00050	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 252  : }

  00053	c3		 ret	 0
$L2127:

; 246  : 	    return EOF;
; 247  : 	}
; 248  : 	s->stream.next_in = s->inbuf;

  00054	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00057	89 06		 mov	 DWORD PTR [esi], eax
$L2126:

; 249  :     }
; 250  :     s->stream.avail_in--;

  00059	ff 4e 04	 dec	 DWORD PTR [esi+4]

; 251  :     return *(s->stream.next_in)++;

  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	8a 08		 mov	 cl, BYTE PTR [eax]
  00060	40		 inc	 eax
  00061	89 06		 mov	 DWORD PTR [esi], eax
  00063	0f b6 c1	 movzx	 eax, cl
$L2124:

; 252  : }

  00066	c3		 ret	 0
@get_byte@4 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @check_header@4
_TEXT	SEGMENT
@check_header@4 PROC NEAR				; COMDAT
; _s$ = eax

; 265  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 266  :     int method; /* method byte */
; 267  :     int flags;  /* flags byte */
; 268  :     uInt len;
; 269  :     int c;
; 270  : 
; 271  :     /* Check the gzip magic header */
; 272  :     for (len = 0; len < 2; len++) {

  00004	33 ff		 xor	 edi, edi
  00006	8b f0		 mov	 esi, eax
  00008	83 cb ff	 or	 ebx, -1
  0000b	bd 01 00 00 00	 mov	 ebp, 1
$L2563:

; 273  : 	c = get_byte(s);

  00010	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00013	85 c0		 test	 eax, eax
  00015	74 04		 je	 SHORT $L2489
  00017	8b c3		 mov	 eax, ebx
  00019	eb 54		 jmp	 SHORT $L2488
$L2489:
  0001b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001e	85 c0		 test	 eax, eax
  00020	75 40		 jne	 SHORT $L2490
  00022	e8 00 00 00 00	 call	 __errno
  00027	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002d	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00030	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00033	50		 push	 eax
  00034	68 00 40 00 00	 push	 16384			; 00004000H
  00039	55		 push	 ebp
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _fread
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	85 c0		 test	 eax, eax
  00045	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00048	75 13		 jne	 SHORT $L2491
  0004a	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  0004d	89 6e 3c	 mov	 DWORD PTR [esi+60], ebp
  00050	f6 42 0c 20	 test	 BYTE PTR [edx+12], 32	; 00000020H
  00054	74 03		 je	 SHORT $L2492
  00056	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
$L2492:
  00059	8b c3		 mov	 eax, ebx
  0005b	eb 12		 jmp	 SHORT $L2488
$L2491:
  0005d	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00060	89 06		 mov	 DWORD PTR [esi], eax
$L2490:
  00062	ff 4e 04	 dec	 DWORD PTR [esi+4]
  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	8a 08		 mov	 cl, BYTE PTR [eax]
  00069	40		 inc	 eax
  0006a	89 06		 mov	 DWORD PTR [esi], eax
  0006c	0f b6 c1	 movzx	 eax, cl
$L2488:

; 274  : 	if (c != gz_magic[len]) {

  0006f	3b 04 bd 00 00
	00 00		 cmp	 eax, DWORD PTR _gz_magic[edi*4]
  00076	75 14		 jne	 SHORT $L2550
  00078	47		 inc	 edi
  00079	83 ff 02	 cmp	 edi, 2
  0007c	72 92		 jb	 SHORT $L2563

; 281  : 	    return;
; 282  : 	}
; 283  :     }
; 284  :     method = get_byte(s);

  0007e	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00081	85 c0		 test	 eax, eax
  00083	74 3c		 je	 SHORT $L2496
  00085	8b fb		 mov	 edi, ebx
  00087	e9 89 00 00 00	 jmp	 $L2495
$L2550:

; 275  : 	    if (len != 0) s->stream.avail_in++, s->stream.next_in--;

  0008c	85 ff		 test	 edi, edi
  0008e	74 0c		 je	 SHORT $L2140
  00090	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00093	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00095	42		 inc	 edx
  00096	49		 dec	 ecx
  00097	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0009a	89 0e		 mov	 DWORD PTR [esi], ecx
$L2140:

; 276  : 	    if (c != EOF) {

  0009c	3b c3		 cmp	 eax, ebx
  0009e	74 0f		 je	 SHORT $L2141

; 277  : 		s->stream.avail_in++, s->stream.next_in--;

  000a0	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000a3	8b 06		 mov	 eax, DWORD PTR [esi]
  000a5	41		 inc	 ecx
  000a6	48		 dec	 eax
  000a7	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  000aa	89 06		 mov	 DWORD PTR [esi], eax

; 278  : 		s->transparent = 1;

  000ac	89 6e 58	 mov	 DWORD PTR [esi+88], ebp
$L2141:

; 279  : 	    }
; 280  : 	    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;

  000af	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b2	33 c9		 xor	 ecx, ecx
  000b4	85 c0		 test	 eax, eax
  000b6	0f 94 c1	 sete	 cl
  000b9	5f		 pop	 edi
  000ba	89 4e 38	 mov	 DWORD PTR [esi+56], ecx
  000bd	5e		 pop	 esi
  000be	5d		 pop	 ebp
  000bf	5b		 pop	 ebx

; 310  : }

  000c0	c3		 ret	 0

; 281  : 	    return;
; 282  : 	}
; 283  :     }
; 284  :     method = get_byte(s);

$L2496:
  000c1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c4	85 c0		 test	 eax, eax
  000c6	75 40		 jne	 SHORT $L2497
  000c8	e8 00 00 00 00	 call	 __errno
  000cd	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000d3	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  000d6	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  000d9	52		 push	 edx
  000da	68 00 40 00 00	 push	 16384			; 00004000H
  000df	55		 push	 ebp
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _fread
  000e6	83 c4 10	 add	 esp, 16			; 00000010H
  000e9	85 c0		 test	 eax, eax
  000eb	89 46 04	 mov	 DWORD PTR [esi+4], eax
  000ee	75 13		 jne	 SHORT $L2498
  000f0	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  000f3	89 6e 3c	 mov	 DWORD PTR [esi+60], ebp
  000f6	f6 41 0c 20	 test	 BYTE PTR [ecx+12], 32	; 00000020H
  000fa	74 03		 je	 SHORT $L2499
  000fc	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
$L2499:
  000ff	8b fb		 mov	 edi, ebx
  00101	eb 12		 jmp	 SHORT $L2495
$L2498:
  00103	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00106	89 16		 mov	 DWORD PTR [esi], edx
$L2497:
  00108	ff 4e 04	 dec	 DWORD PTR [esi+4]
  0010b	8b 06		 mov	 eax, DWORD PTR [esi]
  0010d	8a 08		 mov	 cl, BYTE PTR [eax]
  0010f	40		 inc	 eax
  00110	89 06		 mov	 DWORD PTR [esi], eax
  00112	0f b6 f9	 movzx	 edi, cl
$L2495:

; 285  :     flags = get_byte(s);

  00115	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00118	85 c0		 test	 eax, eax
  0011a	74 05		 je	 SHORT $L2503
  0011c	83 cb ff	 or	 ebx, -1
  0011f	eb 55		 jmp	 SHORT $L2502
$L2503:
  00121	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00124	85 c0		 test	 eax, eax
  00126	75 41		 jne	 SHORT $L2504
  00128	e8 00 00 00 00	 call	 __errno
  0012d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00133	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00136	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00139	50		 push	 eax
  0013a	68 00 40 00 00	 push	 16384			; 00004000H
  0013f	55		 push	 ebp
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 _fread
  00146	83 c4 10	 add	 esp, 16			; 00000010H
  00149	85 c0		 test	 eax, eax
  0014b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0014e	75 14		 jne	 SHORT $L2505
  00150	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  00153	89 6e 3c	 mov	 DWORD PTR [esi+60], ebp
  00156	f6 42 0c 20	 test	 BYTE PTR [edx+12], 32	; 00000020H
  0015a	74 03		 je	 SHORT $L2506
  0015c	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
$L2506:
  0015f	83 cb ff	 or	 ebx, -1
  00162	eb 12		 jmp	 SHORT $L2502
$L2505:
  00164	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00167	89 06		 mov	 DWORD PTR [esi], eax
$L2504:
  00169	ff 4e 04	 dec	 DWORD PTR [esi+4]
  0016c	8b 06		 mov	 eax, DWORD PTR [esi]
  0016e	8a 08		 mov	 cl, BYTE PTR [eax]
  00170	40		 inc	 eax
  00171	89 06		 mov	 DWORD PTR [esi], eax
  00173	0f b6 d9	 movzx	 ebx, cl
$L2502:

; 286  :     if (method != Z_DEFLATED || (flags & RESERVED) != 0) {

  00176	83 ff 08	 cmp	 edi, 8
  00179	0f 85 4e 02 00
	00		 jne	 $L2143
  0017f	f6 c3 e0	 test	 bl, -32			; ffffffe0H
  00182	0f 85 45 02 00
	00		 jne	 $L2143

; 288  : 	return;
; 289  :     }
; 290  : 
; 291  :     /* Discard time, xflags and OS code: */
; 292  :     for (len = 0; len < 6; len++) (void)get_byte(s);

  00188	bf 06 00 00 00	 mov	 edi, 6
  0018d	8d 49 00	 npad	 3
$L2144:
  00190	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00193	85 c0		 test	 eax, eax
  00195	75 55		 jne	 SHORT $L2145
  00197	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0019a	85 c0		 test	 eax, eax
  0019c	75 42		 jne	 SHORT $L2511
  0019e	e8 00 00 00 00	 call	 __errno
  001a3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001a9	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  001ac	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  001af	51		 push	 ecx
  001b0	68 00 40 00 00	 push	 16384			; 00004000H
  001b5	55		 push	 ebp
  001b6	52		 push	 edx
  001b7	e8 00 00 00 00	 call	 _fread
  001bc	83 c4 10	 add	 esp, 16			; 00000010H
  001bf	85 c0		 test	 eax, eax
  001c1	89 46 04	 mov	 DWORD PTR [esi+4], eax
  001c4	75 15		 jne	 SHORT $L2512
  001c6	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  001c9	89 6e 3c	 mov	 DWORD PTR [esi+60], ebp
  001cc	f6 40 0c 20	 test	 BYTE PTR [eax+12], 32	; 00000020H
  001d0	74 1a		 je	 SHORT $L2145
  001d2	c7 46 38 ff ff
	ff ff		 mov	 DWORD PTR [esi+56], -1
  001d9	eb 11		 jmp	 SHORT $L2145
$L2512:
  001db	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  001de	89 0e		 mov	 DWORD PTR [esi], ecx
$L2511:
  001e0	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  001e3	8b 06		 mov	 eax, DWORD PTR [esi]
  001e5	49		 dec	 ecx
  001e6	40		 inc	 eax
  001e7	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  001ea	89 06		 mov	 DWORD PTR [esi], eax
$L2145:
  001ec	4f		 dec	 edi
  001ed	75 a1		 jne	 SHORT $L2144

; 293  : 
; 294  :     if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */

  001ef	f6 c3 04	 test	 bl, 4
  001f2	74 7e		 je	 SHORT $L2520

; 295  : 	len  =  (uInt)get_byte(s);

  001f4	e8 00 00 00 00	 call	 @get_byte@4
  001f9	8b f8		 mov	 edi, eax

; 296  : 	len += ((uInt)get_byte(s))<<8;

  001fb	e8 00 00 00 00	 call	 @get_byte@4
  00200	c1 e0 08	 shl	 eax, 8
  00203	03 f8		 add	 edi, eax
$L2152:

; 297  : 	/* len is garbage if EOF but the loop below will quit anyway */
; 298  : 	while (len-- != 0 && get_byte(s) != EOF) ;

  00205	8b d7		 mov	 edx, edi
  00207	4f		 dec	 edi
  00208	85 d2		 test	 edx, edx
  0020a	74 66		 je	 SHORT $L2520
  0020c	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0020f	85 c0		 test	 eax, eax
  00211	75 5f		 jne	 SHORT $L2520
  00213	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00216	85 c0		 test	 eax, eax
  00218	75 2d		 jne	 SHORT $L2518
  0021a	e8 00 00 00 00	 call	 __errno
  0021f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00225	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00228	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0022b	50		 push	 eax
  0022c	68 00 40 00 00	 push	 16384			; 00004000H
  00231	55		 push	 ebp
  00232	51		 push	 ecx
  00233	e8 00 00 00 00	 call	 _fread
  00238	83 c4 10	 add	 esp, 16			; 00000010H
  0023b	85 c0		 test	 eax, eax
  0023d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00240	74 1d		 je	 SHORT $L2557
  00242	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00245	89 16		 mov	 DWORD PTR [esi], edx
$L2518:
  00247	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0024a	8b 06		 mov	 eax, DWORD PTR [esi]
  0024c	4a		 dec	 edx
  0024d	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00250	8a 08		 mov	 cl, BYTE PTR [eax]
  00252	40		 inc	 eax
  00253	89 06		 mov	 DWORD PTR [esi], eax
  00255	0f b6 c1	 movzx	 eax, cl
  00258	83 f8 ff	 cmp	 eax, -1
  0025b	75 a8		 jne	 SHORT $L2152
  0025d	eb 13		 jmp	 SHORT $L2520
$L2557:
  0025f	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00262	89 6e 3c	 mov	 DWORD PTR [esi+60], ebp
  00265	f6 40 0c 20	 test	 BYTE PTR [eax+12], 32	; 00000020H
  00269	74 07		 je	 SHORT $L2520
  0026b	c7 46 38 ff ff
	ff ff		 mov	 DWORD PTR [esi+56], -1
$L2520:

; 299  :     }
; 300  :     if ((flags & ORIG_NAME) != 0) { /* skip the original file name */

  00272	f6 c3 08	 test	 bl, 8
  00275	74 6a		 je	 SHORT $L2562
$L2156:

; 301  : 	while ((c = get_byte(s)) != 0 && c != EOF) ;

  00277	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0027a	85 c0		 test	 eax, eax
  0027c	75 63		 jne	 SHORT $L2562
  0027e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00281	85 c0		 test	 eax, eax
  00283	75 2d		 jne	 SHORT $L2526
  00285	e8 00 00 00 00	 call	 __errno
  0028a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00290	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  00293	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00296	51		 push	 ecx
  00297	68 00 40 00 00	 push	 16384			; 00004000H
  0029c	55		 push	 ebp
  0029d	52		 push	 edx
  0029e	e8 00 00 00 00	 call	 _fread
  002a3	83 c4 10	 add	 esp, 16			; 00000010H
  002a6	85 c0		 test	 eax, eax
  002a8	89 46 04	 mov	 DWORD PTR [esi+4], eax
  002ab	74 21		 je	 SHORT $L2559
  002ad	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  002b0	89 06		 mov	 DWORD PTR [esi], eax
$L2526:
  002b2	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  002b5	8b 06		 mov	 eax, DWORD PTR [esi]
  002b7	4a		 dec	 edx
  002b8	89 56 04	 mov	 DWORD PTR [esi+4], edx
  002bb	8a 08		 mov	 cl, BYTE PTR [eax]
  002bd	40		 inc	 eax
  002be	89 06		 mov	 DWORD PTR [esi], eax
  002c0	0f b6 c1	 movzx	 eax, cl
  002c3	85 c0		 test	 eax, eax
  002c5	74 1a		 je	 SHORT $L2562
  002c7	83 f8 ff	 cmp	 eax, -1
  002ca	75 ab		 jne	 SHORT $L2156
  002cc	eb 13		 jmp	 SHORT $L2562
$L2559:
  002ce	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  002d1	89 6e 3c	 mov	 DWORD PTR [esi+60], ebp
  002d4	f6 41 0c 20	 test	 BYTE PTR [ecx+12], 32	; 00000020H
  002d8	74 07		 je	 SHORT $L2562
  002da	c7 46 38 ff ff
	ff ff		 mov	 DWORD PTR [esi+56], -1
$L2562:

; 302  :     }
; 303  :     if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */

  002e1	f6 c3 10	 test	 bl, 16			; 00000010H
  002e4	74 6a		 je	 SHORT $L2535
$L2160:

; 304  : 	while ((c = get_byte(s)) != 0 && c != EOF) ;

  002e6	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  002e9	85 c0		 test	 eax, eax
  002eb	75 63		 jne	 SHORT $L2535
  002ed	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002f0	85 c0		 test	 eax, eax
  002f2	75 2d		 jne	 SHORT $L2533
  002f4	e8 00 00 00 00	 call	 __errno
  002f9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002ff	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  00302	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00305	52		 push	 edx
  00306	68 00 40 00 00	 push	 16384			; 00004000H
  0030b	55		 push	 ebp
  0030c	50		 push	 eax
  0030d	e8 00 00 00 00	 call	 _fread
  00312	83 c4 10	 add	 esp, 16			; 00000010H
  00315	85 c0		 test	 eax, eax
  00317	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0031a	74 21		 je	 SHORT $L2561
  0031c	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0031f	89 0e		 mov	 DWORD PTR [esi], ecx
$L2533:
  00321	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00324	8b 06		 mov	 eax, DWORD PTR [esi]
  00326	4a		 dec	 edx
  00327	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0032a	8a 08		 mov	 cl, BYTE PTR [eax]
  0032c	40		 inc	 eax
  0032d	89 06		 mov	 DWORD PTR [esi], eax
  0032f	0f b6 c1	 movzx	 eax, cl
  00332	85 c0		 test	 eax, eax
  00334	74 1a		 je	 SHORT $L2535
  00336	83 f8 ff	 cmp	 eax, -1
  00339	75 ab		 jne	 SHORT $L2160
  0033b	eb 13		 jmp	 SHORT $L2535
$L2561:
  0033d	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  00340	89 6e 3c	 mov	 DWORD PTR [esi+60], ebp
  00343	f6 42 0c 20	 test	 BYTE PTR [edx+12], 32	; 00000020H
  00347	74 07		 je	 SHORT $L2535
  00349	c7 46 38 ff ff
	ff ff		 mov	 DWORD PTR [esi+56], -1
$L2535:

; 305  :     }
; 306  :     if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */

  00350	f6 c3 02	 test	 bl, 2
  00353	74 66		 je	 SHORT $L2165

; 307  : 	for (len = 0; len < 2; len++) (void)get_byte(s);

  00355	bf 02 00 00 00	 mov	 edi, 2
  0035a	83 cb ff	 or	 ebx, -1
  0035d	8d 49 00	 npad	 3
$L2163:
  00360	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00363	85 c0		 test	 eax, eax
  00365	75 51		 jne	 SHORT $L2164
  00367	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0036a	85 c0		 test	 eax, eax
  0036c	75 3e		 jne	 SHORT $L2540
  0036e	e8 00 00 00 00	 call	 __errno
  00373	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00379	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0037c	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0037f	50		 push	 eax
  00380	68 00 40 00 00	 push	 16384			; 00004000H
  00385	55		 push	 ebp
  00386	51		 push	 ecx
  00387	e8 00 00 00 00	 call	 _fread
  0038c	83 c4 10	 add	 esp, 16			; 00000010H
  0038f	85 c0		 test	 eax, eax
  00391	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00394	75 11		 jne	 SHORT $L2541
  00396	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  00399	89 6e 3c	 mov	 DWORD PTR [esi+60], ebp
  0039c	f6 42 0c 20	 test	 BYTE PTR [edx+12], 32	; 00000020H
  003a0	74 16		 je	 SHORT $L2164
  003a2	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  003a5	eb 11		 jmp	 SHORT $L2164
$L2541:
  003a7	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  003aa	89 06		 mov	 DWORD PTR [esi], eax
$L2540:
  003ac	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  003af	8b 06		 mov	 eax, DWORD PTR [esi]
  003b1	49		 dec	 ecx
  003b2	40		 inc	 eax
  003b3	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  003b6	89 06		 mov	 DWORD PTR [esi], eax
$L2164:
  003b8	4f		 dec	 edi
  003b9	75 a5		 jne	 SHORT $L2163
$L2165:

; 308  :     }
; 309  :     s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;

  003bb	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  003be	f7 d9		 neg	 ecx
  003c0	1b c9		 sbb	 ecx, ecx
  003c2	5f		 pop	 edi
  003c3	83 e1 fd	 and	 ecx, -3			; fffffffdH
  003c6	89 4e 38	 mov	 DWORD PTR [esi+56], ecx
  003c9	5e		 pop	 esi
  003ca	5d		 pop	 ebp
  003cb	5b		 pop	 ebx

; 310  : }

  003cc	c3		 ret	 0
$L2143:
  003cd	5f		 pop	 edi

; 287  : 	s->z_err = Z_DATA_ERROR;

  003ce	c7 46 38 fd ff
	ff ff		 mov	 DWORD PTR [esi+56], -3	; fffffffdH
  003d5	5e		 pop	 esi
  003d6	5d		 pop	 ebp
  003d7	5b		 pop	 ebx

; 310  : }

  003d8	c3		 ret	 0
@check_header@4 ENDP
_TEXT	ENDS
EXTRN	_free:NEAR
EXTRN	_fclose:NEAR
EXTRN	@deflateEnd@4:NEAR
EXTRN	@inflateEnd@4:NEAR
; Function compile flags: /Ogty
;	COMDAT @destroy@4
_TEXT	SEGMENT
@destroy@4 PROC NEAR					; COMDAT
; _s$ = esi

; 318  : {

  00000	57		 push	 edi

; 319  :     int err = Z_OK;

  00001	33 ff		 xor	 edi, edi

; 320  : 
; 321  :     if (!s) return Z_STREAM_ERROR;

  00003	85 f6		 test	 esi, esi
  00005	75 07		 jne	 SHORT $L2171
  00007	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0000c	5f		 pop	 edi

; 349  : }

  0000d	c3		 ret	 0
$L2171:

; 322  : 
; 323  :     TRYFREE(s->msg);

  0000e	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  00011	85 c0		 test	 eax, eax
  00013	74 09		 je	 SHORT $L2172
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _free
  0001b	83 c4 04	 add	 esp, 4
$L2172:

; 324  : 
; 325  :     if (s->stream.state != NULL) {

  0001e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00021	85 c0		 test	 eax, eax
  00023	74 1d		 je	 SHORT $L2177

; 326  : 	if (s->mode == 'w') {

  00025	8a 46 5c	 mov	 al, BYTE PTR [esi+92]
  00028	3c 77		 cmp	 al, 119			; 00000077H
  0002a	75 09		 jne	 SHORT $L2175

; 327  : #ifdef NO_DEFLATE
; 328  : 	    err = Z_STREAM_ERROR;
; 329  : #else
; 330  : 	    err = deflateEnd(&(s->stream));

  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 @deflateEnd@4

; 331  : #endif
; 332  : 	} else if (s->mode == 'r') {

  00033	eb 0b		 jmp	 SHORT $L2566
$L2175:
  00035	3c 72		 cmp	 al, 114			; 00000072H
  00037	75 09		 jne	 SHORT $L2177

; 333  : 	    err = inflateEnd(&(s->stream));

  00039	8b ce		 mov	 ecx, esi
  0003b	e8 00 00 00 00	 call	 @inflateEnd@4
$L2566:
  00040	8b f8		 mov	 edi, eax
$L2177:

; 334  : 	}
; 335  :     }
; 336  :     if (s->file != NULL && fclose(s->file)) {

  00042	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00045	85 c0		 test	 eax, eax
  00047	74 1a		 je	 SHORT $L2180
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _fclose
  0004f	83 c4 04	 add	 esp, 4
  00052	85 c0		 test	 eax, eax
  00054	74 0d		 je	 SHORT $L2180

; 337  : #ifdef ESPIPE
; 338  : 	if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */

  00056	e8 00 00 00 00	 call	 __errno
  0005b	83 38 1d	 cmp	 DWORD PTR [eax], 29	; 0000001dH
  0005e	74 03		 je	 SHORT $L2180

; 339  : #endif
; 340  : 	    err = Z_ERRNO;

  00060	83 cf ff	 or	 edi, -1
$L2180:

; 341  :     }
; 342  :     if (s->z_err < 0) err = s->z_err;

  00063	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00066	85 c0		 test	 eax, eax
  00068	7d 02		 jge	 SHORT $L2181
  0006a	8b f8		 mov	 edi, eax
$L2181:

; 343  : 
; 344  :     TRYFREE(s->inbuf);

  0006c	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0006f	85 c0		 test	 eax, eax
  00071	74 09		 je	 SHORT $L2182
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _free
  00079	83 c4 04	 add	 esp, 4
$L2182:

; 345  :     TRYFREE(s->outbuf);

  0007c	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  0007f	85 c0		 test	 eax, eax
  00081	74 09		 je	 SHORT $L2183
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _free
  00089	83 c4 04	 add	 esp, 4
$L2183:

; 346  :     TRYFREE(s->path);

  0008c	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0008f	85 c0		 test	 eax, eax
  00091	74 09		 je	 SHORT $L2184
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 _free
  00099	83 c4 04	 add	 esp, 4
$L2184:

; 347  :     TRYFREE(s);

  0009c	56		 push	 esi
  0009d	e8 00 00 00 00	 call	 _free
  000a2	83 c4 04	 add	 esp, 4

; 348  :     return err;

  000a5	8b c7		 mov	 eax, edi
  000a7	5f		 pop	 edi

; 349  : }

  000a8	c3		 ret	 0
@destroy@4 ENDP
_TEXT	ENDS
PUBLIC	@gzwrite@12
EXTRN	@crc32@12:NEAR
EXTRN	@deflate@8:NEAR
; Function compile flags: /Ogty
;	COMDAT @gzwrite@12
_TEXT	SEGMENT
_len$ = 8						; size = 4
@gzwrite@12 PROC NEAR					; COMDAT
; _file$ = ecx
; _buf$ = edx

; 490  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 491  :     gz_stream *s = (gz_stream*)file;
; 492  : 
; 493  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  00004	85 f6		 test	 esi, esi
  00006	8b da		 mov	 ebx, edx
  00008	74 7c		 je	 SHORT $L2255
  0000a	80 7e 5c 77	 cmp	 BYTE PTR [esi+92], 119	; 00000077H
  0000e	75 76		 jne	 SHORT $L2255
  00010	57		 push	 edi

; 494  : 
; 495  :     s->stream.next_in = (Bytef*)buf;
; 496  :     s->stream.avail_in = len;

  00011	8b 7c 24 10	 mov	 edi, DWORD PTR _len$[esp+8]

; 497  : 
; 498  :     while (s->stream.avail_in != 0) {

  00015	85 ff		 test	 edi, edi
  00017	89 1e		 mov	 DWORD PTR [esi], ebx
  00019	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0001c	74 4d		 je	 SHORT $L2571
  0001e	8b ff		 npad	 2
$L2258:

; 499  : 
; 500  :         if (s->stream.avail_out == 0) {

  00020	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00023	85 c0		 test	 eax, eax
  00025	75 24		 jne	 SHORT $L2260

; 501  : 
; 502  :             s->stream.next_out = s->outbuf;
; 503  :             if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {

  00027	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0002a	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  0002d	51		 push	 ecx
  0002e	68 00 40 00 00	 push	 16384			; 00004000H
  00033	6a 01		 push	 1
  00035	50		 push	 eax
  00036	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00039	e8 00 00 00 00	 call	 _fwrite
  0003e	83 c4 10	 add	 esp, 16			; 00000010H
  00041	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00046	75 1c		 jne	 SHORT $L2570

; 505  :                 break;
; 506  :             }
; 507  :             s->stream.avail_out = Z_BUFSIZE;

  00048	89 46 10	 mov	 DWORD PTR [esi+16], eax
$L2260:

; 508  :         }
; 509  :         s->z_err = deflate(&(s->stream), Z_NO_FLUSH);

  0004b	33 d2		 xor	 edx, edx
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 @deflate@8

; 510  :         if (s->z_err != Z_OK) break;

  00054	85 c0		 test	 eax, eax
  00056	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00059	75 10		 jne	 SHORT $L2571
  0005b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0005e	85 c0		 test	 eax, eax
  00060	75 be		 jne	 SHORT $L2258
  00062	eb 07		 jmp	 SHORT $L2571
$L2570:

; 504  :                 s->z_err = Z_ERRNO;

  00064	c7 46 38 ff ff
	ff ff		 mov	 DWORD PTR [esi+56], -1
$L2571:

; 511  :     }
; 512  :     s->crc = crc32(s->crc, (const Bytef *)buf, len);

  0006b	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  0006e	57		 push	 edi
  0006f	8b d3		 mov	 edx, ebx
  00071	e8 00 00 00 00	 call	 @crc32@12

; 513  : 
; 514  :     return (int)(len - s->stream.avail_in);

  00076	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00079	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  0007c	8b c7		 mov	 eax, edi
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	2b c1		 sub	 eax, ecx
  00082	5b		 pop	 ebx

; 515  : }

  00083	c2 04 00	 ret	 4
$L2255:
  00086	5e		 pop	 esi

; 491  :     gz_stream *s = (gz_stream*)file;
; 492  : 
; 493  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  00087	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0008c	5b		 pop	 ebx

; 515  : }

  0008d	c2 04 00	 ret	 4
@gzwrite@12 ENDP
_TEXT	ENDS
PUBLIC	_gzprintf
EXTRN	__chkstk:NEAR
EXTRN	_vsprintf:NEAR
; Function compile flags: /Ogty
;	COMDAT _gzprintf
_TEXT	SEGMENT
_buf$ = -4096						; size = 4096
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC NEAR					; COMDAT

; 526  : {

  00000	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00005	e8 00 00 00 00	 call	 __chkstk

; 527  :     char buf[Z_PRINTF_BUFSIZE];
; 528  :     va_list va;
; 529  :     int len;
; 530  : 
; 531  :     va_start(va, format);
; 532  : #ifdef HAS_vsnprintf
; 533  :     (void)vsnprintf(buf, sizeof(buf), format, va);
; 534  : #else
; 535  :     (void)vsprintf(buf, format, va);

  0000a	8b 8c 24 08 10
	00 00		 mov	 ecx, DWORD PTR _format$[esp+4092]
  00011	8d 84 24 0c 10
	00 00		 lea	 eax, DWORD PTR _format$[esp+4096]
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	8d 54 24 08	 lea	 edx, DWORD PTR _buf$[esp+4104]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 _vsprintf

; 536  : #endif
; 537  :     va_end(va);
; 538  :     len = strlen(buf); /* some *sprintf don't return the nb of bytes written */

  00024	8d 44 24 0c	 lea	 eax, DWORD PTR _buf$[esp+4108]
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0002e	8b ff		 npad	 2
$L2575:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $L2575
  00037	2b c2		 sub	 eax, edx

; 539  :     if (len <= 0) return 0;

  00039	85 c0		 test	 eax, eax
  0003b	7f 09		 jg	 SHORT $L2288
  0003d	33 c0		 xor	 eax, eax

; 542  : }

  0003f	81 c4 00 10 00
	00		 add	 esp, 4096		; 00001000H
  00045	c3		 ret	 0
$L2288:

; 540  : 
; 541  :     return gzwrite(file, buf, (unsigned)len);

  00046	8b 8c 24 04 10
	00 00		 mov	 ecx, DWORD PTR _file$[esp+4092]
  0004d	50		 push	 eax
  0004e	8d 54 24 04	 lea	 edx, DWORD PTR _buf$[esp+4100]
  00052	e8 00 00 00 00	 call	 @gzwrite@12

; 542  : }

  00057	81 c4 00 10 00
	00		 add	 esp, 4096		; 00001000H
  0005d	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
PUBLIC	@gzputc@8
; Function compile flags: /Ogty
;	COMDAT @gzputc@8
_TEXT	SEGMENT
_cc$ = -1						; size = 1
@gzputc@8 PROC NEAR					; COMDAT
; _file$ = ecx
; _c$ = edx

; 576  : {

  00000	51		 push	 ecx

; 577  :     unsigned char cc = (unsigned char) c; /* required for big endian systems */

  00001	88 54 24 03	 mov	 BYTE PTR _cc$[esp+4], dl

; 578  : 
; 579  :     return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;

  00005	6a 01		 push	 1
  00007	8d 54 24 07	 lea	 edx, DWORD PTR _cc$[esp+8]
  0000b	e8 00 00 00 00	 call	 @gzwrite@12
  00010	83 f8 01	 cmp	 eax, 1
  00013	75 07		 jne	 SHORT $L2579
  00015	0f b6 44 24 03	 movzx	 eax, BYTE PTR _cc$[esp+4]

; 580  : }

  0001a	59		 pop	 ecx
  0001b	c3		 ret	 0
$L2579:

; 578  : 
; 579  :     return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;

  0001c	83 c8 ff	 or	 eax, -1

; 580  : }

  0001f	59		 pop	 ecx
  00020	c3		 ret	 0
@gzputc@8 ENDP
_TEXT	ENDS
PUBLIC	@gzputs@8
; Function compile flags: /Ogty
;	COMDAT @gzputs@8
_TEXT	SEGMENT
@gzputs@8 PROC NEAR					; COMDAT
; _file$ = ecx
; _s$ = edx

; 591  : {

  00000	53		 push	 ebx

; 592  :     return gzwrite(file, (char*)s, (unsigned)strlen(s));

  00001	8b c2		 mov	 eax, edx
  00003	56		 push	 esi
  00004	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L2583:
  00007	8a 18		 mov	 bl, BYTE PTR [eax]
  00009	40		 inc	 eax
  0000a	84 db		 test	 bl, bl
  0000c	75 f9		 jne	 SHORT $L2583
  0000e	2b c6		 sub	 eax, esi
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 @gzwrite@12
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx

; 593  : }

  00018	c3		 ret	 0
@gzputs@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @do_flush@8
_TEXT	SEGMENT
_flush$ = 8						; size = 4
@do_flush@8 PROC NEAR					; COMDAT
; _file$ = eax

; 603  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f0		 mov	 esi, eax

; 604  :     uInt len;
; 605  :     int done = 0;

  00004	33 db		 xor	 ebx, ebx

; 606  :     gz_stream *s = (gz_stream*)file;
; 607  : 
; 608  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  00006	85 f6		 test	 esi, esi
  00008	0f 84 a0 00 00
	00		 je	 $L2313
  0000e	80 7e 5c 77	 cmp	 BYTE PTR [esi+92], 119	; 00000077H
  00012	0f 85 96 00 00
	00		 jne	 $L2313

; 609  : 
; 610  :     s->stream.avail_in = 0; /* should be zero already anyway */

  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	57		 push	 edi
  0001c	8d 64 24 00	 npad	 4
$L2315:

; 611  : 
; 612  :     for (;;) {
; 613  :         len = Z_BUFSIZE - s->stream.avail_out;

  00020	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00023	bf 00 40 00 00	 mov	 edi, 16384		; 00004000H
  00028	2b f8		 sub	 edi, eax

; 614  : 
; 615  :         if (len != 0) {

  0002a	74 24		 je	 SHORT $L2317

; 616  :             if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {

  0002c	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0002f	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00032	50		 push	 eax
  00033	57		 push	 edi
  00034	6a 01		 push	 1
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _fwrite
  0003c	83 c4 10	 add	 esp, 16			; 00000010H
  0003f	3b c7		 cmp	 eax, edi
  00041	75 5f		 jne	 SHORT $L2591

; 618  :                 return Z_ERRNO;
; 619  :             }
; 620  :             s->stream.next_out = s->outbuf;

  00043	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00046	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 621  :             s->stream.avail_out = Z_BUFSIZE;

  00049	c7 46 10 00 40
	00 00		 mov	 DWORD PTR [esi+16], 16384 ; 00004000H
$L2317:

; 622  :         }
; 623  :         if (done) break;

  00050	85 db		 test	 ebx, ebx
  00052	75 3c		 jne	 SHORT $L2592

; 624  :         s->z_err = deflate(&(s->stream), flush);

  00054	8b 54 24 10	 mov	 edx, DWORD PTR _flush$[esp+8]
  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 @deflate@8

; 625  : 
; 626  : 	/* Ignore the second of two consecutive flushes: */
; 627  : 	if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;

  0005f	85 ff		 test	 edi, edi
  00061	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00064	75 08		 jne	 SHORT $L2321
  00066	83 f8 fb	 cmp	 eax, -5			; fffffffbH
  00069	75 03		 jne	 SHORT $L2321
  0006b	89 7e 38	 mov	 DWORD PTR [esi+56], edi
$L2321:

; 628  : 
; 629  :         /* deflate has finished flushing only when it hasn't used up
; 630  :          * all the available space in the output buffer: 
; 631  :          */
; 632  :         done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);

  0006e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00071	85 c0		 test	 eax, eax
  00073	75 0a		 jne	 SHORT $L2594
  00075	83 7e 38 01	 cmp	 DWORD PTR [esi+56], 1
  00079	74 04		 je	 SHORT $L2594
  0007b	33 db		 xor	 ebx, ebx
  0007d	eb 05		 jmp	 SHORT $L2587
$L2594:
  0007f	bb 01 00 00 00	 mov	 ebx, 1
$L2587:

; 633  :  
; 634  :         if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;

  00084	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00087	85 c0		 test	 eax, eax
  00089	74 95		 je	 SHORT $L2315
  0008b	83 f8 01	 cmp	 eax, 1
  0008e	74 90		 je	 SHORT $L2315
$L2592:

; 635  :     }
; 636  :     return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;

  00090	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  00093	8b c6		 mov	 eax, esi
  00095	48		 dec	 eax
  00096	f7 d8		 neg	 eax
  00098	1b c0		 sbb	 eax, eax
  0009a	5f		 pop	 edi
  0009b	23 c6		 and	 eax, esi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx

; 637  : }

  0009f	c2 04 00	 ret	 4
$L2591:

; 617  :                 s->z_err = Z_ERRNO;

  000a2	83 c8 ff	 or	 eax, -1
  000a5	5f		 pop	 edi
  000a6	89 46 38	 mov	 DWORD PTR [esi+56], eax
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx

; 637  : }

  000ab	c2 04 00	 ret	 4
$L2313:
  000ae	5e		 pop	 esi

; 606  :     gz_stream *s = (gz_stream*)file;
; 607  : 
; 608  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  000af	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000b4	5b		 pop	 ebx

; 637  : }

  000b5	c2 04 00	 ret	 4
@do_flush@8 ENDP
_TEXT	ENDS
PUBLIC	@gzflush@8
EXTRN	_fflush:NEAR
; Function compile flags: /Ogty
;	COMDAT @gzflush@8
_TEXT	SEGMENT
@gzflush@8 PROC NEAR					; COMDAT
; _file$ = ecx
; _flush$ = edx

; 642  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 643  :     gz_stream *s = (gz_stream*)file;
; 644  :     int err = do_flush (file, flush);

  00003	52		 push	 edx
  00004	8b c6		 mov	 eax, esi
  00006	e8 00 00 00 00	 call	 @do_flush@8

; 645  : 
; 646  :     if (err) return err;

  0000b	85 c0		 test	 eax, eax
  0000d	75 18		 jne	 SHORT $L2326

; 647  :     fflush(s->file);

  0000f	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _fflush

; 648  :     return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;

  00018	8b 76 38	 mov	 esi, DWORD PTR [esi+56]
  0001b	83 c4 04	 add	 esp, 4
  0001e	8b c6		 mov	 eax, esi
  00020	48		 dec	 eax
  00021	f7 d8		 neg	 eax
  00023	1b c0		 sbb	 eax, eax
  00025	23 c6		 and	 eax, esi
$L2326:
  00027	5e		 pop	 esi

; 649  : }

  00028	c3		 ret	 0
@gzflush@8 ENDP
_TEXT	ENDS
PUBLIC	@gzrewind@4
EXTRN	@inflateReset@4:NEAR
EXTRN	_fseek:NEAR
EXTRN	_rewind:NEAR
; Function compile flags: /Ogty
;	COMDAT @gzrewind@4
_TEXT	SEGMENT
@gzrewind@4 PROC NEAR					; COMDAT
; _file$ = ecx

; 743  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 744  :     gz_stream *s = (gz_stream*)file;
; 745  :     
; 746  :     if (s == NULL || s->mode != 'r') return -1;

  00003	85 f6		 test	 esi, esi
  00005	74 60		 je	 SHORT $L2381
  00007	80 7e 5c 72	 cmp	 BYTE PTR [esi+92], 114	; 00000072H
  0000b	75 5a		 jne	 SHORT $L2381

; 747  : 
; 748  :     s->z_err = Z_OK;
; 749  :     s->z_eof = 0;
; 750  :     s->stream.avail_in = 0;
; 751  :     s->stream.next_in = s->inbuf;

  0000d	8b 46 44	 mov	 eax, DWORD PTR [esi+68]

; 752  :     s->crc = crc32(0L, Z_NULL, 0);

  00010	6a 00		 push	 0
  00012	33 d2		 xor	 edx, edx
  00014	33 c9		 xor	 ecx, ecx
  00016	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  0001d	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  00024	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0002b	89 06		 mov	 DWORD PTR [esi], eax
  0002d	e8 00 00 00 00	 call	 @crc32@12
  00032	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 753  : 	
; 754  :     if (s->startpos == 0) { /* not a compressed file */

  00035	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00038	85 c0		 test	 eax, eax
  0003a	75 10		 jne	 SHORT $L2382

; 755  : 	rewind(s->file);

  0003c	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _rewind
  00045	83 c4 04	 add	 esp, 4

; 756  : 	return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	5e		 pop	 esi

; 761  : }

  0004b	c3		 ret	 0
$L2382:

; 757  :     }
; 758  : 
; 759  :     (void) inflateReset(&s->stream);

  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 @inflateReset@4

; 760  :     return fseek(s->file, s->startpos, SEEK_SET);

  00053	8b 56 60	 mov	 edx, DWORD PTR [esi+96]
  00056	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00059	6a 00		 push	 0
  0005b	52		 push	 edx
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _fseek
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	5e		 pop	 esi

; 761  : }

  00066	c3		 ret	 0
$L2381:

; 744  :     gz_stream *s = (gz_stream*)file;
; 745  :     
; 746  :     if (s == NULL || s->mode != 'r') return -1;

  00067	83 c8 ff	 or	 eax, -1
  0006a	5e		 pop	 esi

; 761  : }

  0006b	c3		 ret	 0
@gzrewind@4 ENDP
_TEXT	ENDS
PUBLIC	@gzeof@4
; Function compile flags: /Ogty
;	COMDAT @gzeof@4
_TEXT	SEGMENT
@gzeof@4 PROC NEAR					; COMDAT
; _file$ = ecx

; 781  :     gz_stream *s = (gz_stream*)file;
; 782  :     
; 783  :     return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;

  00000	85 c9		 test	 ecx, ecx
  00002	74 0a		 je	 SHORT $L2604
  00004	80 79 5c 72	 cmp	 BYTE PTR [ecx+92], 114	; 00000072H
  00008	75 04		 jne	 SHORT $L2604
  0000a	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]

; 784  : }

  0000d	c3		 ret	 0
$L2604:

; 781  :     gz_stream *s = (gz_stream*)file;
; 782  :     
; 783  :     return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;

  0000e	33 c0		 xor	 eax, eax

; 784  : }

  00010	c3		 ret	 0
@gzeof@4 ENDP
_TEXT	ENDS
EXTRN	_fputc:NEAR
; Function compile flags: /Ogty
;	COMDAT @putLong@8
_TEXT	SEGMENT
@putLong@8 PROC NEAR					; COMDAT
; _file$ = ebx
; _x$ = eax

; 792  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f0		 mov	 esi, eax

; 793  :     int n;
; 794  :     for (n = 0; n < 4; n++) {

  00004	bf 04 00 00 00	 mov	 edi, 4
  00009	8d a4 24 00 00
	00 00		 npad	 7
$L2398:

; 795  :         fputc((int)(x & 0xff), file);

  00010	8b c6		 mov	 eax, esi
  00012	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00017	53		 push	 ebx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _fputc
  0001e	83 c4 08	 add	 esp, 8

; 796  :         x >>= 8;

  00021	c1 ee 08	 shr	 esi, 8
  00024	4f		 dec	 edi
  00025	75 e9		 jne	 SHORT $L2398
  00027	5f		 pop	 edi
  00028	5e		 pop	 esi

; 797  :     }
; 798  : }

  00029	c3		 ret	 0
@putLong@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @getLong@4
_TEXT	SEGMENT
@getLong@4 PROC NEAR					; COMDAT
; _s$ = eax

; 806  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f0		 mov	 esi, eax

; 807  :     uLong x = (uLong)get_byte(s);

  00004	e8 00 00 00 00	 call	 @get_byte@4
  00009	8b f8		 mov	 edi, eax

; 808  :     int c;
; 809  : 
; 810  :     x += ((uLong)get_byte(s))<<8;

  0000b	e8 00 00 00 00	 call	 @get_byte@4
  00010	c1 e0 08	 shl	 eax, 8
  00013	03 f8		 add	 edi, eax

; 811  :     x += ((uLong)get_byte(s))<<16;

  00015	e8 00 00 00 00	 call	 @get_byte@4
  0001a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0001d	03 f8		 add	 edi, eax

; 812  :     c = get_byte(s);

  0001f	e8 00 00 00 00	 call	 @get_byte@4

; 813  :     if (c == EOF) s->z_err = Z_DATA_ERROR;

  00024	83 f8 ff	 cmp	 eax, -1
  00027	75 07		 jne	 SHORT $L2410
  00029	c7 46 38 fd ff
	ff ff		 mov	 DWORD PTR [esi+56], -3	; fffffffdH
$L2410:

; 814  :     x += ((uLong)c)<<24;

  00030	c1 e0 18	 shl	 eax, 24			; 00000018H
  00033	03 c7		 add	 eax, edi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 815  :     return x;
; 816  : }

  00037	c3		 ret	 0
@getLong@4 ENDP
_TEXT	ENDS
PUBLIC	@gzclose@4
; Function compile flags: /Ogty
;	COMDAT @gzclose@4
_TEXT	SEGMENT
@gzclose@4 PROC NEAR					; COMDAT
; _file$ = ecx

; 824  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 825  :     int err;
; 826  :     gz_stream *s = (gz_stream*)file;
; 827  : 
; 828  :     if (s == NULL) return Z_STREAM_ERROR;

  00003	85 f6		 test	 esi, esi
  00005	75 07		 jne	 SHORT $L2419
  00007	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0000c	5e		 pop	 esi

; 842  : }

  0000d	c3		 ret	 0
$L2419:

; 829  : 
; 830  :     if (s->mode == 'w') {

  0000e	80 7e 5c 77	 cmp	 BYTE PTR [esi+92], 119	; 00000077H
  00012	75 25		 jne	 SHORT $L2420

; 831  : #ifdef NO_DEFLATE
; 832  : 	return Z_STREAM_ERROR;
; 833  : #else
; 834  :         err = do_flush (file, Z_FINISH);

  00014	6a 04		 push	 4
  00016	8b c6		 mov	 eax, esi
  00018	e8 00 00 00 00	 call	 @do_flush@8

; 835  :         if (err != Z_OK) return destroy((gz_stream*)file);

  0001d	85 c0		 test	 eax, eax
  0001f	75 18		 jne	 SHORT $L2420

; 836  : 
; 837  :         putLong (s->file, s->crc);

  00021	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00024	53		 push	 ebx
  00025	8b 5e 40	 mov	 ebx, DWORD PTR [esi+64]
  00028	e8 00 00 00 00	 call	 @putLong@8

; 838  :         putLong (s->file, s->stream.total_in);

  0002d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00030	8b 5e 40	 mov	 ebx, DWORD PTR [esi+64]
  00033	e8 00 00 00 00	 call	 @putLong@8
  00038	5b		 pop	 ebx
$L2420:

; 839  : #endif
; 840  :     }
; 841  :     return destroy((gz_stream*)file);

  00039	e8 00 00 00 00	 call	 @destroy@4
  0003e	5e		 pop	 esi

; 842  : }

  0003f	c3		 ret	 0
@gzclose@4 ENDP
_TEXT	ENDS
PUBLIC	@gzerror@8
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	_malloc:NEAR
EXTRN	_z_errmsg:BYTE
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @gzerror@8
_TEXT	SEGMENT
@gzerror@8 PROC NEAR					; COMDAT
; _file$ = ecx
; _errnum$ = edx

; 854  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 855  :     char *m;
; 856  :     gz_stream *s = (gz_stream*)file;
; 857  : 
; 858  :     if (s == NULL) {

  00003	85 db		 test	 ebx, ebx
  00005	75 0d		 jne	 SHORT $L2432

; 859  :         *errnum = Z_STREAM_ERROR;

  00007	c7 02 fe ff ff
	ff		 mov	 DWORD PTR [edx], -2	; fffffffeH

; 860  :         return (const char*)ERR_MSG(Z_STREAM_ERROR);

  0000d	a1 10 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+16
  00012	5b		 pop	 ebx

; 875  : }

  00013	c3		 ret	 0
$L2432:

; 861  :     }
; 862  :     *errnum = s->z_err;

  00014	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]

; 863  :     if (*errnum == Z_OK) return (const char*)"";

  00017	85 c0		 test	 eax, eax
  00019	89 02		 mov	 DWORD PTR [edx], eax
  0001b	75 07		 jne	 SHORT $L2434
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00022	5b		 pop	 ebx

; 875  : }

  00023	c3		 ret	 0
$L2434:

; 864  : 
; 865  :     m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);

  00024	83 f8 ff	 cmp	 eax, -1
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	74 0d		 je	 SHORT $L2440
  0002c	8b 6b 18	 mov	 ebp, DWORD PTR [ebx+24]

; 866  : 
; 867  :     if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);

  0002f	85 ed		 test	 ebp, ebp
  00031	74 06		 je	 SHORT $L2440
  00033	80 7d 00 00	 cmp	 BYTE PTR [ebp], 0
  00037	75 0f		 jne	 SHORT $L2439
$L2440:
  00039	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  0003c	c1 e0 02	 shl	 eax, 2
  0003f	b9 08 00 00 00	 mov	 ecx, OFFSET FLAT:_z_errmsg+8
  00044	2b c8		 sub	 ecx, eax
  00046	8b 29		 mov	 ebp, DWORD PTR [ecx]
$L2439:

; 868  : 
; 869  :     TRYFREE(s->msg);

  00048	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  0004b	85 c0		 test	 eax, eax
  0004d	74 09		 je	 SHORT $L2442
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _free
  00055	83 c4 04	 add	 esp, 4
$L2442:

; 870  :     s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);

  00058	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  0005b	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0005e	8b ff		 npad	 2
$L2621:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $L2621
  00067	2b c2		 sub	 eax, edx
  00069	8b d0		 mov	 edx, eax
  0006b	8b c5		 mov	 eax, ebp
  0006d	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$L2622:
  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	40		 inc	 eax
  00073	84 c9		 test	 cl, cl
  00075	75 f9		 jne	 SHORT $L2622
  00077	2b c6		 sub	 eax, esi
  00079	8d 54 10 03	 lea	 edx, DWORD PTR [eax+edx+3]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _malloc

; 871  :     strcpy(s->msg, s->path);

  00083	8b 4b 54	 mov	 ecx, DWORD PTR [ebx+84]
  00086	83 c4 04	 add	 esp, 4
  00089	89 43 50	 mov	 DWORD PTR [ebx+80], eax
  0008c	8b d0		 mov	 edx, eax
  0008e	8b ff		 npad	 2
$L2618:
  00090	8a 01		 mov	 al, BYTE PTR [ecx]
  00092	41		 inc	 ecx
  00093	88 02		 mov	 BYTE PTR [edx], al
  00095	42		 inc	 edx
  00096	84 c0		 test	 al, al
  00098	75 f6		 jne	 SHORT $L2618

; 872  :     strcat(s->msg, ": ");

  0009a	8b 7b 50	 mov	 edi, DWORD PTR [ebx+80]
  0009d	4f		 dec	 edi
  0009e	8b ff		 npad	 2
$L2623:
  000a0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000a3	47		 inc	 edi
  000a4	84 c0		 test	 al, al
  000a6	75 f8		 jne	 SHORT $L2623
  000a8	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02LMMGGCAJ@?3?5?$AA@
  000ae	66 89 07	 mov	 WORD PTR [edi], ax
  000b1	8a 0d 02 00 00
	00		 mov	 cl, BYTE PTR ??_C@_02LMMGGCAJ@?3?5?$AA@+2

; 873  :     strcat(s->msg, m);

  000b7	8b c5		 mov	 eax, ebp
  000b9	88 4f 02	 mov	 BYTE PTR [edi+2], cl
  000bc	8b f0		 mov	 esi, eax
  000be	8b ff		 npad	 2
$L2624:
  000c0	8a 08		 mov	 cl, BYTE PTR [eax]
  000c2	40		 inc	 eax
  000c3	84 c9		 test	 cl, cl
  000c5	75 f9		 jne	 SHORT $L2624
  000c7	8b 7b 50	 mov	 edi, DWORD PTR [ebx+80]
  000ca	2b c6		 sub	 eax, esi
  000cc	4f		 dec	 edi
  000cd	8d 49 00	 npad	 3
$L2625:
  000d0	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000d3	47		 inc	 edi
  000d4	84 c9		 test	 cl, cl
  000d6	75 f8		 jne	 SHORT $L2625
  000d8	8b c8		 mov	 ecx, eax
  000da	c1 e9 02	 shr	 ecx, 2
  000dd	f3 a5		 rep movsd
  000df	8b c8		 mov	 ecx, eax
  000e1	83 e1 03	 and	 ecx, 3
  000e4	f3 a4		 rep movsb

; 874  :     return (const char*)s->msg;

  000e6	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5d		 pop	 ebp
  000ec	5b		 pop	 ebx

; 875  : }

  000ed	c3		 ret	 0
@gzerror@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_05DOIEBMOI@1?41?44?$AA@			; `string'
PUBLIC	??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@ ; `string'
EXTRN	@deflateInit2_@32:NEAR
EXTRN	@inflateInit2_@16:NEAR
EXTRN	__fdopen:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fprintf:NEAR
EXTRN	_ftell:NEAR
;	COMDAT ??_C@_05DOIEBMOI@1?41?44?$AA@
CONST	SEGMENT
??_C@_05DOIEBMOI@1?41?44?$AA@ DB '1.1.4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@
CONST	SEGMENT
??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@ DB '%'
	DB	'c%c%c%c%c%c%c%c%c%c', 00H			; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @gz_open@12
_TEXT	SEGMENT
_m$ = -88						; size = 4
_strategy$ = -84					; size = 4
_fmode$ = -80						; size = 80
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
@gz_open@12 PROC NEAR					; COMDAT
; _mode$ = eax

; 77   : {

  00000	83 ec 58	 sub	 esp, 88			; 00000058H
  00003	53		 push	 ebx

; 78   :     int err;
; 79   :     int level = Z_DEFAULT_COMPRESSION; /* compression level */
; 80   :     int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
; 81   :     char *p = (char*)mode;
; 82   :     gz_stream *s;
; 83   :     char fmode[80]; /* copy of mode, without the compression level */
; 84   :     char *m = fmode;

  00004	8d 4c 24 0c	 lea	 ecx, DWORD PTR _fmode$[esp+92]
  00008	55		 push	 ebp
  00009	33 db		 xor	 ebx, ebx
  0000b	89 4c 24 08	 mov	 DWORD PTR _m$[esp+96], ecx

; 85   : 
; 86   :     if (!path || !mode) return Z_NULL;

  0000f	8b 4c 24 64	 mov	 ecx, DWORD PTR _path$[esp+92]
  00013	83 cd ff	 or	 ebp, -1
  00016	3b cb		 cmp	 ecx, ebx
  00018	57		 push	 edi
  00019	89 5c 24 10	 mov	 DWORD PTR _strategy$[esp+100], ebx
  0001d	8b f8		 mov	 edi, eax
  0001f	0f 84 0c 02 00
	00		 je	 $L2049
  00025	3b c3		 cmp	 eax, ebx
  00027	0f 84 04 02 00
	00		 je	 $L2049
  0002d	56		 push	 esi

; 87   : 
; 88   :     s = (gz_stream *)ALLOC(sizeof(gz_stream));

  0002e	6a 64		 push	 100			; 00000064H
  00030	e8 00 00 00 00	 call	 _malloc
  00035	8b f0		 mov	 esi, eax
  00037	83 c4 04	 add	 esp, 4

; 89   :     if (!s) return Z_NULL;

  0003a	3b f3		 cmp	 esi, ebx
  0003c	0f 84 18 01 00
	00		 je	 $L2637

; 90   : 
; 91   :     s->stream.zalloc = (alloc_func)0;
; 92   :     s->stream.zfree = (free_func)0;
; 93   :     s->stream.opaque = (voidpf)0;
; 94   :     s->stream.next_in = s->inbuf = Z_NULL;
; 95   :     s->stream.next_out = s->outbuf = Z_NULL;
; 96   :     s->stream.avail_in = s->stream.avail_out = 0;
; 97   :     s->file = NULL;
; 98   :     s->z_err = Z_OK;
; 99   :     s->z_eof = 0;
; 100  :     s->crc = crc32(0L, Z_NULL, 0);

  00042	53		 push	 ebx
  00043	33 d2		 xor	 edx, edx
  00045	33 c9		 xor	 ecx, ecx
  00047	89 5e 20	 mov	 DWORD PTR [esi+32], ebx
  0004a	89 5e 24	 mov	 DWORD PTR [esi+36], ebx
  0004d	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
  00050	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  00053	89 1e		 mov	 DWORD PTR [esi], ebx
  00055	89 5e 48	 mov	 DWORD PTR [esi+72], ebx
  00058	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  0005b	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0005e	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00061	89 5e 40	 mov	 DWORD PTR [esi+64], ebx
  00064	89 5e 38	 mov	 DWORD PTR [esi+56], ebx
  00067	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  0006a	e8 00 00 00 00	 call	 @crc32@12
  0006f	89 46 4c	 mov	 DWORD PTR [esi+76], eax

; 101  :     s->msg = NULL;
; 102  :     s->transparent = 0;
; 103  : 
; 104  :     s->path = (char*)ALLOC(strlen(path)+1);

  00072	8b 44 24 6c	 mov	 eax, DWORD PTR _path$[esp+100]
  00076	89 5e 50	 mov	 DWORD PTR [esi+80], ebx
  00079	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  0007c	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0007f	90		 npad	 1
$L2633:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	40		 inc	 eax
  00083	3a cb		 cmp	 cl, bl
  00085	75 f9		 jne	 SHORT $L2633
  00087	2b c2		 sub	 eax, edx
  00089	40		 inc	 eax
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _malloc
  00090	83 c4 04	 add	 esp, 4

; 105  :     if (s->path == NULL) {

  00093	3b c3		 cmp	 eax, ebx
  00095	89 46 54	 mov	 DWORD PTR [esi+84], eax

; 106  :         return destroy(s), (gzFile)Z_NULL;

  00098	0f 84 b7 00 00
	00		 je	 $L2082

; 107  :     }
; 108  :     strcpy(s->path, path); /* do this early for debugging */

  0009e	8b 4c 24 6c	 mov	 ecx, DWORD PTR _path$[esp+100]
  000a2	8b d0		 mov	 edx, eax
$L2628:
  000a4	8a 01		 mov	 al, BYTE PTR [ecx]
  000a6	41		 inc	 ecx
  000a7	88 02		 mov	 BYTE PTR [edx], al
  000a9	42		 inc	 edx
  000aa	3a c3		 cmp	 al, bl
  000ac	75 f6		 jne	 SHORT $L2628

; 109  : 
; 110  :     s->mode = '\0';

  000ae	88 5e 5c	 mov	 BYTE PTR [esi+92], bl
  000b1	b1 72		 mov	 cl, 114			; 00000072H
$L2062:

; 111  :     do {
; 112  :         if (*p == 'r') s->mode = 'r';

  000b3	38 0f		 cmp	 BYTE PTR [edi], cl
  000b5	75 03		 jne	 SHORT $L2065
  000b7	88 4e 5c	 mov	 BYTE PTR [esi+92], cl
$L2065:

; 113  :         if (*p == 'w' || *p == 'a') s->mode = 'w';

  000ba	8a 07		 mov	 al, BYTE PTR [edi]
  000bc	3c 77		 cmp	 al, 119			; 00000077H
  000be	74 04		 je	 SHORT $L2067
  000c0	3c 61		 cmp	 al, 97			; 00000061H
  000c2	75 04		 jne	 SHORT $L2066
$L2067:
  000c4	c6 46 5c 77	 mov	 BYTE PTR [esi+92], 119	; 00000077H
$L2066:

; 114  :         if (*p >= '0' && *p <= '9') {

  000c8	8a 07		 mov	 al, BYTE PTR [edi]
  000ca	3c 30		 cmp	 al, 48			; 00000030H
  000cc	7c 0c		 jl	 SHORT $L2068
  000ce	3c 39		 cmp	 al, 57			; 00000039H
  000d0	7f 08		 jg	 SHORT $L2068

; 115  : 	    level = *p - '0';

  000d2	0f be e8	 movsx	 ebp, al
  000d5	83 ed 30	 sub	 ebp, 48			; 00000030H

; 116  : 	} else if (*p == 'f') {

  000d8	eb 27		 jmp	 SHORT $L2063
$L2068:
  000da	3c 66		 cmp	 al, 102			; 00000066H
  000dc	75 0a		 jne	 SHORT $L2070

; 117  : 	  strategy = Z_FILTERED;

  000de	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _strategy$[esp+104], 1

; 118  : 	} else if (*p == 'h') {

  000e6	eb 19		 jmp	 SHORT $L2063
$L2070:
  000e8	3c 68		 cmp	 al, 104			; 00000068H
  000ea	75 0a		 jne	 SHORT $L2072

; 119  : 	  strategy = Z_HUFFMAN_ONLY;

  000ec	c7 44 24 14 02
	00 00 00	 mov	 DWORD PTR _strategy$[esp+104], 2

; 120  : 	} else {

  000f4	eb 0b		 jmp	 SHORT $L2063
$L2072:

; 121  : 	    *m++ = *p; /* copy the mode */

  000f6	8b 54 24 10	 mov	 edx, DWORD PTR _m$[esp+104]
  000fa	88 02		 mov	 BYTE PTR [edx], al
  000fc	42		 inc	 edx
  000fd	89 54 24 10	 mov	 DWORD PTR _m$[esp+104], edx
$L2063:

; 122  : 	}
; 123  :     } while (*p++ && m != fmode + sizeof(fmode));

  00101	47		 inc	 edi
  00102	3a c3		 cmp	 al, bl
  00104	74 0c		 je	 SHORT $L2074
  00106	8b 44 24 10	 mov	 eax, DWORD PTR _m$[esp+104]
  0010a	8d 54 24 68	 lea	 edx, DWORD PTR _fmode$[esp+184]
  0010e	3b c2		 cmp	 eax, edx
  00110	75 a1		 jne	 SHORT $L2062
$L2074:

; 124  :     if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;

  00112	8a 46 5c	 mov	 al, BYTE PTR [esi+92]
  00115	3a c3		 cmp	 al, bl
  00117	74 3c		 je	 SHORT $L2082

; 125  :     
; 126  :     if (s->mode == 'w') {

  00119	3c 77		 cmp	 al, 119			; 00000077H
  0011b	75 49		 jne	 SHORT $L2077

; 127  : #ifdef NO_DEFLATE
; 128  :         err = Z_STREAM_ERROR;
; 129  : #else
; 130  :         err = deflateInit2(&(s->stream), level,
; 131  :                            Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);

  0011d	8b 44 24 14	 mov	 eax, DWORD PTR _strategy$[esp+104]
  00121	6a 38		 push	 56			; 00000038H
  00123	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05DOIEBMOI@1?41?44?$AA@
  00128	50		 push	 eax
  00129	6a 08		 push	 8
  0012b	6a f1		 push	 -15			; fffffff1H
  0012d	6a 08		 push	 8
  0012f	8b d5		 mov	 edx, ebp
  00131	8b ce		 mov	 ecx, esi
  00133	e8 00 00 00 00	 call	 @deflateInit2_@32

; 132  :         /* windowBits is passed < 0 to suppress zlib header */
; 133  : 
; 134  :         s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);

  00138	68 00 40 00 00	 push	 16384			; 00004000H
  0013d	8b f8		 mov	 edi, eax
  0013f	e8 00 00 00 00	 call	 _malloc
  00144	83 c4 04	 add	 esp, 4

; 135  : #endif
; 136  :         if (err != Z_OK || s->outbuf == Z_NULL) {

  00147	3b fb		 cmp	 edi, ebx
  00149	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0014c	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0014f	75 04		 jne	 SHORT $L2082
  00151	3b c3		 cmp	 eax, ebx
  00153	75 3f		 jne	 SHORT $L2087
$L2082:

; 137  :             return destroy(s), (gzFile)Z_NULL;

  00155	e8 00 00 00 00	 call	 @destroy@4
$L2637:
  0015a	5e		 pop	 esi
  0015b	5f		 pop	 edi
  0015c	5d		 pop	 ebp
  0015d	33 c0		 xor	 eax, eax
  0015f	5b		 pop	 ebx

; 178  : }

  00160	83 c4 58	 add	 esp, 88			; 00000058H
  00163	c2 08 00	 ret	 8
$L2077:

; 138  :         }
; 139  :     } else {
; 140  :         s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);

  00166	68 00 40 00 00	 push	 16384			; 00004000H
  0016b	e8 00 00 00 00	 call	 _malloc
  00170	83 c4 04	 add	 esp, 4

; 141  : 
; 142  :         err = inflateInit2(&(s->stream), -MAX_WBITS);

  00173	6a 38		 push	 56			; 00000038H
  00175	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05DOIEBMOI@1?41?44?$AA@
  0017a	ba f1 ff ff ff	 mov	 edx, -15		; fffffff1H
  0017f	8b ce		 mov	 ecx, esi
  00181	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00184	89 06		 mov	 DWORD PTR [esi], eax
  00186	e8 00 00 00 00	 call	 @inflateInit2_@16

; 143  :         /* windowBits is passed < 0 to tell that there is no zlib header.
; 144  :          * Note that in this case inflate *requires* an extra "dummy" byte
; 145  :          * after the compressed stream in order to complete decompression and
; 146  :          * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
; 147  :          * present after the compressed stream.
; 148  :          */
; 149  :         if (err != Z_OK || s->inbuf == Z_NULL) {

  0018b	85 c0		 test	 eax, eax
  0018d	75 c6		 jne	 SHORT $L2082
  0018f	39 5e 44	 cmp	 DWORD PTR [esi+68], ebx
  00192	74 c1		 je	 SHORT $L2082
$L2087:

; 150  :             return destroy(s), (gzFile)Z_NULL;
; 151  :         }
; 152  :     }
; 153  :     s->stream.avail_out = Z_BUFSIZE;

  00194	c7 46 10 00 40
	00 00		 mov	 DWORD PTR [esi+16], 16384 ; 00004000H

; 154  : 
; 155  :     errno = 0;

  0019b	e8 00 00 00 00	 call	 __errno
  001a0	89 18		 mov	 DWORD PTR [eax], ebx

; 156  :     s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);

  001a2	8b 44 24 70	 mov	 eax, DWORD PTR _fd$[esp+100]
  001a6	3b c3		 cmp	 eax, ebx
  001a8	8d 4c 24 18	 lea	 ecx, DWORD PTR _fmode$[esp+104]
  001ac	51		 push	 ecx
  001ad	7d 0c		 jge	 SHORT $L2629
  001af	8b 54 24 70	 mov	 edx, DWORD PTR _path$[esp+104]
  001b3	52		 push	 edx
  001b4	e8 00 00 00 00	 call	 _fopen
  001b9	eb 06		 jmp	 SHORT $L2636
$L2629:
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 __fdopen
$L2636:
  001c1	83 c4 08	 add	 esp, 8

; 157  : 
; 158  :     if (s->file == NULL) {

  001c4	3b c3		 cmp	 eax, ebx
  001c6	89 46 40	 mov	 DWORD PTR [esi+64], eax

; 159  :         return destroy(s), (gzFile)Z_NULL;

  001c9	74 8a		 je	 SHORT $L2082

; 160  :     }
; 161  :     if (s->mode == 'w') {

  001cb	80 7e 5c 77	 cmp	 BYTE PTR [esi+92], 119	; 00000077H
  001cf	75 39		 jne	 SHORT $L2094

; 162  :         /* Write a very simple .gz header:
; 163  :          */
; 164  :         fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
; 165  :              Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);

  001d1	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _gz_magic+4
  001d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _gz_magic
  001dd	6a 0b		 push	 11			; 0000000bH
  001df	53		 push	 ebx
  001e0	53		 push	 ebx
  001e1	53		 push	 ebx
  001e2	53		 push	 ebx
  001e3	53		 push	 ebx
  001e4	53		 push	 ebx
  001e5	6a 08		 push	 8
  001e7	52		 push	 edx
  001e8	51		 push	 ecx
  001e9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 _fprintf
  001f4	83 c4 30	 add	 esp, 48			; 00000030H

; 166  : 	s->startpos = 10L;

  001f7	c7 46 60 0a 00
	00 00		 mov	 DWORD PTR [esi+96], 10	; 0000000aH

; 175  :     }
; 176  :     
; 177  :     return (gzFile)s;

  001fe	8b c6		 mov	 eax, esi
  00200	5e		 pop	 esi
  00201	5f		 pop	 edi
  00202	5d		 pop	 ebp
  00203	5b		 pop	 ebx

; 178  : }

  00204	83 c4 58	 add	 esp, 88			; 00000058H
  00207	c2 08 00	 ret	 8
$L2094:

; 167  : 	/* We use 10L instead of ftell(s->file) to because ftell causes an
; 168  :          * fflush on some systems. This version of the library doesn't use
; 169  :          * startpos anyway in write mode, so this initialization is not
; 170  :          * necessary.
; 171  :          */
; 172  :     } else {
; 173  : 	check_header(s); /* skip the .gz header */

  0020a	8b c6		 mov	 eax, esi
  0020c	e8 00 00 00 00	 call	 @check_header@4

; 174  : 	s->startpos = (ftell(s->file) - s->stream.avail_in);

  00211	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  00214	52		 push	 edx
  00215	e8 00 00 00 00	 call	 _ftell
  0021a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0021d	83 c4 04	 add	 esp, 4
  00220	2b c1		 sub	 eax, ecx
  00222	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 175  :     }
; 176  :     
; 177  :     return (gzFile)s;

  00225	8b c6		 mov	 eax, esi
  00227	5e		 pop	 esi
  00228	5f		 pop	 edi
  00229	5d		 pop	 ebp
  0022a	5b		 pop	 ebx

; 178  : }

  0022b	83 c4 58	 add	 esp, 88			; 00000058H
  0022e	c2 08 00	 ret	 8
$L2049:
  00231	5f		 pop	 edi
  00232	5d		 pop	 ebp

; 85   : 
; 86   :     if (!path || !mode) return Z_NULL;

  00233	33 c0		 xor	 eax, eax
  00235	5b		 pop	 ebx

; 178  : }

  00236	83 c4 58	 add	 esp, 88			; 00000058H
  00239	c2 08 00	 ret	 8
@gz_open@12 ENDP
_TEXT	ENDS
PUBLIC	@gzopen@8
; Function compile flags: /Ogty
;	COMDAT @gzopen@8
_TEXT	SEGMENT
@gzopen@8 PROC NEAR					; COMDAT
; _path$ = ecx
; _mode$ = edx

; 187  :     return gz_open (path, mode, -1);

  00000	6a ff		 push	 -1
  00002	8b c2		 mov	 eax, edx
  00004	51		 push	 ecx
  00005	e8 00 00 00 00	 call	 @gz_open@12

; 188  : }

  0000a	c3		 ret	 0
@gzopen@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	@gzdopen@8
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @gzdopen@8
_TEXT	SEGMENT
_name$ = -20						; size = 20
@gzdopen@8 PROC NEAR					; COMDAT
; _fd$ = ecx
; _mode$ = edx

; 197  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 198  :     char name[20];
; 199  : 
; 200  :     if (fd < 0) return (gzFile)Z_NULL;

  00006	85 f6		 test	 esi, esi
  00008	57		 push	 edi
  00009	8b fa		 mov	 edi, edx
  0000b	7d 08		 jge	 SHORT $L2107
  0000d	5f		 pop	 edi
  0000e	33 c0		 xor	 eax, eax
  00010	5e		 pop	 esi

; 204  : }

  00011	83 c4 14	 add	 esp, 20			; 00000014H
  00014	c3		 ret	 0
$L2107:

; 201  :     sprintf(name, "<fd:%d>", fd); /* for debugging */

  00015	56		 push	 esi
  00016	8d 44 24 0c	 lea	 eax, DWORD PTR _name$[esp+32]
  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _sprintf
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  : 
; 203  :     return gz_open (name, mode, fd);

  00028	56		 push	 esi
  00029	8d 4c 24 0c	 lea	 ecx, DWORD PTR _name$[esp+32]
  0002d	51		 push	 ecx
  0002e	8b c7		 mov	 eax, edi
  00030	e8 00 00 00 00	 call	 @gz_open@12
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 204  : }

  00037	83 c4 14	 add	 esp, 20			; 00000014H
  0003a	c3		 ret	 0
@gzdopen@8 ENDP
_TEXT	ENDS
PUBLIC	@gzread@12
EXTRN	@inflate@8:NEAR
; Function compile flags: /Ogty
;	COMDAT @gzread@12
_TEXT	SEGMENT
_next_out$ = -8						; size = 4
_buf$ = -4						; size = 4
_start$ = 8						; size = 4
_len$ = 8						; size = 4
@gzread@12 PROC NEAR					; COMDAT
; _file$ = ecx
; _buf$ = edx

; 359  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	55		 push	 ebp
  00004	8b e9		 mov	 ebp, ecx

; 360  :     gz_stream *s = (gz_stream*)file;
; 361  :     Bytef *start = (Bytef*)buf; /* starting point for crc computation */
; 362  :     Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */
; 363  : 
; 364  :     if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;

  00006	85 ed		 test	 ebp, ebp
  00008	56		 push	 esi
  00009	89 54 24 0c	 mov	 DWORD PTR _buf$[esp+16], edx
  0000d	8b f2		 mov	 esi, edx
  0000f	0f 84 13 02 00
	00		 je	 $L2198
  00015	80 7d 5c 72	 cmp	 BYTE PTR [ebp+92], 114	; 00000072H
  00019	0f 85 09 02 00
	00		 jne	 $L2198

; 365  : 
; 366  :     if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;

  0001f	8b 45 38	 mov	 eax, DWORD PTR [ebp+56]
  00022	83 f8 fd	 cmp	 eax, -3			; fffffffdH
  00025	0f 84 f2 01 00
	00		 je	 $L2652
  0002b	83 f8 ff	 cmp	 eax, -1
  0002e	0f 84 e9 01 00
	00		 je	 $L2652

; 367  :     if (s->z_err == Z_STREAM_END) return 0;  /* EOF */

  00034	83 f8 01	 cmp	 eax, 1
  00037	75 0a		 jne	 SHORT $L2201
  00039	5e		 pop	 esi
  0003a	33 c0		 xor	 eax, eax
  0003c	5d		 pop	 ebp

; 442  : }

  0003d	83 c4 08	 add	 esp, 8
  00040	c2 04 00	 ret	 4
$L2201:
  00043	53		 push	 ebx

; 368  : 
; 369  :     next_out = (Byte*)buf;
; 370  :     s->stream.next_out = (Bytef*)buf;
; 371  :     s->stream.avail_out = len;

  00044	8b 5c 24 18	 mov	 ebx, DWORD PTR _len$[esp+16]

; 372  : 
; 373  :     while (s->stream.avail_out != 0) {

  00048	85 db		 test	 ebx, ebx
  0004a	57		 push	 edi
  0004b	89 54 24 10	 mov	 DWORD PTR _next_out$[esp+24], edx
  0004f	89 55 0c	 mov	 DWORD PTR [ebp+12], edx
  00052	89 5d 10	 mov	 DWORD PTR [ebp+16], ebx
  00055	0f 84 f8 00 00
	00		 je	 $L2648
  0005b	eb 03 8d 49 00	 npad	 5
$L2205:

; 374  : 
; 375  : 	if (s->transparent) {

  00060	8b 45 58	 mov	 eax, DWORD PTR [ebp+88]
  00063	85 c0		 test	 eax, eax
  00065	0f 85 0c 01 00
	00		 jne	 $L2646

; 396  : 	}
; 397  :         if (s->stream.avail_in == 0 && !s->z_eof) {

  0006b	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  0006e	85 c0		 test	 eax, eax
  00070	75 4a		 jne	 SHORT $L2654
  00072	8b 45 3c	 mov	 eax, DWORD PTR [ebp+60]
  00075	85 c0		 test	 eax, eax
  00077	75 43		 jne	 SHORT $L2654

; 398  : 
; 399  :             errno = 0;

  00079	e8 00 00 00 00	 call	 __errno
  0007e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 400  :             s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);

  00084	8b 45 40	 mov	 eax, DWORD PTR [ebp+64]
  00087	8b 4d 44	 mov	 ecx, DWORD PTR [ebp+68]
  0008a	50		 push	 eax
  0008b	68 00 40 00 00	 push	 16384			; 00004000H
  00090	6a 01		 push	 1
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 _fread
  00098	83 c4 10	 add	 esp, 16			; 00000010H

; 401  :             if (s->stream.avail_in == 0) {

  0009b	85 c0		 test	 eax, eax
  0009d	89 45 04	 mov	 DWORD PTR [ebp+4], eax
  000a0	75 14		 jne	 SHORT $L2218

; 402  :                 s->z_eof = 1;
; 403  : 		if (ferror(s->file)) {

  000a2	8b 55 40	 mov	 edx, DWORD PTR [ebp+64]
  000a5	c7 45 3c 01 00
	00 00		 mov	 DWORD PTR [ebp+60], 1
  000ac	f6 42 0c 20	 test	 BYTE PTR [edx+12], 32	; 00000020H
  000b0	0f 85 5b 01 00
	00		 jne	 $L2647
$L2218:

; 405  : 		    break;
; 406  : 		}
; 407  :             }
; 408  :             s->stream.next_in = s->inbuf;

  000b6	8b 45 44	 mov	 eax, DWORD PTR [ebp+68]
  000b9	89 45 00	 mov	 DWORD PTR [ebp], eax
$L2654:

; 409  :         }
; 410  :         s->z_err = inflate(&(s->stream), Z_NO_FLUSH);

  000bc	33 d2		 xor	 edx, edx
  000be	8b cd		 mov	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @inflate@8

; 411  : 
; 412  : 	if (s->z_err == Z_STREAM_END) {

  000c5	83 f8 01	 cmp	 eax, 1
  000c8	89 45 38	 mov	 DWORD PTR [ebp+56], eax
  000cb	75 60		 jne	 SHORT $L2224

; 413  : 	    /* Check CRC and original size */
; 414  : 	    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

  000cd	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  000d0	2b ce		 sub	 ecx, esi
  000d2	51		 push	 ecx
  000d3	8b 4d 4c	 mov	 ecx, DWORD PTR [ebp+76]
  000d6	8b d6		 mov	 edx, esi
  000d8	e8 00 00 00 00	 call	 @crc32@12

; 415  : 	    start = s->stream.next_out;

  000dd	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]
  000e0	89 45 4c	 mov	 DWORD PTR [ebp+76], eax

; 416  : 
; 417  : 	    if (getLong(s) != s->crc) {

  000e3	8b c5		 mov	 eax, ebp
  000e5	89 54 24 1c	 mov	 DWORD PTR _start$[esp+20], edx
  000e9	e8 00 00 00 00	 call	 @getLong@4
  000ee	3b 45 4c	 cmp	 eax, DWORD PTR [ebp+76]
  000f1	75 55		 jne	 SHORT $L2649

; 420  : 	        (void)getLong(s);

  000f3	8b c5		 mov	 eax, ebp
  000f5	e8 00 00 00 00	 call	 @getLong@4

; 421  :                 /* The uncompressed length returned by above getlong() may
; 422  :                  * be different from s->stream.total_out) in case of
; 423  : 		 * concatenated .gz files. Check for such files:
; 424  : 		 */
; 425  : 		check_header(s);

  000fa	8b c5		 mov	 eax, ebp
  000fc	e8 00 00 00 00	 call	 @check_header@4

; 426  : 		if (s->z_err == Z_OK) {

  00101	8b 45 38	 mov	 eax, DWORD PTR [ebp+56]
  00104	85 c0		 test	 eax, eax
  00106	75 47		 jne	 SHORT $L2651

; 427  : 		    uLong total_in = s->stream.total_in;

  00108	8b 75 08	 mov	 esi, DWORD PTR [ebp+8]

; 428  : 		    uLong total_out = s->stream.total_out;

  0010b	8b 7d 14	 mov	 edi, DWORD PTR [ebp+20]

; 429  : 
; 430  : 		    inflateReset(&(s->stream));

  0010e	8b cd		 mov	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @inflateReset@4

; 431  : 		    s->stream.total_in = total_in;
; 432  : 		    s->stream.total_out = total_out;
; 433  : 		    s->crc = crc32(0L, Z_NULL, 0);

  00115	6a 00		 push	 0
  00117	33 d2		 xor	 edx, edx
  00119	33 c9		 xor	 ecx, ecx
  0011b	89 75 08	 mov	 DWORD PTR [ebp+8], esi
  0011e	89 7d 14	 mov	 DWORD PTR [ebp+20], edi
  00121	e8 00 00 00 00	 call	 @crc32@12
  00126	8b 74 24 1c	 mov	 esi, DWORD PTR _start$[esp+20]
  0012a	89 45 4c	 mov	 DWORD PTR [ebp+76], eax
$L2224:

; 434  : 		}
; 435  : 	    }
; 436  : 	}
; 437  : 	if (s->z_err != Z_OK || s->z_eof) break;

  0012d	8b 45 38	 mov	 eax, DWORD PTR [ebp+56]
  00130	85 c0		 test	 eax, eax
  00132	75 1f		 jne	 SHORT $L2648
  00134	8b 45 3c	 mov	 eax, DWORD PTR [ebp+60]
  00137	85 c0		 test	 eax, eax
  00139	75 18		 jne	 SHORT $L2648
  0013b	8b 45 10	 mov	 eax, DWORD PTR [ebp+16]
  0013e	85 c0		 test	 eax, eax
  00140	0f 85 1a ff ff
	ff		 jne	 $L2205

; 372  : 
; 373  :     while (s->stream.avail_out != 0) {

  00146	eb 0b		 jmp	 SHORT $L2648
$L2649:

; 418  : 		s->z_err = Z_DATA_ERROR;

  00148	c7 45 38 fd ff
	ff ff		 mov	 DWORD PTR [ebp+56], -3	; fffffffdH
$L2651:

; 419  : 	    } else {

  0014f	8b 74 24 1c	 mov	 esi, DWORD PTR _start$[esp+20]
$L2648:

; 438  :     }
; 439  :     s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

  00153	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]
  00156	2b ce		 sub	 ecx, esi
  00158	51		 push	 ecx
  00159	8b 4d 4c	 mov	 ecx, DWORD PTR [ebp+76]
  0015c	8b d6		 mov	 edx, esi
  0015e	e8 00 00 00 00	 call	 @crc32@12

; 440  : 
; 441  :     return (int)(len - s->stream.avail_out);

  00163	8b 4d 10	 mov	 ecx, DWORD PTR [ebp+16]
  00166	89 45 4c	 mov	 DWORD PTR [ebp+76], eax
  00169	5f		 pop	 edi
  0016a	8b c3		 mov	 eax, ebx
  0016c	5b		 pop	 ebx
  0016d	5e		 pop	 esi
  0016e	2b c1		 sub	 eax, ecx
  00170	5d		 pop	 ebp

; 442  : }

  00171	83 c4 08	 add	 esp, 8
  00174	c2 04 00	 ret	 4
$L2646:

; 376  : 	    /* Copy first the lookahead bytes: */
; 377  : 	    uInt n = s->stream.avail_in;

  00177	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]

; 378  : 	    if (n > s->stream.avail_out) n = s->stream.avail_out;

  0017a	8b 4d 10	 mov	 ecx, DWORD PTR [ebp+16]
  0017d	3b c1		 cmp	 eax, ecx
  0017f	76 02		 jbe	 SHORT $L2209
  00181	8b c1		 mov	 eax, ecx
$L2209:

; 379  : 	    if (n > 0) {

  00183	85 c0		 test	 eax, eax
  00185	76 3b		 jbe	 SHORT $L2210

; 380  : 		zmemcpy(s->stream.next_out, s->stream.next_in, n);

  00187	8b 75 00	 mov	 esi, DWORD PTR [ebp]
  0018a	8b 7d 0c	 mov	 edi, DWORD PTR [ebp+12]
  0018d	8b c8		 mov	 ecx, eax
  0018f	8b d1		 mov	 edx, ecx
  00191	c1 e9 02	 shr	 ecx, 2
  00194	f3 a5		 rep movsd
  00196	8b ca		 mov	 ecx, edx
  00198	83 e1 03	 and	 ecx, 3
  0019b	f3 a4		 rep movsb

; 381  : 		next_out += n;

  0019d	8b 4c 24 14	 mov	 ecx, DWORD PTR _buf$[esp+24]

; 382  : 		s->stream.next_out = next_out;
; 383  : 		s->stream.next_in   += n;

  001a1	8b 75 00	 mov	 esi, DWORD PTR [ebp]

; 384  : 		s->stream.avail_out -= n;

  001a4	8b 55 10	 mov	 edx, DWORD PTR [ebp+16]
  001a7	03 c8		 add	 ecx, eax
  001a9	89 4c 24 10	 mov	 DWORD PTR _next_out$[esp+24], ecx
  001ad	89 4d 0c	 mov	 DWORD PTR [ebp+12], ecx

; 385  : 		s->stream.avail_in  -= n;

  001b0	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  001b3	03 f0		 add	 esi, eax
  001b5	2b d0		 sub	 edx, eax
  001b7	2b c8		 sub	 ecx, eax
  001b9	89 75 00	 mov	 DWORD PTR [ebp], esi
  001bc	89 55 10	 mov	 DWORD PTR [ebp+16], edx
  001bf	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
$L2210:

; 386  : 	    }
; 387  : 	    if (s->stream.avail_out > 0) {

  001c2	8b 45 10	 mov	 eax, DWORD PTR [ebp+16]
  001c5	85 c0		 test	 eax, eax
  001c7	76 1c		 jbe	 SHORT $L2653

; 388  : 		s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,
; 389  : 					     s->file);

  001c9	8b 55 40	 mov	 edx, DWORD PTR [ebp+64]
  001cc	52		 push	 edx
  001cd	50		 push	 eax
  001ce	8b 44 24 18	 mov	 eax, DWORD PTR _next_out$[esp+32]
  001d2	6a 01		 push	 1
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 _fread
  001da	8b 4d 10	 mov	 ecx, DWORD PTR [ebp+16]
  001dd	83 c4 10	 add	 esp, 16			; 00000010H
  001e0	2b c8		 sub	 ecx, eax
  001e2	89 4d 10	 mov	 DWORD PTR [ebp+16], ecx
$L2653:

; 390  : 	    }
; 391  : 	    len -= s->stream.avail_out;

  001e5	8b 75 10	 mov	 esi, DWORD PTR [ebp+16]

; 392  : 	    s->stream.total_in  += (uLong)len;

  001e8	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]

; 393  : 	    s->stream.total_out += (uLong)len;

  001eb	8b 4d 14	 mov	 ecx, DWORD PTR [ebp+20]
  001ee	2b de		 sub	 ebx, esi
  001f0	03 d3		 add	 edx, ebx
  001f2	03 cb		 add	 ecx, ebx

; 394  :             if (len == 0) s->z_eof = 1;

  001f4	85 db		 test	 ebx, ebx
  001f6	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  001f9	89 4d 14	 mov	 DWORD PTR [ebp+20], ecx
  001fc	75 07		 jne	 SHORT $L2214
  001fe	c7 45 3c 01 00
	00 00		 mov	 DWORD PTR [ebp+60], 1
$L2214:
  00205	5f		 pop	 edi

; 395  : 	    return (int)len;

  00206	8b c3		 mov	 eax, ebx
  00208	5b		 pop	 ebx
  00209	5e		 pop	 esi
  0020a	5d		 pop	 ebp

; 442  : }

  0020b	83 c4 08	 add	 esp, 8
  0020e	c2 04 00	 ret	 4
$L2647:

; 404  : 		    s->z_err = Z_ERRNO;

  00211	c7 45 38 ff ff
	ff ff		 mov	 DWORD PTR [ebp+56], -1
  00218	e9 36 ff ff ff	 jmp	 $L2648
$L2652:
  0021d	5e		 pop	 esi

; 365  : 
; 366  :     if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;

  0021e	83 c8 ff	 or	 eax, -1
  00221	5d		 pop	 ebp

; 442  : }

  00222	83 c4 08	 add	 esp, 8
  00225	c2 04 00	 ret	 4
$L2198:
  00228	5e		 pop	 esi

; 360  :     gz_stream *s = (gz_stream*)file;
; 361  :     Bytef *start = (Bytef*)buf; /* starting point for crc computation */
; 362  :     Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */
; 363  : 
; 364  :     if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;

  00229	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0022e	5d		 pop	 ebp

; 442  : }

  0022f	83 c4 08	 add	 esp, 8
  00232	c2 04 00	 ret	 4
@gzread@12 ENDP
_TEXT	ENDS
PUBLIC	@gzgetc@4
; Function compile flags: /Ogty
;	COMDAT @gzgetc@4
_TEXT	SEGMENT
_c$ = -1						; size = 1
@gzgetc@4 PROC NEAR					; COMDAT
; _file$ = ecx

; 451  : {

  00000	51		 push	 ecx

; 452  :     unsigned char c;
; 453  : 
; 454  :     return gzread(file, &c, 1) == 1 ? c : -1;

  00001	6a 01		 push	 1
  00003	8d 54 24 07	 lea	 edx, DWORD PTR _c$[esp+8]
  00007	e8 00 00 00 00	 call	 @gzread@12
  0000c	83 f8 01	 cmp	 eax, 1
  0000f	75 07		 jne	 SHORT $L2659
  00011	0f b6 44 24 03	 movzx	 eax, BYTE PTR _c$[esp+4]

; 455  : }

  00016	59		 pop	 ecx
  00017	c3		 ret	 0
$L2659:

; 452  :     unsigned char c;
; 453  : 
; 454  :     return gzread(file, &c, 1) == 1 ? c : -1;

  00018	83 c8 ff	 or	 eax, -1

; 455  : }

  0001b	59		 pop	 ecx
  0001c	c3		 ret	 0
@gzgetc@4 ENDP
_TEXT	ENDS
PUBLIC	@gzgets@12
; Function compile flags: /Ogty
;	COMDAT @gzgets@12
_TEXT	SEGMENT
_len$ = 8						; size = 4
@gzgets@12 PROC NEAR					; COMDAT
; _file$ = ecx
; _buf$ = edx

; 471  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	8b f2		 mov	 esi, edx

; 472  :     char *b = buf;
; 473  :     if (buf == Z_NULL || len <= 0) return Z_NULL;

  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	8b d9		 mov	 ebx, ecx
  0000a	8b ee		 mov	 ebp, esi
  0000c	74 38		 je	 SHORT $L2242
  0000e	8b 7c 24 14	 mov	 edi, DWORD PTR _len$[esp+12]
  00012	85 ff		 test	 edi, edi
  00014	7e 30		 jle	 SHORT $L2242
$L2244:

; 474  : 
; 475  :     while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;

  00016	4f		 dec	 edi
  00017	85 ff		 test	 edi, edi
  00019	7e 17		 jle	 SHORT $L2667
  0001b	6a 01		 push	 1
  0001d	8b d6		 mov	 edx, esi
  0001f	8b cb		 mov	 ecx, ebx
  00021	e8 00 00 00 00	 call	 @gzread@12
  00026	83 f8 01	 cmp	 eax, 1
  00029	75 07		 jne	 SHORT $L2667
  0002b	8a 06		 mov	 al, BYTE PTR [esi]
  0002d	46		 inc	 esi
  0002e	3c 0a		 cmp	 al, 10			; 0000000aH
  00030	75 e4		 jne	 SHORT $L2244
$L2667:

; 476  :     *buf = '\0';
; 477  :     return b == buf && len > 0 ? Z_NULL : b;

  00032	3b ee		 cmp	 ebp, esi
  00034	c6 06 00	 mov	 BYTE PTR [esi], 0
  00037	75 04		 jne	 SHORT $L2663
  00039	85 ff		 test	 edi, edi
  0003b	7f 09		 jg	 SHORT $L2242
$L2663:
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	8b c5		 mov	 eax, ebp
  00041	5d		 pop	 ebp
  00042	5b		 pop	 ebx

; 478  : }

  00043	c2 04 00	 ret	 4
$L2242:
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5d		 pop	 ebp

; 472  :     char *b = buf;
; 473  :     if (buf == Z_NULL || len <= 0) return Z_NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	5b		 pop	 ebx

; 478  : }

  0004c	c2 04 00	 ret	 4
@gzgets@12 ENDP
_TEXT	ENDS
PUBLIC	@gzseek@12
; Function compile flags: /Ogty
;	COMDAT @gzseek@12
_TEXT	SEGMENT
_whence$ = 8						; size = 4
@gzseek@12 PROC NEAR					; COMDAT
; _file$ = ecx
; _offset$ = edx

; 664  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 665  :     gz_stream *s = (gz_stream*)file;
; 666  : 
; 667  :     if (s == NULL || whence == SEEK_END ||
; 668  : 	s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {

  00003	85 db		 test	 ebx, ebx
  00005	56		 push	 esi
  00006	8b f2		 mov	 esi, edx
  00008	0f 84 2e 01 00
	00		 je	 $L2340
  0000e	8b 4c 24 0c	 mov	 ecx, DWORD PTR _whence$[esp+4]
  00012	83 f9 02	 cmp	 ecx, 2
  00015	0f 84 21 01 00
	00		 je	 $L2340
  0001b	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  0001e	83 f8 ff	 cmp	 eax, -1
  00021	0f 84 15 01 00
	00		 je	 $L2340
  00027	83 f8 fd	 cmp	 eax, -3			; fffffffdH
  0002a	0f 84 0c 01 00
	00		 je	 $L2340

; 670  :     }
; 671  :     
; 672  :     if (s->mode == 'w') {

  00030	80 7b 5c 77	 cmp	 BYTE PTR [ebx+92], 119	; 00000077H
  00034	75 66		 jne	 SHORT $L2341

; 673  : #ifdef NO_DEFLATE
; 674  : 	return -1L;
; 675  : #else
; 676  : 	if (whence == SEEK_SET) {

  00036	85 c9		 test	 ecx, ecx
  00038	75 03		 jne	 SHORT $L2342

; 677  : 	    offset -= s->stream.total_in;

  0003a	2b 73 08	 sub	 esi, DWORD PTR [ebx+8]
$L2342:

; 678  : 	}
; 679  : 	if (offset < 0) return -1L;

  0003d	85 f6		 test	 esi, esi
  0003f	0f 8c f7 00 00
	00		 jl	 $L2340

; 680  : 
; 681  : 	/* At this point, offset is the number of zero bytes to write. */
; 682  : 	if (s->inbuf == Z_NULL) {

  00045	8b 43 44	 mov	 eax, DWORD PTR [ebx+68]
  00048	85 c0		 test	 eax, eax
  0004a	75 1d		 jne	 SHORT $L2670
  0004c	57		 push	 edi

; 683  : 	    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */

  0004d	68 00 40 00 00	 push	 16384			; 00004000H
  00052	e8 00 00 00 00	 call	 _malloc
  00057	8b f8		 mov	 edi, eax
  00059	83 c4 04	 add	 esp, 4
  0005c	89 7b 44	 mov	 DWORD PTR [ebx+68], edi

; 684  : 	    zmemzero(s->inbuf, Z_BUFSIZE);

  0005f	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00064	33 c0		 xor	 eax, eax
  00066	f3 ab		 rep stosd
  00068	5f		 pop	 edi
$L2670:

; 685  : 	}
; 686  : 	while (offset > 0)  {

  00069	85 f6		 test	 esi, esi
  0006b	7e 27		 jle	 SHORT $L2348
  0006d	8d 49 00	 npad	 3
$L2347:

; 687  : 	    uInt size = Z_BUFSIZE;

  00070	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H

; 688  : 	    if (offset < Z_BUFSIZE) size = (uInt)offset;

  00075	3b f0		 cmp	 esi, eax
  00077	7d 02		 jge	 SHORT $L2350
  00079	8b c6		 mov	 eax, esi
$L2350:

; 689  : 
; 690  : 	    size = gzwrite(file, s->inbuf, size);

  0007b	8b 53 44	 mov	 edx, DWORD PTR [ebx+68]
  0007e	50		 push	 eax
  0007f	8b cb		 mov	 ecx, ebx
  00081	e8 00 00 00 00	 call	 @gzwrite@12

; 691  : 	    if (size == 0) return -1L;

  00086	85 c0		 test	 eax, eax
  00088	0f 84 ae 00 00
	00		 je	 $L2340

; 692  : 
; 693  : 	    offset -= size;

  0008e	2b f0		 sub	 esi, eax
  00090	85 f6		 test	 esi, esi
  00092	7f dc		 jg	 SHORT $L2347
$L2348:

; 694  : 	}
; 695  : 	return (z_off_t)s->stream.total_in;

  00094	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx

; 736  : }

  00099	c2 04 00	 ret	 4
$L2341:

; 696  : #endif
; 697  :     }
; 698  :     /* Rest of function is for reading only */
; 699  : 
; 700  :     /* compute absolute position */
; 701  :     if (whence == SEEK_CUR) {

  0009c	83 f9 01	 cmp	 ecx, 1
  0009f	75 03		 jne	 SHORT $L2354

; 702  : 	offset += s->stream.total_out;

  000a1	03 73 14	 add	 esi, DWORD PTR [ebx+20]
$L2354:

; 703  :     }
; 704  :     if (offset < 0) return -1L;

  000a4	85 f6		 test	 esi, esi
  000a6	0f 8c 90 00 00
	00		 jl	 $L2340

; 705  : 
; 706  :     if (s->transparent) {

  000ac	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  000af	85 c0		 test	 eax, eax
  000b1	74 2c		 je	 SHORT $L2356

; 707  : 	/* map to fseek */
; 708  : 	s->stream.avail_in = 0;
; 709  : 	s->stream.next_in = s->inbuf;
; 710  :         if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;

  000b3	8b 4b 40	 mov	 ecx, DWORD PTR [ebx+64]
  000b6	8b 43 44	 mov	 eax, DWORD PTR [ebx+68]
  000b9	6a 00		 push	 0
  000bb	56		 push	 esi
  000bc	51		 push	 ecx
  000bd	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  000c4	89 03		 mov	 DWORD PTR [ebx], eax
  000c6	e8 00 00 00 00	 call	 _fseek
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ce	85 c0		 test	 eax, eax
  000d0	7c 6a		 jl	 SHORT $L2340

; 711  : 
; 712  : 	s->stream.total_in = s->stream.total_out = (uLong)offset;

  000d2	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000d5	89 73 08	 mov	 DWORD PTR [ebx+8], esi

; 713  : 	return offset;

  000d8	8b c6		 mov	 eax, esi
  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx

; 736  : }

  000dc	c2 04 00	 ret	 4
$L2356:

; 714  :     }
; 715  : 
; 716  :     /* For a negative seek, rewind and use positive seek */
; 717  :     if ((uLong)offset >= s->stream.total_out) {

  000df	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000e2	3b f0		 cmp	 esi, eax
  000e4	72 04		 jb	 SHORT $L2360

; 718  : 	offset -= s->stream.total_out;

  000e6	2b f0		 sub	 esi, eax

; 719  :     } else if (gzrewind(file) < 0) {

  000e8	eb 0b		 jmp	 SHORT $L2362
$L2360:
  000ea	8b cb		 mov	 ecx, ebx
  000ec	e8 00 00 00 00	 call	 @gzrewind@4
  000f1	85 c0		 test	 eax, eax

; 720  : 	return -1L;

  000f3	7c 47		 jl	 SHORT $L2340
$L2362:

; 721  :     }
; 722  :     /* offset is now the number of bytes to skip. */
; 723  : 
; 724  :     if (offset != 0 && s->outbuf == Z_NULL) {

  000f5	85 f6		 test	 esi, esi
  000f7	74 3b		 je	 SHORT $L2367
  000f9	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  000fc	85 c0		 test	 eax, eax
  000fe	75 10		 jne	 SHORT $L2671

; 725  : 	s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);

  00100	68 00 40 00 00	 push	 16384			; 00004000H
  00105	e8 00 00 00 00	 call	 _malloc
  0010a	83 c4 04	 add	 esp, 4
  0010d	89 43 48	 mov	 DWORD PTR [ebx+72], eax
$L2671:

; 726  :     }
; 727  :     while (offset > 0)  {

  00110	85 f6		 test	 esi, esi
  00112	7e 20		 jle	 SHORT $L2367
$L2366:

; 728  : 	int size = Z_BUFSIZE;

  00114	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H

; 729  : 	if (offset < Z_BUFSIZE) size = (int)offset;

  00119	3b f0		 cmp	 esi, eax
  0011b	7d 02		 jge	 SHORT $L2369
  0011d	8b c6		 mov	 eax, esi
$L2369:

; 730  : 
; 731  : 	size = gzread(file, s->outbuf, (uInt)size);

  0011f	8b 53 48	 mov	 edx, DWORD PTR [ebx+72]
  00122	50		 push	 eax
  00123	8b cb		 mov	 ecx, ebx
  00125	e8 00 00 00 00	 call	 @gzread@12

; 732  : 	if (size <= 0) return -1L;

  0012a	85 c0		 test	 eax, eax
  0012c	7e 0e		 jle	 SHORT $L2340

; 733  : 	offset -= size;

  0012e	2b f0		 sub	 esi, eax
  00130	85 f6		 test	 esi, esi
  00132	7f e0		 jg	 SHORT $L2366
$L2367:

; 734  :     }
; 735  :     return (z_off_t)s->stream.total_out;

  00134	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx

; 736  : }

  00139	c2 04 00	 ret	 4
$L2340:
  0013c	5e		 pop	 esi

; 669  : 	return -1L;

  0013d	83 c8 ff	 or	 eax, -1
  00140	5b		 pop	 ebx

; 736  : }

  00141	c2 04 00	 ret	 4
@gzseek@12 ENDP
_TEXT	ENDS
PUBLIC	@gztell@4
; Function compile flags: /Ogty
;	COMDAT @gztell@4
_TEXT	SEGMENT
@gztell@4 PROC NEAR					; COMDAT
; _file$ = ecx

; 771  :     return gzseek(file, 0L, SEEK_CUR);

  00000	6a 01		 push	 1
  00002	33 d2		 xor	 edx, edx
  00004	e8 00 00 00 00	 call	 @gzseek@12

; 772  : }

  00009	c3		 ret	 0
@gztell@4 ENDP
_TEXT	ENDS
END
