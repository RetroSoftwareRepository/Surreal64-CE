; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\trees.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT @tr_static_init@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @_tr_init@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @init_block@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @pqdownheap@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gen_bitlen@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @gen_codes@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @build_tree@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @scan_tree@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @send_tree@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @build_bl_tree@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @send_all_trees@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @_tr_stored_block@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @_tr_align@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @_tr_flush_block@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @_tr_tally@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @compress_block@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @set_data_type@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @bi_reverse@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @bi_flush@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @bi_windup@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @copy_block@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__length_code
PUBLIC	__dist_code
CONST	SEGMENT
_extra_lbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	ORG $+4
_extra_dbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
_extra_blbits DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	03H
	DD	07H
_bl_order DB	010H
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+1
_static_ltree DW 0cH
	DW	08H
	DW	08cH
	DW	08H
	DW	04cH
	DW	08H
	DW	0ccH
	DW	08H
	DW	02cH
	DW	08H
	DW	0acH
	DW	08H
	DW	06cH
	DW	08H
	DW	0ecH
	DW	08H
	DW	01cH
	DW	08H
	DW	09cH
	DW	08H
	DW	05cH
	DW	08H
	DW	0dcH
	DW	08H
	DW	03cH
	DW	08H
	DW	0bcH
	DW	08H
	DW	07cH
	DW	08H
	DW	0fcH
	DW	08H
	DW	02H
	DW	08H
	DW	082H
	DW	08H
	DW	042H
	DW	08H
	DW	0c2H
	DW	08H
	DW	022H
	DW	08H
	DW	0a2H
	DW	08H
	DW	062H
	DW	08H
	DW	0e2H
	DW	08H
	DW	012H
	DW	08H
	DW	092H
	DW	08H
	DW	052H
	DW	08H
	DW	0d2H
	DW	08H
	DW	032H
	DW	08H
	DW	0b2H
	DW	08H
	DW	072H
	DW	08H
	DW	0f2H
	DW	08H
	DW	0aH
	DW	08H
	DW	08aH
	DW	08H
	DW	04aH
	DW	08H
	DW	0caH
	DW	08H
	DW	02aH
	DW	08H
	DW	0aaH
	DW	08H
	DW	06aH
	DW	08H
	DW	0eaH
	DW	08H
	DW	01aH
	DW	08H
	DW	09aH
	DW	08H
	DW	05aH
	DW	08H
	DW	0daH
	DW	08H
	DW	03aH
	DW	08H
	DW	0baH
	DW	08H
	DW	07aH
	DW	08H
	DW	0faH
	DW	08H
	DW	06H
	DW	08H
	DW	086H
	DW	08H
	DW	046H
	DW	08H
	DW	0c6H
	DW	08H
	DW	026H
	DW	08H
	DW	0a6H
	DW	08H
	DW	066H
	DW	08H
	DW	0e6H
	DW	08H
	DW	016H
	DW	08H
	DW	096H
	DW	08H
	DW	056H
	DW	08H
	DW	0d6H
	DW	08H
	DW	036H
	DW	08H
	DW	0b6H
	DW	08H
	DW	076H
	DW	08H
	DW	0f6H
	DW	08H
	DW	0eH
	DW	08H
	DW	08eH
	DW	08H
	DW	04eH
	DW	08H
	DW	0ceH
	DW	08H
	DW	02eH
	DW	08H
	DW	0aeH
	DW	08H
	DW	06eH
	DW	08H
	DW	0eeH
	DW	08H
	DW	01eH
	DW	08H
	DW	09eH
	DW	08H
	DW	05eH
	DW	08H
	DW	0deH
	DW	08H
	DW	03eH
	DW	08H
	DW	0beH
	DW	08H
	DW	07eH
	DW	08H
	DW	0feH
	DW	08H
	DW	01H
	DW	08H
	DW	081H
	DW	08H
	DW	041H
	DW	08H
	DW	0c1H
	DW	08H
	DW	021H
	DW	08H
	DW	0a1H
	DW	08H
	DW	061H
	DW	08H
	DW	0e1H
	DW	08H
	DW	011H
	DW	08H
	DW	091H
	DW	08H
	DW	051H
	DW	08H
	DW	0d1H
	DW	08H
	DW	031H
	DW	08H
	DW	0b1H
	DW	08H
	DW	071H
	DW	08H
	DW	0f1H
	DW	08H
	DW	09H
	DW	08H
	DW	089H
	DW	08H
	DW	049H
	DW	08H
	DW	0c9H
	DW	08H
	DW	029H
	DW	08H
	DW	0a9H
	DW	08H
	DW	069H
	DW	08H
	DW	0e9H
	DW	08H
	DW	019H
	DW	08H
	DW	099H
	DW	08H
	DW	059H
	DW	08H
	DW	0d9H
	DW	08H
	DW	039H
	DW	08H
	DW	0b9H
	DW	08H
	DW	079H
	DW	08H
	DW	0f9H
	DW	08H
	DW	05H
	DW	08H
	DW	085H
	DW	08H
	DW	045H
	DW	08H
	DW	0c5H
	DW	08H
	DW	025H
	DW	08H
	DW	0a5H
	DW	08H
	DW	065H
	DW	08H
	DW	0e5H
	DW	08H
	DW	015H
	DW	08H
	DW	095H
	DW	08H
	DW	055H
	DW	08H
	DW	0d5H
	DW	08H
	DW	035H
	DW	08H
	DW	0b5H
	DW	08H
	DW	075H
	DW	08H
	DW	0f5H
	DW	08H
	DW	0dH
	DW	08H
	DW	08dH
	DW	08H
	DW	04dH
	DW	08H
	DW	0cdH
	DW	08H
	DW	02dH
	DW	08H
	DW	0adH
	DW	08H
	DW	06dH
	DW	08H
	DW	0edH
	DW	08H
	DW	01dH
	DW	08H
	DW	09dH
	DW	08H
	DW	05dH
	DW	08H
	DW	0ddH
	DW	08H
	DW	03dH
	DW	08H
	DW	0bdH
	DW	08H
	DW	07dH
	DW	08H
	DW	0fdH
	DW	08H
	DW	013H
	DW	09H
	DW	0113H
	DW	09H
	DW	093H
	DW	09H
	DW	0193H
	DW	09H
	DW	053H
	DW	09H
	DW	0153H
	DW	09H
	DW	0d3H
	DW	09H
	DW	01d3H
	DW	09H
	DW	033H
	DW	09H
	DW	0133H
	DW	09H
	DW	0b3H
	DW	09H
	DW	01b3H
	DW	09H
	DW	073H
	DW	09H
	DW	0173H
	DW	09H
	DW	0f3H
	DW	09H
	DW	01f3H
	DW	09H
	DW	0bH
	DW	09H
	DW	010bH
	DW	09H
	DW	08bH
	DW	09H
	DW	018bH
	DW	09H
	DW	04bH
	DW	09H
	DW	014bH
	DW	09H
	DW	0cbH
	DW	09H
	DW	01cbH
	DW	09H
	DW	02bH
	DW	09H
	DW	012bH
	DW	09H
	DW	0abH
	DW	09H
	DW	01abH
	DW	09H
	DW	06bH
	DW	09H
	DW	016bH
	DW	09H
	DW	0ebH
	DW	09H
	DW	01ebH
	DW	09H
	DW	01bH
	DW	09H
	DW	011bH
	DW	09H
	DW	09bH
	DW	09H
	DW	019bH
	DW	09H
	DW	05bH
	DW	09H
	DW	015bH
	DW	09H
	DW	0dbH
	DW	09H
	DW	01dbH
	DW	09H
	DW	03bH
	DW	09H
	DW	013bH
	DW	09H
	DW	0bbH
	DW	09H
	DW	01bbH
	DW	09H
	DW	07bH
	DW	09H
	DW	017bH
	DW	09H
	DW	0fbH
	DW	09H
	DW	01fbH
	DW	09H
	DW	07H
	DW	09H
	DW	0107H
	DW	09H
	DW	087H
	DW	09H
	DW	0187H
	DW	09H
	DW	047H
	DW	09H
	DW	0147H
	DW	09H
	DW	0c7H
	DW	09H
	DW	01c7H
	DW	09H
	DW	027H
	DW	09H
	DW	0127H
	DW	09H
	DW	0a7H
	DW	09H
	DW	01a7H
	DW	09H
	DW	067H
	DW	09H
	DW	0167H
	DW	09H
	DW	0e7H
	DW	09H
	DW	01e7H
	DW	09H
	DW	017H
	DW	09H
	DW	0117H
	DW	09H
	DW	097H
	DW	09H
	DW	0197H
	DW	09H
	DW	057H
	DW	09H
	DW	0157H
	DW	09H
	DW	0d7H
	DW	09H
	DW	01d7H
	DW	09H
	DW	037H
	DW	09H
	DW	0137H
	DW	09H
	DW	0b7H
	DW	09H
	DW	01b7H
	DW	09H
	DW	077H
	DW	09H
	DW	0177H
	DW	09H
	DW	0f7H
	DW	09H
	DW	01f7H
	DW	09H
	DW	0fH
	DW	09H
	DW	010fH
	DW	09H
	DW	08fH
	DW	09H
	DW	018fH
	DW	09H
	DW	04fH
	DW	09H
	DW	014fH
	DW	09H
	DW	0cfH
	DW	09H
	DW	01cfH
	DW	09H
	DW	02fH
	DW	09H
	DW	012fH
	DW	09H
	DW	0afH
	DW	09H
	DW	01afH
	DW	09H
	DW	06fH
	DW	09H
	DW	016fH
	DW	09H
	DW	0efH
	DW	09H
	DW	01efH
	DW	09H
	DW	01fH
	DW	09H
	DW	011fH
	DW	09H
	DW	09fH
	DW	09H
	DW	019fH
	DW	09H
	DW	05fH
	DW	09H
	DW	015fH
	DW	09H
	DW	0dfH
	DW	09H
	DW	01dfH
	DW	09H
	DW	03fH
	DW	09H
	DW	013fH
	DW	09H
	DW	0bfH
	DW	09H
	DW	01bfH
	DW	09H
	DW	07fH
	DW	09H
	DW	017fH
	DW	09H
	DW	0ffH
	DW	09H
	DW	01ffH
	DW	09H
	DW	00H
	DW	07H
	DW	040H
	DW	07H
	DW	020H
	DW	07H
	DW	060H
	DW	07H
	DW	010H
	DW	07H
	DW	050H
	DW	07H
	DW	030H
	DW	07H
	DW	070H
	DW	07H
	DW	08H
	DW	07H
	DW	048H
	DW	07H
	DW	028H
	DW	07H
	DW	068H
	DW	07H
	DW	018H
	DW	07H
	DW	058H
	DW	07H
	DW	038H
	DW	07H
	DW	078H
	DW	07H
	DW	04H
	DW	07H
	DW	044H
	DW	07H
	DW	024H
	DW	07H
	DW	064H
	DW	07H
	DW	014H
	DW	07H
	DW	054H
	DW	07H
	DW	034H
	DW	07H
	DW	074H
	DW	07H
	DW	03H
	DW	08H
	DW	083H
	DW	08H
	DW	043H
	DW	08H
	DW	0c3H
	DW	08H
	DW	023H
	DW	08H
	DW	0a3H
	DW	08H
	DW	063H
	DW	08H
	DW	0e3H
	DW	08H
_static_dtree DW 00H
	DW	05H
	DW	010H
	DW	05H
	DW	08H
	DW	05H
	DW	018H
	DW	05H
	DW	04H
	DW	05H
	DW	014H
	DW	05H
	DW	0cH
	DW	05H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	012H
	DW	05H
	DW	0aH
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	05H
	DW	016H
	DW	05H
	DW	0eH
	DW	05H
	DW	01eH
	DW	05H
	DW	01H
	DW	05H
	DW	011H
	DW	05H
	DW	09H
	DW	05H
	DW	019H
	DW	05H
	DW	05H
	DW	05H
	DW	015H
	DW	05H
	DW	0dH
	DW	05H
	DW	01dH
	DW	05H
	DW	03H
	DW	05H
	DW	013H
	DW	05H
	DW	0bH
	DW	05H
	DW	01bH
	DW	05H
	DW	07H
	DW	05H
	DW	017H
	DW	05H
__dist_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	00H
	DB	00H
	DB	010H
	DB	011H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
__length_code DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
_base_length DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	0aH
	DD	0cH
	DD	0eH
	DD	010H
	DD	014H
	DD	018H
	DD	01cH
	DD	020H
	DD	028H
	DD	030H
	DD	038H
	DD	040H
	DD	050H
	DD	060H
	DD	070H
	DD	080H
	DD	0a0H
	DD	0c0H
	DD	0e0H
	DD	00H
	ORG $+4
_base_dist DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	06H
	DD	08H
	DD	0cH
	DD	010H
	DD	018H
	DD	020H
	DD	030H
	DD	040H
	DD	060H
	DD	080H
	DD	0c0H
	DD	0100H
	DD	0180H
	DD	0200H
	DD	0300H
	DD	0400H
	DD	0600H
	DD	0800H
	DD	0c00H
	DD	01000H
	DD	01800H
	DD	02000H
	DD	03000H
	DD	04000H
	DD	06000H
CONST	ENDS
_DATA	SEGMENT
_static_l_desc DD FLAT:_static_ltree
	DD	FLAT:_extra_lbits
	DD	0101H
	DD	011eH
	DD	0fH
_static_d_desc DD FLAT:_static_dtree
	DD	FLAT:_extra_dbits
	DD	00H
	DD	01eH
	DD	0fH
_static_bl_desc DD 00H
	DD	FLAT:_extra_blbits
	DD	00H
	DD	013H
	DD	07H
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\trees.c
_DATA	ENDS
;	COMDAT @tr_static_init@0
_TEXT	SEGMENT
@tr_static_init@0 PROC NEAR				; COMDAT

; 241  : #if defined(GEN_TREES_H) || !defined(STDC)
; 242  :     static int static_init_done = 0;
; 243  :     int n;        /* iterates over tree elements */
; 244  :     int bits;     /* bit counter */
; 245  :     int length;   /* length value */
; 246  :     int code;     /* code value */
; 247  :     int dist;     /* distance index */
; 248  :     ush bl_count[MAX_BITS+1];
; 249  :     /* number of codes at each bit length for an optimal tree */
; 250  : 
; 251  :     if (static_init_done) return;
; 252  : 
; 253  :     /* For some embedded targets, global variables are not initialized: */
; 254  :     static_l_desc.static_tree = static_ltree;
; 255  :     static_l_desc.extra_bits = extra_lbits;
; 256  :     static_d_desc.static_tree = static_dtree;
; 257  :     static_d_desc.extra_bits = extra_dbits;
; 258  :     static_bl_desc.extra_bits = extra_blbits;
; 259  : 
; 260  :     /* Initialize the mapping length (0..255) -> length code (0..28) */
; 261  :     length = 0;
; 262  :     for (code = 0; code < LENGTH_CODES-1; code++) {
; 263  :         base_length[code] = length;
; 264  :         for (n = 0; n < (1<<extra_lbits[code]); n++) {
; 265  :             _length_code[length++] = (uch)code;
; 266  :         }
; 267  :     }
; 268  :     Assert (length == 256, "tr_static_init: length != 256");
; 269  :     /* Note that the length 255 (match length 258) can be represented
; 270  :      * in two different ways: code 284 + 5 bits or code 285, so we
; 271  :      * overwrite length_code[255] to use the best encoding:
; 272  :      */
; 273  :     _length_code[length-1] = (uch)code;
; 274  : 
; 275  :     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
; 276  :     dist = 0;
; 277  :     for (code = 0 ; code < 16; code++) {
; 278  :         base_dist[code] = dist;
; 279  :         for (n = 0; n < (1<<extra_dbits[code]); n++) {
; 280  :             _dist_code[dist++] = (uch)code;
; 281  :         }
; 282  :     }
; 283  :     Assert (dist == 256, "tr_static_init: dist != 256");
; 284  :     dist >>= 7; /* from now on, all distances are divided by 128 */
; 285  :     for ( ; code < D_CODES; code++) {
; 286  :         base_dist[code] = dist << 7;
; 287  :         for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
; 288  :             _dist_code[256 + dist++] = (uch)code;
; 289  :         }
; 290  :     }
; 291  :     Assert (dist == 256, "tr_static_init: 256+dist != 512");
; 292  : 
; 293  :     /* Construct the codes of the static literal tree */
; 294  :     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
; 295  :     n = 0;
; 296  :     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
; 297  :     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
; 298  :     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
; 299  :     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
; 300  :     /* Codes 286 and 287 do not exist, but we must include them in the
; 301  :      * tree construction to get a canonical Huffman tree (longest code
; 302  :      * all ones)
; 303  :      */
; 304  :     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
; 305  : 
; 306  :     /* The static distance tree is trivial: */
; 307  :     for (n = 0; n < D_CODES; n++) {
; 308  :         static_dtree[n].Len = 5;
; 309  :         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
; 310  :     }
; 311  :     static_init_done = 1;
; 312  : 
; 313  : #  ifdef GEN_TREES_H
; 314  :     gen_trees_header();
; 315  : #  endif
; 316  : #endif /* defined(GEN_TREES_H) || !defined(STDC) */
; 317  : }

  00000	c3		 ret	 0
@tr_static_init@0 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @init_block@4
_TEXT	SEGMENT
@init_block@4 PROC NEAR					; COMDAT
; _s$ = edx

; 414  : {

  00000	56		 push	 esi

; 415  :     int n; /* iterates over tree elements */
; 416  : 
; 417  :     /* Initialize the trees. */
; 418  :     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;

  00001	8d 82 8c 00 00
	00		 lea	 eax, DWORD PTR [edx+140]
  00007	b9 1e 01 00 00	 mov	 ecx, 286		; 0000011eH
  0000c	33 f6		 xor	 esi, esi
  0000e	8b ff		 npad	 2
$L1871:
  00010	66 89 30	 mov	 WORD PTR [eax], si
  00013	83 c0 04	 add	 eax, 4
  00016	49		 dec	 ecx
  00017	75 f7		 jne	 SHORT $L1871

; 419  :     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;

  00019	8d 82 80 09 00
	00		 lea	 eax, DWORD PTR [edx+2432]
  0001f	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
$L1874:
  00024	66 89 30	 mov	 WORD PTR [eax], si
  00027	83 c0 04	 add	 eax, 4
  0002a	49		 dec	 ecx
  0002b	75 f7		 jne	 SHORT $L1874

; 420  :     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

  0002d	8d 82 74 0a 00
	00		 lea	 eax, DWORD PTR [edx+2676]
  00033	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
$L1877:
  00038	66 89 30	 mov	 WORD PTR [eax], si
  0003b	83 c0 04	 add	 eax, 4
  0003e	49		 dec	 ecx
  0003f	75 f7		 jne	 SHORT $L1877

; 421  : 
; 422  :     s->dyn_ltree[END_BLOCK].Freq = 1;
; 423  :     s->opt_len = s->static_len = 0L;

  00041	89 b2 a4 16 00
	00		 mov	 DWORD PTR [edx+5796], esi
  00047	89 b2 a0 16 00
	00		 mov	 DWORD PTR [edx+5792], esi

; 424  :     s->last_lit = s->matches = 0;

  0004d	89 b2 a8 16 00
	00		 mov	 DWORD PTR [edx+5800], esi
  00053	89 b2 98 16 00
	00		 mov	 DWORD PTR [edx+5784], esi
  00059	66 c7 82 8c 04
	00 00 01 00	 mov	 WORD PTR [edx+1164], 1
  00062	5e		 pop	 esi

; 425  : }

  00063	c3		 ret	 0
@init_block@4 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @pqdownheap@12
_TEXT	SEGMENT
_v$ = -4						; size = 4
_k$ = 8							; size = 4
@pqdownheap@12 PROC NEAR				; COMDAT
; _s$ = eax
; _tree$ = edi

; 460  : {

  00000	51		 push	 ecx

; 461  :     int v = s->heap[k];
; 462  :     int j = k << 1;  /* left son of k */
; 463  :     while (j <= s->heap_len) {

  00001	8b 90 48 14 00
	00		 mov	 edx, DWORD PTR [eax+5192]
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	8b 74 24 10	 mov	 esi, DWORD PTR _k$[esp+8]
  0000d	8b ac b0 54 0b
	00 00		 mov	 ebp, DWORD PTR [eax+esi*4+2900]
  00014	8d 0c 36	 lea	 ecx, DWORD PTR [esi+esi]
  00017	3b ca		 cmp	 ecx, edx
  00019	89 6c 24 08	 mov	 DWORD PTR _v$[esp+12], ebp
  0001d	0f 8f 9a 00 00
	00		 jg	 $L2550
  00023	53		 push	 ebx
$L2554:

; 464  :         /* Set j to the smallest of the two sons: */
; 465  :         if (j < s->heap_len &&
; 466  :             smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {

  00024	7d 32		 jge	 SHORT $L1893
  00026	8b b4 88 58 0b
	00 00		 mov	 esi, DWORD PTR [eax+ecx*4+2904]
  0002d	8b ac 88 54 0b
	00 00		 mov	 ebp, DWORD PTR [eax+ecx*4+2900]
  00034	66 8b 14 b7	 mov	 dx, WORD PTR [edi+esi*4]
  00038	66 8b 1c af	 mov	 bx, WORD PTR [edi+ebp*4]
  0003c	66 3b d3	 cmp	 dx, bx
  0003f	72 12		 jb	 SHORT $L1894
  00041	75 11		 jne	 SHORT $L2552
  00043	8a 94 06 50 14
	00 00		 mov	 dl, BYTE PTR [esi+eax+5200]
  0004a	3a 94 28 50 14
	00 00		 cmp	 dl, BYTE PTR [eax+ebp+5200]
  00051	77 01		 ja	 SHORT $L2552
$L1894:

; 467  :             j++;

  00053	41		 inc	 ecx
$L2552:
  00054	8b 6c 24 0c	 mov	 ebp, DWORD PTR _v$[esp+16]
$L1893:

; 468  :         }
; 469  :         /* Exit if v is smaller than both sons */
; 470  :         if (smaller(tree, v, s->heap[j], s->depth)) break;

  00058	8b b4 88 54 0b
	00 00		 mov	 esi, DWORD PTR [eax+ecx*4+2900]
  0005f	66 8b 14 af	 mov	 dx, WORD PTR [edi+ebp*4]
  00063	66 8b 1c b7	 mov	 bx, WORD PTR [edi+esi*4]
  00067	66 3b d3	 cmp	 dx, bx
  0006a	72 2d		 jb	 SHORT $L2549
  0006c	75 10		 jne	 SHORT $L1895
  0006e	8a 94 28 50 14
	00 00		 mov	 dl, BYTE PTR [eax+ebp+5200]
  00075	3a 94 06 50 14
	00 00		 cmp	 dl, BYTE PTR [esi+eax+5200]
  0007c	76 2d		 jbe	 SHORT $L2548
$L1895:

; 471  : 
; 472  :         /* Exchange v with the smallest son */
; 473  :         s->heap[k] = s->heap[j];  k = j;

  0007e	8b 54 24 14	 mov	 edx, DWORD PTR _k$[esp+12]
  00082	89 b4 90 54 0b
	00 00		 mov	 DWORD PTR [eax+edx*4+2900], esi
  00089	8b 90 48 14 00
	00		 mov	 edx, DWORD PTR [eax+5192]
  0008f	89 4c 24 14	 mov	 DWORD PTR _k$[esp+12], ecx

; 474  : 
; 475  :         /* And continue down the tree, setting j to the left son of k */
; 476  :         j <<= 1;

  00093	d1 e1		 shl	 ecx, 1
  00095	3b ca		 cmp	 ecx, edx
  00097	7e 8b		 jle	 SHORT $L2554
$L2549:

; 477  :     }
; 478  :     s->heap[k] = v;

  00099	8b 4c 24 14	 mov	 ecx, DWORD PTR _k$[esp+12]
  0009d	5b		 pop	 ebx
  0009e	5e		 pop	 esi
  0009f	89 ac 88 54 0b
	00 00		 mov	 DWORD PTR [eax+ecx*4+2900], ebp
  000a6	5d		 pop	 ebp

; 479  : }

  000a7	59		 pop	 ecx
  000a8	c2 04 00	 ret	 4
$L2548:

; 477  :     }
; 478  :     s->heap[k] = v;

  000ab	8b 54 24 14	 mov	 edx, DWORD PTR _k$[esp+12]
  000af	5b		 pop	 ebx
  000b0	5e		 pop	 esi
  000b1	89 ac 90 54 0b
	00 00		 mov	 DWORD PTR [eax+edx*4+2900], ebp
  000b8	5d		 pop	 ebp

; 479  : }

  000b9	59		 pop	 ecx
  000ba	c2 04 00	 ret	 4
$L2550:

; 477  :     }
; 478  :     s->heap[k] = v;

  000bd	89 ac b0 54 0b
	00 00		 mov	 DWORD PTR [eax+esi*4+2900], ebp
  000c4	5e		 pop	 esi
  000c5	5d		 pop	 ebp

; 479  : }

  000c6	59		 pop	 ecx
  000c7	c2 04 00	 ret	 4
@pqdownheap@12 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @gen_bitlen@8
_TEXT	SEGMENT
_h$ = -32						; size = 4
tv599 = -28						; size = 4
_overflow$ = -24					; size = 4
_n$ = -20						; size = 4
_max_length$ = -20					; size = 4
tv711 = -16						; size = 4
tv181 = -16						; size = 4
_max_code$ = -12					; size = 4
_base$ = -8						; size = 4
tv673 = -4						; size = 4
tv446 = -4						; size = 4
_extra$ = -4						; size = 4
@gen_bitlen@8 PROC NEAR					; COMDAT
; _s$ = eax
; _desc$ = ecx

; 494  : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H

; 495  :     ct_data *tree        = desc->dyn_tree;
; 496  :     int max_code         = desc->max_code;

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	89 54 24 14	 mov	 DWORD PTR _max_code$[esp+32], edx
  0000a	53		 push	 ebx
  0000b	8b 19		 mov	 ebx, DWORD PTR [ecx]

; 497  :     const ct_data *stree = desc->stat_desc->static_tree;

  0000d	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 498  :     const intf *extra    = desc->stat_desc->extra_bits;

  00010	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00013	89 54 24 20	 mov	 DWORD PTR _extra$[esp+36], edx

; 499  :     int base             = desc->stat_desc->extra_base;

  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	89 54 24 1c	 mov	 DWORD PTR _base$[esp+36], edx

; 500  :     int max_length       = desc->stat_desc->max_length;
; 501  :     int h;              /* heap index */
; 502  :     int n, m;           /* iterate over the tree elements */
; 503  :     int bits;           /* bit length */
; 504  :     int xbits;          /* extra bits */
; 505  :     ush f;              /* frequency */
; 506  :     int overflow = 0;   /* number of elements with bit length too large */
; 507  : 
; 508  :     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

  0001e	33 d2		 xor	 edx, edx
  00020	55		 push	 ebp
  00021	8b 29		 mov	 ebp, DWORD PTR [ecx]
  00023	56		 push	 esi
  00024	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00027	89 90 34 0b 00
	00		 mov	 DWORD PTR [eax+2868], edx
  0002d	89 90 38 0b 00
	00		 mov	 DWORD PTR [eax+2872], edx
  00033	89 90 3c 0b 00
	00		 mov	 DWORD PTR [eax+2876], edx
  00039	89 90 40 0b 00
	00		 mov	 DWORD PTR [eax+2880], edx
  0003f	89 90 44 0b 00
	00		 mov	 DWORD PTR [eax+2884], edx
  00045	89 90 48 0b 00
	00		 mov	 DWORD PTR [eax+2888], edx
  0004b	89 90 4c 0b 00
	00		 mov	 DWORD PTR [eax+2892], edx
  00051	89 90 50 0b 00
	00		 mov	 DWORD PTR [eax+2896], edx

; 509  : 
; 510  :     /* In a first pass, compute the optimal bit lengths (which may
; 511  :      * overflow in the case of the bit length tree).
; 512  :      */
; 513  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

  00057	8b 90 4c 14 00
	00		 mov	 edx, DWORD PTR [eax+5196]
  0005d	8b 94 90 54 0b
	00 00		 mov	 edx, DWORD PTR [eax+edx*4+2900]
  00064	33 c9		 xor	 ecx, ecx
  00066	57		 push	 edi
  00067	66 89 4c 93 02	 mov	 WORD PTR [ebx+edx*4+2], cx

; 514  : 
; 515  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  0006c	8b b8 4c 14 00
	00		 mov	 edi, DWORD PTR [eax+5196]
  00072	47		 inc	 edi
  00073	81 ff 3d 02 00
	00		 cmp	 edi, 573		; 0000023dH
  00079	89 74 24 1c	 mov	 DWORD PTR _max_length$[esp+48], esi
  0007d	89 4c 24 18	 mov	 DWORD PTR _overflow$[esp+48], ecx
  00081	0f 8d a4 01 00
	00		 jge	 $L1936
  00087	8d 8c b8 54 0b
	00 00		 lea	 ecx, DWORD PTR [eax+edi*4+2900]
  0008e	89 4c 24 14	 mov	 DWORD PTR tv599[esp+48], ecx
  00092	b9 3d 02 00 00	 mov	 ecx, 573		; 0000023dH
  00097	2b cf		 sub	 ecx, edi
  00099	03 f9		 add	 edi, ecx
  0009b	89 4c 24 20	 mov	 DWORD PTR tv181[esp+48], ecx
  0009f	89 7c 24 10	 mov	 DWORD PTR _h$[esp+48], edi
  000a3	eb 0b		 jmp	 SHORT $L1917
$L2572:
  000a5	8b 74 24 1c	 mov	 esi, DWORD PTR _max_length$[esp+48]
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$L1917:

; 516  :         n = s->heap[h];

  000b0	8b 54 24 14	 mov	 edx, DWORD PTR tv599[esp+48]
  000b4	8b 12		 mov	 edx, DWORD PTR [edx]

; 517  :         bits = tree[tree[n].Dad].Len + 1;

  000b6	0f b7 4c 93 02	 movzx	 ecx, WORD PTR [ebx+edx*4+2]
  000bb	0f b7 4c 8b 02	 movzx	 ecx, WORD PTR [ebx+ecx*4+2]
  000c0	41		 inc	 ecx

; 518  :         if (bits > max_length) bits = max_length, overflow++;

  000c1	3b ce		 cmp	 ecx, esi
  000c3	7e 06		 jle	 SHORT $L1920
  000c5	8b ce		 mov	 ecx, esi
  000c7	ff 44 24 18	 inc	 DWORD PTR _overflow$[esp+48]
$L1920:

; 519  :         tree[n].Len = (ush)bits;
; 520  :         /* We overwrite tree[n].Dad which is no longer needed */
; 521  : 
; 522  :         if (n > max_code) continue; /* not a leaf node */

  000cb	3b 54 24 24	 cmp	 edx, DWORD PTR _max_code$[esp+48]
  000cf	66 89 4c 93 02	 mov	 WORD PTR [ebx+edx*4+2], cx
  000d4	7f 4c		 jg	 SHORT $L1918

; 523  : 
; 524  :         s->bl_count[bits]++;
; 525  :         xbits = 0;
; 526  :         if (n >= base) xbits = extra[n-base];

  000d6	8b 7c 24 28	 mov	 edi, DWORD PTR _base$[esp+48]
  000da	66 ff 84 48 34
	0b 00 00	 inc	 WORD PTR [eax+ecx*2+2868]
  000e2	33 f6		 xor	 esi, esi
  000e4	3b d7		 cmp	 edx, edi
  000e6	7c 0b		 jl	 SHORT $L1923
  000e8	8b f2		 mov	 esi, edx
  000ea	2b f7		 sub	 esi, edi
  000ec	8b 7c 24 2c	 mov	 edi, DWORD PTR _extra$[esp+48]
  000f0	8b 34 b7	 mov	 esi, DWORD PTR [edi+esi*4]
$L1923:

; 527  :         f = tree[n].Freq;
; 528  :         s->opt_len += (ulg)f * (bits + xbits);

  000f3	0f b7 3c 93	 movzx	 edi, WORD PTR [ebx+edx*4]
  000f7	03 ce		 add	 ecx, esi
  000f9	0f af cf	 imul	 ecx, edi
  000fc	01 88 a0 16 00
	00		 add	 DWORD PTR [eax+5792], ecx

; 529  :         if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);

  00102	85 ed		 test	 ebp, ebp
  00104	74 18		 je	 SHORT $L2569
  00106	0f b7 54 95 02	 movzx	 edx, WORD PTR [ebp+edx*4+2]
  0010b	8b 88 a4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5796]
  00111	03 d6		 add	 edx, esi
  00113	0f af d7	 imul	 edx, edi
  00116	03 ca		 add	 ecx, edx
  00118	89 88 a4 16 00
	00		 mov	 DWORD PTR [eax+5796], ecx
$L2569:
  0011e	8b 7c 24 10	 mov	 edi, DWORD PTR _h$[esp+48]
$L1918:

; 514  : 
; 515  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  00122	8b 54 24 14	 mov	 edx, DWORD PTR tv599[esp+48]
  00126	8b 4c 24 20	 mov	 ecx, DWORD PTR tv181[esp+48]
  0012a	83 c2 04	 add	 edx, 4
  0012d	49		 dec	 ecx
  0012e	89 54 24 14	 mov	 DWORD PTR tv599[esp+48], edx
  00132	89 4c 24 20	 mov	 DWORD PTR tv181[esp+48], ecx
  00136	0f 85 69 ff ff
	ff		 jne	 $L2572

; 530  :     }
; 531  :     if (overflow == 0) return;

  0013c	8b 6c 24 18	 mov	 ebp, DWORD PTR _overflow$[esp+48]
  00140	85 ed		 test	 ebp, ebp
  00142	0f 84 e3 00 00
	00		 je	 $L1936
  00148	8b 4c 24 1c	 mov	 ecx, DWORD PTR _max_length$[esp+48]

; 548  : 
; 549  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 550  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 551  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 552  :      * from 'ar' written by Haruhiko Okumura.)
; 553  :      */
; 554  :     for (bits = max_length; bits != 0; bits--) {

  0014c	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  0014f	89 54 24 2c	 mov	 DWORD PTR tv446[esp+48], edx
  00153	8d b4 48 34 0b
	00 00		 lea	 esi, DWORD PTR [eax+ecx*2+2868]
  0015a	8d 9b 00 00 00
	00		 npad	 6
$L1928:
  00160	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv446[esp+48]
  00164	66 83 bc 48 34
	0b 00 00 00	 cmp	 WORD PTR [eax+ecx*2+2868], 0
  0016d	8d 94 48 34 0b
	00 00		 lea	 edx, DWORD PTR [eax+ecx*2+2868]
  00174	75 0a		 jne	 SHORT $L1933
$L1932:

; 532  : 
; 533  :     Trace((stderr,"\nbit length overflow\n"));
; 534  :     /* This happens for example on obj2 and pic of the Calgary corpus */
; 535  : 
; 536  :     /* Find the first bit length which could increase: */
; 537  :     do {
; 538  :         bits = max_length-1;
; 539  :         while (s->bl_count[bits] == 0) bits--;

  00176	83 ea 02	 sub	 edx, 2
  00179	49		 dec	 ecx
  0017a	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  0017e	74 f6		 je	 SHORT $L1932
$L1933:

; 540  :         s->bl_count[bits]--;      /* move one leaf down the tree */

  00180	66 ff 8c 48 34
	0b 00 00	 dec	 WORD PTR [eax+ecx*2+2868]

; 541  :         s->bl_count[bits+1] += 2; /* move one overflow item as its brother */

  00188	66 83 84 48 36
	0b 00 00 02	 add	 WORD PTR [eax+ecx*2+2870], 2

; 542  :         s->bl_count[max_length]--;

  00191	66 ff 0e	 dec	 WORD PTR [esi]

; 543  :         /* The brother of the overflow item also moves one step up,
; 544  :          * but this does not affect bl_count[max_length]
; 545  :          */
; 546  :         overflow -= 2;

  00194	83 ed 02	 sub	 ebp, 2

; 547  :     } while (overflow > 0);

  00197	85 ed		 test	 ebp, ebp
  00199	7f c5		 jg	 SHORT $L1928

; 548  : 
; 549  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 550  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 551  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 552  :      * from 'ar' written by Haruhiko Okumura.)
; 553  :      */
; 554  :     for (bits = max_length; bits != 0; bits--) {

  0019b	8b 54 24 1c	 mov	 edx, DWORD PTR _max_length$[esp+48]
  0019f	85 d2		 test	 edx, edx
  001a1	0f 84 84 00 00
	00		 je	 $L1936
  001a7	89 74 24 20	 mov	 DWORD PTR tv711[esp+48], esi
  001ab	eb 03 8d 49 00	 npad	 5
$L1934:

; 555  :         n = s->bl_count[bits];

  001b0	0f b7 36	 movzx	 esi, WORD PTR [esi]

; 556  :         while (n != 0) {

  001b3	85 f6		 test	 esi, esi
  001b5	89 74 24 1c	 mov	 DWORD PTR _n$[esp+48], esi
  001b9	74 60		 je	 SHORT $L1935

; 555  :         n = s->bl_count[bits];

  001bb	8d ac b8 54 0b
	00 00		 lea	 ebp, DWORD PTR [eax+edi*4+2900]
$L1938:

; 557  :             m = s->heap[--h];

  001c2	8b 7c 24 10	 mov	 edi, DWORD PTR _h$[esp+48]
  001c6	8b 4d fc	 mov	 ecx, DWORD PTR [ebp-4]
  001c9	4f		 dec	 edi
  001ca	83 ed 04	 sub	 ebp, 4
  001cd	89 7c 24 10	 mov	 DWORD PTR _h$[esp+48], edi

; 558  :             if (m > max_code) continue;

  001d1	3b 4c 24 24	 cmp	 ecx, DWORD PTR _max_code$[esp+48]
  001d5	89 6c 24 2c	 mov	 DWORD PTR tv673[esp+48], ebp
  001d9	7f 38		 jg	 SHORT $L2567

; 559  :             if (tree[m].Len != (unsigned) bits) {

  001db	0f b7 7c 8b 02	 movzx	 edi, WORD PTR [ebx+ecx*4+2]
  001e0	3b fa		 cmp	 edi, edx
  001e2	8d 74 8b 02	 lea	 esi, DWORD PTR [ebx+ecx*4+2]
  001e6	74 20		 je	 SHORT $L1942

; 560  :                 Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
; 561  :                 s->opt_len += ((long)bits - (long)tree[m].Len)
; 562  :                               *(long)tree[m].Freq;

  001e8	0f b7 0c 8b	 movzx	 ecx, WORD PTR [ebx+ecx*4]
  001ec	8b ea		 mov	 ebp, edx
  001ee	2b ef		 sub	 ebp, edi
  001f0	0f af e9	 imul	 ebp, ecx
  001f3	8b 88 a0 16 00
	00		 mov	 ecx, DWORD PTR [eax+5792]
  001f9	03 cd		 add	 ecx, ebp

; 563  :                 tree[m].Len = (ush)bits;

  001fb	8b 6c 24 2c	 mov	 ebp, DWORD PTR tv673[esp+48]
  001ff	89 88 a0 16 00
	00		 mov	 DWORD PTR [eax+5792], ecx
  00205	66 89 16	 mov	 WORD PTR [esi], dx
$L1942:

; 564  :             }
; 565  :             n--;

  00208	8b 4c 24 1c	 mov	 ecx, DWORD PTR _n$[esp+48]
  0020c	49		 dec	 ecx
  0020d	89 4c 24 1c	 mov	 DWORD PTR _n$[esp+48], ecx
  00211	8b f1		 mov	 esi, ecx
$L2567:

; 556  :         while (n != 0) {

  00213	85 f6		 test	 esi, esi
  00215	75 ab		 jne	 SHORT $L1938
  00217	8b 7c 24 10	 mov	 edi, DWORD PTR _h$[esp+48]
$L1935:

; 548  : 
; 549  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 550  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 551  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 552  :      * from 'ar' written by Haruhiko Okumura.)
; 553  :      */
; 554  :     for (bits = max_length; bits != 0; bits--) {

  0021b	8b 74 24 20	 mov	 esi, DWORD PTR tv711[esp+48]
  0021f	4a		 dec	 edx
  00220	83 ee 02	 sub	 esi, 2
  00223	85 d2		 test	 edx, edx
  00225	89 74 24 20	 mov	 DWORD PTR tv711[esp+48], esi
  00229	75 85		 jne	 SHORT $L1934
$L1936:
  0022b	5f		 pop	 edi
  0022c	5e		 pop	 esi
  0022d	5d		 pop	 ebp
  0022e	5b		 pop	 ebx

; 566  :         }
; 567  :     }
; 568  : }

  0022f	83 c4 20	 add	 esp, 32			; 00000020H
  00232	c3		 ret	 0
@gen_bitlen@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @scan_tree@12
_TEXT	SEGMENT
tv295 = -4						; size = 4
_s$ = 8							; size = 4
@scan_tree@12 PROC NEAR					; COMDAT
; _tree$ = eax
; _max_code$ = ecx

; 711  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 712  :     int n;                     /* iterates over all tree elements */
; 713  :     int prevlen = -1;          /* last emitted length */
; 714  :     int curlen;                /* length of current code */
; 715  :     int nextlen = tree[0].Len; /* length of next code */

  00005	0f b7 78 02	 movzx	 edi, WORD PTR [eax+2]
  00009	83 cd ff	 or	 ebp, -1

; 716  :     int count = 0;             /* repeat count of the current code */

  0000c	33 f6		 xor	 esi, esi

; 717  :     int max_count = 7;         /* max repeat count */
; 718  :     int min_count = 4;         /* min repeat count */
; 719  : 
; 720  :     if (nextlen == 0) max_count = 138, min_count = 3;

  0000e	85 ff		 test	 edi, edi
  00010	8b d9		 mov	 ebx, ecx
  00012	b9 07 00 00 00	 mov	 ecx, 7
  00017	ba 04 00 00 00	 mov	 edx, 4
  0001c	75 0a		 jne	 SHORT $L2006
  0001e	b9 8a 00 00 00	 mov	 ecx, 138		; 0000008aH
  00023	ba 03 00 00 00	 mov	 edx, 3
$L2006:

; 721  :     tree[max_code+1].Len = (ush)0xffff; /* guard */
; 722  : 
; 723  :     for (n = 0; n <= max_code; n++) {

  00028	85 db		 test	 ebx, ebx
  0002a	66 c7 44 98 06
	ff ff		 mov	 WORD PTR [eax+ebx*4+6], 65535 ; 0000ffffH
  00031	0f 8c 9b 00 00
	00		 jl	 $L2010
  00037	83 c0 06	 add	 eax, 6
  0003a	89 44 24 10	 mov	 DWORD PTR tv295[esp+20], eax
  0003e	43		 inc	 ebx
  0003f	90		 npad	 1
$L2008:

; 724  :         curlen = nextlen; nextlen = tree[n+1].Len;

  00040	8b c7		 mov	 eax, edi
  00042	8b 7c 24 10	 mov	 edi, DWORD PTR tv295[esp+20]
  00046	0f b7 3f	 movzx	 edi, WORD PTR [edi]

; 725  :         if (++count < max_count && curlen == nextlen) {

  00049	46		 inc	 esi
  0004a	3b f1		 cmp	 esi, ecx
  0004c	7d 04		 jge	 SHORT $L2011
  0004e	3b c7		 cmp	 eax, edi
  00050	74 6e		 je	 SHORT $L2009
$L2011:

; 726  :             continue;
; 727  :         } else if (count < min_count) {

  00052	3b f2		 cmp	 esi, edx

; 728  :             s->bl_tree[curlen].Freq += count;

  00054	8b 4c 24 18	 mov	 ecx, DWORD PTR _s$[esp+16]
  00058	7d 0a		 jge	 SHORT $L2013
  0005a	66 01 b4 81 74
	0a 00 00	 add	 WORD PTR [ecx+eax*4+2676], si

; 729  :         } else if (curlen != 0) {

  00062	eb 2e		 jmp	 SHORT $L2019
$L2013:
  00064	85 c0		 test	 eax, eax
  00066	74 15		 je	 SHORT $L2015

; 730  :             if (curlen != prevlen) s->bl_tree[curlen].Freq++;

  00068	3b c5		 cmp	 eax, ebp
  0006a	74 08		 je	 SHORT $L2016
  0006c	66 ff 84 81 74
	0a 00 00	 inc	 WORD PTR [ecx+eax*4+2676]
$L2016:

; 731  :             s->bl_tree[REP_3_6].Freq++;

  00074	66 ff 81 b4 0a
	00 00		 inc	 WORD PTR [ecx+2740]

; 732  :         } else if (count <= 10) {

  0007b	eb 15		 jmp	 SHORT $L2019
$L2015:
  0007d	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00080	7f 09		 jg	 SHORT $L2018

; 733  :             s->bl_tree[REPZ_3_10].Freq++;

  00082	66 ff 81 b8 0a
	00 00		 inc	 WORD PTR [ecx+2744]

; 734  :         } else {

  00089	eb 07		 jmp	 SHORT $L2019
$L2018:

; 735  :             s->bl_tree[REPZ_11_138].Freq++;

  0008b	66 ff 81 bc 0a
	00 00		 inc	 WORD PTR [ecx+2748]
$L2019:

; 736  :         }
; 737  :         count = 0; prevlen = curlen;

  00092	33 f6		 xor	 esi, esi

; 738  :         if (nextlen == 0) {

  00094	85 ff		 test	 edi, edi
  00096	8b e8		 mov	 ebp, eax
  00098	75 0c		 jne	 SHORT $L2020

; 739  :             max_count = 138, min_count = 3;

  0009a	b9 8a 00 00 00	 mov	 ecx, 138		; 0000008aH
  0009f	ba 03 00 00 00	 mov	 edx, 3

; 740  :         } else if (curlen == nextlen) {

  000a4	eb 1a		 jmp	 SHORT $L2009
$L2020:
  000a6	3b c7		 cmp	 eax, edi
  000a8	75 0c		 jne	 SHORT $L2022

; 741  :             max_count = 6, min_count = 3;

  000aa	b9 06 00 00 00	 mov	 ecx, 6
  000af	ba 03 00 00 00	 mov	 edx, 3

; 742  :         } else {

  000b4	eb 0a		 jmp	 SHORT $L2009
$L2022:

; 743  :             max_count = 7, min_count = 4;

  000b6	b9 07 00 00 00	 mov	 ecx, 7
  000bb	ba 04 00 00 00	 mov	 edx, 4
$L2009:
  000c0	8b 44 24 10	 mov	 eax, DWORD PTR tv295[esp+20]
  000c4	83 c0 04	 add	 eax, 4
  000c7	4b		 dec	 ebx
  000c8	89 44 24 10	 mov	 DWORD PTR tv295[esp+20], eax
  000cc	0f 85 6e ff ff
	ff		 jne	 $L2008
$L2010:
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5d		 pop	 ebp
  000d5	5b		 pop	 ebx

; 744  :         }
; 745  :     }
; 746  : }

  000d6	59		 pop	 ecx
  000d7	c2 04 00	 ret	 4
@scan_tree@12 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @send_tree@12
_TEXT	SEGMENT
_nextlen$ = -12						; size = 4
tv1251 = -8						; size = 4
tv697 = -4						; size = 4
_count$ = 8						; size = 4
_max_code$ = 8						; size = 4
@send_tree@12 PROC NEAR					; COMDAT
; _s$ = eax
; _tree$ = ecx

; 756  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	8b 6c 24 18	 mov	 ebp, DWORD PTR _max_code$[esp+16]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx

; 757  :     int n;                     /* iterates over all tree elements */
; 758  :     int prevlen = -1;          /* last emitted length */
; 759  :     int curlen;                /* length of current code */
; 760  :     int nextlen = tree[0].Len; /* length of next code */

  0000d	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00011	89 4c 24 10	 mov	 DWORD PTR _nextlen$[esp+28], ecx

; 761  :     int count = 0;             /* repeat count of the current code */

  00015	33 f6		 xor	 esi, esi
  00017	83 cb ff	 or	 ebx, -1

; 762  :     int max_count = 7;         /* max repeat count */
; 763  :     int min_count = 4;         /* min repeat count */
; 764  : 
; 765  :     /* tree[max_code+1].Len = -1; */  /* guard already set */
; 766  :     if (nextlen == 0) max_count = 138, min_count = 3;

  0001a	39 74 24 10	 cmp	 DWORD PTR _nextlen$[esp+28], esi
  0001e	b9 07 00 00 00	 mov	 ecx, 7
  00023	ba 04 00 00 00	 mov	 edx, 4
  00028	75 0a		 jne	 SHORT $L2584
  0002a	b9 8a 00 00 00	 mov	 ecx, 138		; 0000008aH
  0002f	ba 03 00 00 00	 mov	 edx, 3
$L2584:

; 767  : 
; 768  :     for (n = 0; n <= max_code; n++) {

  00034	85 ed		 test	 ebp, ebp
  00036	0f 8c c6 04 00
	00		 jl	 $L2039
  0003c	83 c7 06	 add	 edi, 6
  0003f	45		 inc	 ebp
  00040	89 7c 24 14	 mov	 DWORD PTR tv1251[esp+28], edi
  00044	89 6c 24 18	 mov	 DWORD PTR tv697[esp+28], ebp
  00048	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L2585:

; 769  :         curlen = nextlen; nextlen = tree[n+1].Len;

  00050	8b 7c 24 14	 mov	 edi, DWORD PTR tv1251[esp+28]
  00054	0f b7 3f	 movzx	 edi, WORD PTR [edi]
  00057	8b 6c 24 10	 mov	 ebp, DWORD PTR _nextlen$[esp+28]

; 770  :         if (++count < max_count && curlen == nextlen) {

  0005b	46		 inc	 esi
  0005c	3b f1		 cmp	 esi, ecx
  0005e	89 7c 24 10	 mov	 DWORD PTR _nextlen$[esp+28], edi
  00062	89 74 24 20	 mov	 DWORD PTR _count$[esp+24], esi
  00066	7d 08		 jge	 SHORT $L2040
  00068	3b ef		 cmp	 ebp, edi
  0006a	0f 84 78 04 00
	00		 je	 $L2038
$L2040:

; 771  :             continue;
; 772  :         } else if (count < min_count) {

  00070	3b f2		 cmp	 esi, edx
  00072	0f 8d a7 00 00
	00		 jge	 $L2042
  00078	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L2043:

; 773  :             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

  00080	0f b7 bc a8 76
	0a 00 00	 movzx	 edi, WORD PTR [eax+ebp*4+2678]
  00088	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  0008e	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00093	2b d7		 sub	 edx, edi
  00095	3b ca		 cmp	 ecx, edx
  00097	7e 5c		 jle	 SHORT $L2049
  00099	0f b7 b4 a8 74
	0a 00 00	 movzx	 esi, WORD PTR [eax+ebp*4+2676]
  000a1	8b d6		 mov	 edx, esi
  000a3	d3 e2		 shl	 edx, cl
  000a5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a8	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  000af	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000b2	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  000b8	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  000bb	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000be	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  000c4	42		 inc	 edx
  000c5	89 50 14	 mov	 DWORD PTR [eax+20], edx
  000c8	8b ca		 mov	 ecx, edx
  000ca	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000cd	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  000d0	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000d3	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  000d9	41		 inc	 ecx
  000da	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  000dd	b1 10		 mov	 cl, 16			; 00000010H
  000df	2a ca		 sub	 cl, dl
  000e1	66 d3 ee	 shr	 si, cl
  000e4	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  000e8	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  000ef	8b 74 24 20	 mov	 esi, DWORD PTR _count$[esp+24]
  000f3	eb 14		 jmp	 SHORT $L2588
$L2049:
  000f5	66 8b 94 a8 74
	0a 00 00	 mov	 dx, WORD PTR [eax+ebp*4+2676]
  000fd	66 d3 e2	 shl	 dx, cl
  00100	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00107	03 cf		 add	 ecx, edi
$L2588:
  00109	4e		 dec	 esi
  0010a	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
  00110	89 74 24 20	 mov	 DWORD PTR _count$[esp+24], esi
  00114	0f 85 66 ff ff
	ff		 jne	 $L2043

; 774  : 
; 775  :         } else if (curlen != 0) {

  0011a	e9 97 03 00 00	 jmp	 $L2147
$L2042:
  0011f	85 ed		 test	 ebp, ebp
  00121	0f 84 99 01 00
	00		 je	 $L2059

; 776  :             if (curlen != prevlen) {

  00127	3b eb		 cmp	 ebp, ebx
  00129	0f 84 94 00 00
	00		 je	 $L2586

; 777  :                 send_code(s, curlen, s->bl_tree); count--;

  0012f	0f b7 bc a8 76
	0a 00 00	 movzx	 edi, WORD PTR [eax+ebp*4+2678]
  00137	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  0013d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00142	2b d7		 sub	 edx, edi
  00144	3b ca		 cmp	 ecx, edx
  00146	7e 5c		 jle	 SHORT $L2064
  00148	0f b7 b4 a8 74
	0a 00 00	 movzx	 esi, WORD PTR [eax+ebp*4+2676]
  00150	8b d6		 mov	 edx, esi
  00152	d3 e2		 shl	 edx, cl
  00154	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00157	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  0015e	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00161	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00167	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0016a	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0016d	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00173	42		 inc	 edx
  00174	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00177	8b ca		 mov	 ecx, edx
  00179	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017c	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0017f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00182	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00188	41		 inc	 ecx
  00189	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0018c	b1 10		 mov	 cl, 16			; 00000010H
  0018e	2a ca		 sub	 cl, dl
  00190	66 d3 ee	 shr	 si, cl
  00193	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  00197	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  0019e	8b 74 24 20	 mov	 esi, DWORD PTR _count$[esp+24]
  001a2	eb 14		 jmp	 SHORT $L2589
$L2064:
  001a4	66 8b 94 a8 74
	0a 00 00	 mov	 dx, WORD PTR [eax+ebp*4+2676]
  001ac	66 d3 e2	 shl	 dx, cl
  001af	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  001b6	03 cf		 add	 ecx, edi
$L2589:
  001b8	4e		 dec	 esi
  001b9	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
  001bf	89 74 24 20	 mov	 DWORD PTR _count$[esp+24], esi
$L2586:

; 778  :             }
; 779  :             Assert(count >= 3 && count <= 6, " 3_6?");
; 780  :             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

  001c3	0f b7 b8 b6 0a
	00 00		 movzx	 edi, WORD PTR [eax+2742]
  001ca	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  001d0	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  001d5	2b d7		 sub	 edx, edi
  001d7	3b ca		 cmp	 ecx, edx
  001d9	7e 5b		 jle	 SHORT $L2076
  001db	0f b7 b0 b4 0a
	00 00		 movzx	 esi, WORD PTR [eax+2740]
  001e2	8b d6		 mov	 edx, esi
  001e4	d3 e2		 shl	 edx, cl
  001e6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001e9	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  001f0	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  001f3	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  001f9	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  001fc	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  001ff	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00205	42		 inc	 edx
  00206	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00209	8b ca		 mov	 ecx, edx
  0020b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0020e	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00211	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00214	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  0021a	41		 inc	 ecx
  0021b	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0021e	b1 10		 mov	 cl, 16			; 00000010H
  00220	2a ca		 sub	 cl, dl
  00222	66 d3 ee	 shr	 si, cl
  00225	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  00229	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  00230	8b 74 24 20	 mov	 esi, DWORD PTR _count$[esp+24]
  00234	eb 13		 jmp	 SHORT $L2590
$L2076:
  00236	66 8b 90 b4 0a
	00 00		 mov	 dx, WORD PTR [eax+2740]
  0023d	66 d3 e2	 shl	 dx, cl
  00240	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00247	03 cf		 add	 ecx, edi
$L2590:
  00249	83 c6 fd	 add	 esi, -3			; fffffffdH
  0024c	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  0024f	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
  00255	7e 58		 jle	 SHORT $L2088
  00257	8b d6		 mov	 edx, esi
  00259	d3 e2		 shl	 edx, cl
  0025b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0025e	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00265	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00268	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  0026e	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00271	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00274	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  0027a	42		 inc	 edx
  0027b	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0027e	8b ca		 mov	 ecx, edx
  00280	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00283	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00286	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00289	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  0028f	41		 inc	 ecx
  00290	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00293	b1 10		 mov	 cl, 16			; 00000010H
  00295	2a ca		 sub	 cl, dl
  00297	66 d3 ee	 shr	 si, cl
  0029a	83 c2 f2	 add	 edx, -14		; fffffff2H
  0029d	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  002a3	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  002aa	e9 07 02 00 00	 jmp	 $L2147
$L2088:
  002af	d3 e6		 shl	 esi, cl
  002b1	66 09 b0 b0 16
	00 00		 or	 WORD PTR [eax+5808], si
  002b8	83 c1 02	 add	 ecx, 2

; 781  : 
; 782  :         } else if (count <= 10) {

  002bb	e9 f0 01 00 00	 jmp	 $L2591
$L2059:
  002c0	83 fe 0a	 cmp	 esi, 10			; 0000000aH

; 783  :             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

  002c3	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  002c9	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  002ce	0f 8f f2 00 00
	00		 jg	 $L2098
  002d4	0f b7 b8 ba 0a
	00 00		 movzx	 edi, WORD PTR [eax+2746]
  002db	2b d7		 sub	 edx, edi
  002dd	3b ca		 cmp	 ecx, edx
  002df	7e 5b		 jle	 SHORT $L2102
  002e1	0f b7 b0 b8 0a
	00 00		 movzx	 esi, WORD PTR [eax+2744]
  002e8	8b d6		 mov	 edx, esi
  002ea	d3 e2		 shl	 edx, cl
  002ec	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002ef	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  002f6	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  002f9	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  002ff	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00302	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00305	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  0030b	42		 inc	 edx
  0030c	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0030f	8b ca		 mov	 ecx, edx
  00311	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00314	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00317	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0031a	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00320	41		 inc	 ecx
  00321	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00324	b1 10		 mov	 cl, 16			; 00000010H
  00326	2a ca		 sub	 cl, dl
  00328	66 d3 ee	 shr	 si, cl
  0032b	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  0032f	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  00336	8b 74 24 20	 mov	 esi, DWORD PTR _count$[esp+24]
  0033a	eb 13		 jmp	 SHORT $L2592
$L2102:
  0033c	66 8b 90 b8 0a
	00 00		 mov	 dx, WORD PTR [eax+2744]
  00343	66 d3 e2	 shl	 dx, cl
  00346	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  0034d	03 cf		 add	 ecx, edi
$L2592:
  0034f	83 c6 fd	 add	 esi, -3			; fffffffdH
  00352	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00355	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
  0035b	7e 58		 jle	 SHORT $L2114
  0035d	8b d6		 mov	 edx, esi
  0035f	d3 e2		 shl	 edx, cl
  00361	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00364	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  0036b	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0036e	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00374	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00377	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0037a	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00380	42		 inc	 edx
  00381	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00384	8b ca		 mov	 ecx, edx
  00386	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00389	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0038c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0038f	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00395	41		 inc	 ecx
  00396	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00399	b1 10		 mov	 cl, 16			; 00000010H
  0039b	2a ca		 sub	 cl, dl
  0039d	66 d3 ee	 shr	 si, cl
  003a0	83 c2 f3	 add	 edx, -13		; fffffff3H
  003a3	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  003a9	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  003b0	e9 01 01 00 00	 jmp	 $L2147
$L2114:
  003b5	d3 e6		 shl	 esi, cl
  003b7	66 09 b0 b0 16
	00 00		 or	 WORD PTR [eax+5808], si
  003be	83 c1 03	 add	 ecx, 3

; 784  : 
; 785  :         } else {

  003c1	e9 ea 00 00 00	 jmp	 $L2591
$L2098:

; 786  :             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);

  003c6	0f b7 b8 be 0a
	00 00		 movzx	 edi, WORD PTR [eax+2750]
  003cd	2b d7		 sub	 edx, edi
  003cf	3b ca		 cmp	 ecx, edx
  003d1	7e 5b		 jle	 SHORT $L2127
  003d3	0f b7 b0 bc 0a
	00 00		 movzx	 esi, WORD PTR [eax+2748]
  003da	8b d6		 mov	 edx, esi
  003dc	d3 e2		 shl	 edx, cl
  003de	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003e1	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  003e8	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  003eb	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  003f1	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  003f4	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  003f7	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  003fd	42		 inc	 edx
  003fe	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00401	8b ca		 mov	 ecx, edx
  00403	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00406	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00409	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0040c	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00412	41		 inc	 ecx
  00413	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00416	b1 10		 mov	 cl, 16			; 00000010H
  00418	2a ca		 sub	 cl, dl
  0041a	66 d3 ee	 shr	 si, cl
  0041d	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  00421	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  00428	8b 74 24 20	 mov	 esi, DWORD PTR _count$[esp+24]
  0042c	eb 13		 jmp	 SHORT $L2593
$L2127:
  0042e	66 8b 90 bc 0a
	00 00		 mov	 dx, WORD PTR [eax+2748]
  00435	66 d3 e2	 shl	 dx, cl
  00438	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  0043f	03 cf		 add	 ecx, edi
$L2593:
  00441	83 c6 f5	 add	 esi, -11		; fffffff5H
  00444	83 f9 09	 cmp	 ecx, 9
  00447	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
  0044d	7e 55		 jle	 SHORT $L2139
  0044f	8b d6		 mov	 edx, esi
  00451	d3 e2		 shl	 edx, cl
  00453	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00456	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  0045d	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00460	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00466	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00469	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0046c	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00472	42		 inc	 edx
  00473	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00476	8b ca		 mov	 ecx, edx
  00478	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0047b	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0047e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00481	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00487	41		 inc	 ecx
  00488	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0048b	b1 10		 mov	 cl, 16			; 00000010H
  0048d	2a ca		 sub	 cl, dl
  0048f	66 d3 ee	 shr	 si, cl
  00492	83 c2 f7	 add	 edx, -9			; fffffff7H
  00495	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  0049b	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  004a2	eb 12		 jmp	 SHORT $L2147
$L2139:
  004a4	d3 e6		 shl	 esi, cl
  004a6	66 09 b0 b0 16
	00 00		 or	 WORD PTR [eax+5808], si
  004ad	83 c1 07	 add	 ecx, 7
$L2591:
  004b0	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2147:

; 787  :         }
; 788  :         count = 0; prevlen = curlen;
; 789  :         if (nextlen == 0) {

  004b6	8b 4c 24 10	 mov	 ecx, DWORD PTR _nextlen$[esp+28]
  004ba	33 f6		 xor	 esi, esi
  004bc	85 c9		 test	 ecx, ecx
  004be	8b dd		 mov	 ebx, ebp
  004c0	75 0c		 jne	 SHORT $L2148

; 790  :             max_count = 138, min_count = 3;

  004c2	b9 8a 00 00 00	 mov	 ecx, 138		; 0000008aH
  004c7	ba 03 00 00 00	 mov	 edx, 3

; 791  :         } else if (curlen == nextlen) {

  004cc	eb 1a		 jmp	 SHORT $L2038
$L2148:
  004ce	3b e9		 cmp	 ebp, ecx
  004d0	75 0c		 jne	 SHORT $L2150

; 792  :             max_count = 6, min_count = 3;

  004d2	b9 06 00 00 00	 mov	 ecx, 6
  004d7	ba 03 00 00 00	 mov	 edx, 3

; 793  :         } else {

  004dc	eb 0a		 jmp	 SHORT $L2038
$L2150:

; 794  :             max_count = 7, min_count = 4;

  004de	b9 07 00 00 00	 mov	 ecx, 7
  004e3	ba 04 00 00 00	 mov	 edx, 4
$L2038:
  004e8	8b 6c 24 14	 mov	 ebp, DWORD PTR tv1251[esp+28]
  004ec	8b 7c 24 18	 mov	 edi, DWORD PTR tv697[esp+28]
  004f0	83 c5 04	 add	 ebp, 4
  004f3	4f		 dec	 edi
  004f4	89 6c 24 14	 mov	 DWORD PTR tv1251[esp+28], ebp
  004f8	89 7c 24 18	 mov	 DWORD PTR tv697[esp+28], edi
  004fc	0f 85 4e fb ff
	ff		 jne	 $L2585
$L2039:
  00502	5f		 pop	 edi
  00503	5e		 pop	 esi
  00504	5d		 pop	 ebp
  00505	5b		 pop	 ebx

; 795  :         }
; 796  :     }
; 797  : }

  00506	83 c4 0c	 add	 esp, 12			; 0000000cH
  00509	c2 04 00	 ret	 4
@send_tree@12 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @send_all_trees@16
_TEXT	SEGMENT
_lcodes$ = 8						; size = 4
_dcodes$ = 12						; size = 4
tv576 = 16						; size = 4
tv575 = 16						; size = 4
tv574 = 16						; size = 4
_blcodes$ = 16						; size = 4
@send_all_trees@16 PROC NEAR				; COMDAT
; _s$ = eax

; 842  :     int rank;                    /* index in bl_order */
; 843  : 
; 844  :     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
; 845  :     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
; 846  :             "too many codes");
; 847  :     Tracev((stderr, "\nbl counts: "));
; 848  :     send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */

  00000	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  00006	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00009	53		 push	 ebx
  0000a	8b 5c 24 0c	 mov	 ebx, DWORD PTR _dcodes$[esp]
  0000e	55		 push	 ebp
  0000f	8b 6c 24 14	 mov	 ebp, DWORD PTR _blcodes$[esp+4]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	7e 67		 jle	 SHORT $L2173
  00017	8b 74 24 14	 mov	 esi, DWORD PTR _lcodes$[esp+12]
  0001b	81 c6 ff fe ff
	ff		 add	 esi, -257		; fffffeffH
  00021	8b d6		 mov	 edx, esi
  00023	d3 e2		 shl	 edx, cl
  00025	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00028	89 5c 24 1c	 mov	 DWORD PTR tv576[esp+12], ebx
  0002c	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00033	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00039	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003c	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0003f	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00042	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00048	42		 inc	 edx
  00049	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0004c	8b ca		 mov	 ecx, edx
  0004e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00051	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00054	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00057	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  0005d	8b 5c 24 1c	 mov	 ebx, DWORD PTR tv576[esp+12]
  00061	41		 inc	 ecx
  00062	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00065	b1 10		 mov	 cl, 16			; 00000010H
  00067	2a ca		 sub	 cl, dl
  00069	66 d3 ee	 shr	 si, cl
  0006c	83 c2 f5	 add	 edx, -11		; fffffff5H
  0006f	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  00075	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  0007c	eb 1c		 jmp	 SHORT $L2181
$L2173:
  0007e	8b 54 24 14	 mov	 edx, DWORD PTR _lcodes$[esp+12]
  00082	81 c2 ff fe ff
	ff		 add	 edx, -257		; fffffeffH
  00088	d3 e2		 shl	 edx, cl
  0008a	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00091	83 c1 05	 add	 ecx, 5
  00094	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2181:

; 849  :     send_bits(s, dcodes-1,   5);

  0009a	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  000a0	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  000a3	7e 60		 jle	 SHORT $L2185
  000a5	8d 73 ff	 lea	 esi, DWORD PTR [ebx-1]
  000a8	8b d6		 mov	 edx, esi
  000aa	d3 e2		 shl	 edx, cl
  000ac	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000af	89 5c 24 1c	 mov	 DWORD PTR tv575[esp+12], ebx
  000b3	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  000ba	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  000c0	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000c3	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  000c6	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000c9	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  000cf	42		 inc	 edx
  000d0	89 50 14	 mov	 DWORD PTR [eax+20], edx
  000d3	8b ca		 mov	 ecx, edx
  000d5	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000d8	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  000db	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000de	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  000e4	8b 5c 24 1c	 mov	 ebx, DWORD PTR tv575[esp+12]
  000e8	41		 inc	 ecx
  000e9	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  000ec	b1 10		 mov	 cl, 16			; 00000010H
  000ee	2a ca		 sub	 cl, dl
  000f0	66 d3 ee	 shr	 si, cl
  000f3	83 c2 f5	 add	 edx, -11		; fffffff5H
  000f6	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  000fc	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  00103	eb 15		 jmp	 SHORT $L2193
$L2185:
  00105	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  00108	d3 e2		 shl	 edx, cl
  0010a	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00111	83 c1 05	 add	 ecx, 5
  00114	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2193:

; 850  :     send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */

  0011a	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  00120	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  00123	7e 60		 jle	 SHORT $L2197
  00125	8d 75 fc	 lea	 esi, DWORD PTR [ebp-4]
  00128	8b d6		 mov	 edx, esi
  0012a	d3 e2		 shl	 edx, cl
  0012c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0012f	89 5c 24 1c	 mov	 DWORD PTR tv574[esp+12], ebx
  00133	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  0013a	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00140	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00143	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00146	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00149	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  0014f	42		 inc	 edx
  00150	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00153	8b ca		 mov	 ecx, edx
  00155	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00158	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0015b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0015e	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00164	8b 5c 24 1c	 mov	 ebx, DWORD PTR tv574[esp+12]
  00168	41		 inc	 ecx
  00169	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0016c	b1 10		 mov	 cl, 16			; 00000010H
  0016e	2a ca		 sub	 cl, dl
  00170	66 d3 ee	 shr	 si, cl
  00173	83 c2 f4	 add	 edx, -12		; fffffff4H
  00176	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  0017c	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  00183	eb 15		 jmp	 SHORT $L2205
$L2197:
  00185	8d 55 fc	 lea	 edx, DWORD PTR [ebp-4]
  00188	d3 e2		 shl	 edx, cl
  0018a	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00191	83 c1 04	 add	 ecx, 4
  00194	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2205:

; 851  :     for (rank = 0; rank < blcodes; rank++) {

  0019a	33 ff		 xor	 edi, edi
  0019c	85 ed		 test	 ebp, ebp
  0019e	0f 8e a3 00 00
	00		 jle	 $L2208
  001a4	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$L2206:

; 852  :         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
; 853  :         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);

  001b0	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  001b6	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  001b9	0f b6 97 00 00
	00 00		 movzx	 edx, BYTE PTR _bl_order[edi]
  001c0	7e 5d		 jle	 SHORT $L2212
  001c2	0f b7 b4 90 76
	0a 00 00	 movzx	 esi, WORD PTR [eax+edx*4+2678]
  001ca	8b d6		 mov	 edx, esi
  001cc	d3 e2		 shl	 edx, cl
  001ce	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001d1	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  001d8	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  001de	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001e1	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  001e4	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  001e7	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  001ed	42		 inc	 edx
  001ee	89 50 14	 mov	 DWORD PTR [eax+20], edx
  001f1	8b ca		 mov	 ecx, edx
  001f3	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f6	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  001f9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001fc	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00202	41		 inc	 ecx
  00203	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00206	b1 10		 mov	 cl, 16			; 00000010H
  00208	2a ca		 sub	 cl, dl
  0020a	66 d3 ee	 shr	 si, cl
  0020d	83 c2 f3	 add	 edx, -13		; fffffff3H
  00210	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  00216	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  0021d	eb 1b		 jmp	 SHORT $L2207
$L2212:
  0021f	66 8b 94 90 76
	0a 00 00	 mov	 dx, WORD PTR [eax+edx*4+2678]
  00227	66 d3 e2	 shl	 dx, cl
  0022a	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00231	83 c1 03	 add	 ecx, 3
  00234	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2207:
  0023a	47		 inc	 edi
  0023b	3b fd		 cmp	 edi, ebp
  0023d	0f 8c 6d ff ff
	ff		 jl	 $L2206

; 851  :     for (rank = 0; rank < blcodes; rank++) {

  00243	8b 5c 24 18	 mov	 ebx, DWORD PTR _dcodes$[esp+12]
$L2208:

; 854  :     }
; 855  :     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
; 856  : 
; 857  :     send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */

  00247	8b 4c 24 14	 mov	 ecx, DWORD PTR _lcodes$[esp+12]
  0024b	49		 dec	 ecx
  0024c	51		 push	 ecx
  0024d	8d 88 8c 00 00
	00		 lea	 ecx, DWORD PTR [eax+140]
  00253	e8 00 00 00 00	 call	 @send_tree@12

; 858  :     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
; 859  : 
; 860  :     send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */

  00258	4b		 dec	 ebx
  00259	53		 push	 ebx
  0025a	8d 88 80 09 00
	00		 lea	 ecx, DWORD PTR [eax+2432]
  00260	e8 00 00 00 00	 call	 @send_tree@12
  00265	5f		 pop	 edi
  00266	5e		 pop	 esi
  00267	5d		 pop	 ebp
  00268	5b		 pop	 ebx

; 861  :     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
; 862  : }

  00269	c2 0c 00	 ret	 12			; 0000000cH
@send_all_trees@16 ENDP
_TEXT	ENDS
PUBLIC	@_tr_tally@12
; Function compile flags: /Ogty
;	COMDAT @_tr_tally@12
_TEXT	SEGMENT
_lc$ = 8						; size = 4
@_tr_tally@12 PROC NEAR					; COMDAT
; _s$ = ecx
; _dist$ = edx

; 1026 :     s->d_buf[s->last_lit] = (ush)dist;

  00000	8b 81 98 16 00
	00		 mov	 eax, DWORD PTR [ecx+5784]
  00006	56		 push	 esi
  00007	8b b1 9c 16 00
	00		 mov	 esi, DWORD PTR [ecx+5788]
  0000d	66 89 14 46	 mov	 WORD PTR [esi+eax*2], dx

; 1027 :     s->l_buf[s->last_lit++] = (uch)lc;

  00011	8b b1 90 16 00
	00		 mov	 esi, DWORD PTR [ecx+5776]
  00017	8b 44 24 08	 mov	 eax, DWORD PTR _lc$[esp]
  0001b	57		 push	 edi
  0001c	8b b9 98 16 00
	00		 mov	 edi, DWORD PTR [ecx+5784]
  00022	88 04 3e	 mov	 BYTE PTR [esi+edi], al
  00025	8b b9 98 16 00
	00		 mov	 edi, DWORD PTR [ecx+5784]
  0002b	47		 inc	 edi

; 1028 :     if (dist == 0) {

  0002c	85 d2		 test	 edx, edx
  0002e	89 b9 98 16 00
	00		 mov	 DWORD PTR [ecx+5784], edi
  00034	75 0a		 jne	 SHORT $L2350

; 1029 :         /* lc is the unmatched char */
; 1030 :         s->dyn_ltree[lc].Freq++;

  00036	66 ff 84 81 8c
	00 00 00	 inc	 WORD PTR [ecx+eax*4+140]

; 1031 :     } else {

  0003e	eb 40		 jmp	 SHORT $L2351
$L2350:

; 1032 :         s->matches++;

  00040	ff 81 a8 16 00
	00		 inc	 DWORD PTR [ecx+5800]

; 1033 :         /* Here, lc is the match length - MIN_MATCH */
; 1034 :         dist--;             /* dist = match distance - 1 */
; 1035 :         Assert((ush)dist < (ush)MAX_DIST(s) &&
; 1036 :                (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
; 1037 :                (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
; 1038 : 
; 1039 :         s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;

  00046	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __length_code[eax]
  0004d	4a		 dec	 edx
  0004e	66 ff 84 81 90
	04 00 00	 inc	 WORD PTR [ecx+eax*4+1168]

; 1040 :         s->dyn_dtree[d_code(dist)].Freq++;

  00056	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H
  0005c	8d 84 81 90 04
	00 00		 lea	 eax, DWORD PTR [ecx+eax*4+1168]
  00063	73 09		 jae	 SHORT $L2600
  00065	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR __dist_code[edx]
  0006c	eb 0a		 jmp	 SHORT $L2601
$L2600:
  0006e	c1 ea 07	 shr	 edx, 7
  00071	0f b6 82 00 01
	00 00		 movzx	 eax, BYTE PTR __dist_code[edx+256]
$L2601:
  00078	66 ff 84 81 80
	09 00 00	 inc	 WORD PTR [ecx+eax*4+2432]
$L2351:

; 1041 :     }
; 1042 : 
; 1043 : #ifdef TRUNCATE_BLOCK
; 1044 :     /* Try to guess if it is profitable to stop the current block here */
; 1045 :     if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
; 1046 :         /* Compute an upper bound for the compressed length */
; 1047 :         ulg out_length = (ulg)s->last_lit*8L;
; 1048 :         ulg in_length = (ulg)((long)s->strstart - s->block_start);
; 1049 :         int dcode;
; 1050 :         for (dcode = 0; dcode < D_CODES; dcode++) {
; 1051 :             out_length += (ulg)s->dyn_dtree[dcode].Freq *
; 1052 :                 (5L+extra_dbits[dcode]);
; 1053 :         }
; 1054 :         out_length >>= 3;
; 1055 :         Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
; 1056 :                s->last_lit, in_length, out_length,
; 1057 :                100L - out_length*100L/in_length));
; 1058 :         if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
; 1059 :     }
; 1060 : #endif
; 1061 :     return (s->last_lit == s->lit_bufsize-1);

  00080	8b 91 94 16 00
	00		 mov	 edx, DWORD PTR [ecx+5780]
  00086	8b b1 98 16 00
	00		 mov	 esi, DWORD PTR [ecx+5784]
  0008c	4a		 dec	 edx
  0008d	33 c0		 xor	 eax, eax
  0008f	3b f2		 cmp	 esi, edx
  00091	5f		 pop	 edi
  00092	0f 94 c0	 sete	 al
  00095	5e		 pop	 esi

; 1062 :     /* We avoid equality with lit_bufsize because of wraparound at 64K
; 1063 :      * on 16 bit machines and because stored blocks are restricted to
; 1064 :      * 64K-1 bytes.
; 1065 :      */
; 1066 : }

  00096	c2 04 00	 ret	 4
@_tr_tally@12 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @compress_block@12
_TEXT	SEGMENT
tv868 = -12						; size = 4
_len$2380 = -12						; size = 4
tv867 = -8						; size = 4
_len$2405 = -8						; size = 4
_code$ = -8						; size = 4
_lx$ = -4						; size = 4
tv866 = 8						; size = 4
_ltree$ = 8						; size = 4
_dtree$ = 12						; size = 4
@compress_block@12 PROC NEAR				; COMDAT
; _s$ = eax

; 1076 :     unsigned dist;      /* distance of matched string */
; 1077 :     int lc;             /* match length or unmatched char (if dist == 0) */
; 1078 :     unsigned lx = 0;    /* running index in l_buf */
; 1079 :     unsigned code;      /* the code to send */
; 1080 :     int extra;          /* number of extra bits to send */
; 1081 : 
; 1082 :     if (s->last_lit != 0) do {

  00000	8b 90 98 16 00
	00		 mov	 edx, DWORD PTR [eax+5784]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	8b 5c 24 14	 mov	 ebx, DWORD PTR _ltree$[esp+12]
  0000e	55		 push	 ebp
  0000f	56		 push	 esi
  00010	33 c9		 xor	 ecx, ecx
  00012	85 d2		 test	 edx, edx
  00014	57		 push	 edi
  00015	0f 84 46 03 00
	00		 je	 $L2365
  0001b	eb 03 8d 49 00	 npad	 5
$L2363:

; 1083 :         dist = s->d_buf[lx];

  00020	8b 90 9c 16 00
	00		 mov	 edx, DWORD PTR [eax+5788]
  00026	0f b7 2c 4a	 movzx	 ebp, WORD PTR [edx+ecx*2]

; 1084 :         lc = s->l_buf[lx++];

  0002a	8b 90 90 16 00
	00		 mov	 edx, DWORD PTR [eax+5776]
  00030	0f b6 34 11	 movzx	 esi, BYTE PTR [ecx+edx]
  00034	41		 inc	 ecx

; 1085 :         if (dist == 0) {

  00035	85 ed		 test	 ebp, ebp
  00037	89 4c 24 18	 mov	 DWORD PTR _lx$[esp+28], ecx

; 1086 :             send_code(s, lc, ltree); /* send a literal byte */

  0003b	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  00041	0f 85 84 00 00
	00		 jne	 $L2366
  00047	0f b7 7c b3 02	 movzx	 edi, WORD PTR [ebx+esi*4+2]
  0004c	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00051	2b d7		 sub	 edx, edi
  00053	3b ca		 cmp	 ecx, edx
  00055	7e 5f		 jle	 SHORT $L2370
  00057	0f b7 34 b3	 movzx	 esi, WORD PTR [ebx+esi*4]
  0005b	8b d6		 mov	 edx, esi
  0005d	d3 e2		 shl	 edx, cl
  0005f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00062	89 5c 24 10	 mov	 DWORD PTR tv868[esp+28], ebx
  00066	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  0006d	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00070	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00076	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00079	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0007c	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00082	42		 inc	 edx
  00083	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00086	8b ca		 mov	 ecx, edx
  00088	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0008b	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0008e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00091	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00097	8b 5c 24 10	 mov	 ebx, DWORD PTR tv868[esp+28]
  0009b	41		 inc	 ecx
  0009c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0009f	b1 10		 mov	 cl, 16			; 00000010H
  000a1	2a ca		 sub	 cl, dl
  000a3	66 d3 ee	 shr	 si, cl
  000a6	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  000aa	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  000b1	e9 95 02 00 00	 jmp	 $L2609
$L2370:
  000b6	66 8b 14 b3	 mov	 dx, WORD PTR [ebx+esi*4]
  000ba	66 d3 e2	 shl	 dx, cl
  000bd	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  000c4	03 cf		 add	 ecx, edi

; 1087 :             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
; 1088 :         } else {

  000c6	e9 80 02 00 00	 jmp	 $L2609
$L2366:

; 1089 :             /* Here, lc is the match length - MIN_MATCH */
; 1090 :             code = _length_code[lc];

  000cb	0f b6 96 00 00
	00 00		 movzx	 edx, BYTE PTR __length_code[esi]

; 1091 :             send_code(s, code+LITERALS+1, ltree); /* send the length code */

  000d2	0f b7 bc 93 06
	04 00 00	 movzx	 edi, WORD PTR [ebx+edx*4+1030]
  000da	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  000df	2b df		 sub	 ebx, edi
  000e1	3b cb		 cmp	 ecx, ebx
  000e3	89 7c 24 10	 mov	 DWORD PTR _len$2380[esp+28], edi
  000e7	8b 7c 24 20	 mov	 edi, DWORD PTR _ltree$[esp+24]
  000eb	89 54 24 14	 mov	 DWORD PTR _code$[esp+28], edx
  000ef	7e 66		 jle	 SHORT $L2383
  000f1	0f b7 bc 97 04
	04 00 00	 movzx	 edi, WORD PTR [edi+edx*4+1028]
  000f9	8b d7		 mov	 edx, edi
  000fb	d3 e2		 shl	 edx, cl
  000fd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00100	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00107	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0010a	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00110	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00113	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00116	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  0011c	42		 inc	 edx
  0011d	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00120	8b ca		 mov	 ecx, edx
  00122	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00125	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00128	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0012b	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00131	41		 inc	 ecx
  00132	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00135	b1 10		 mov	 cl, 16			; 00000010H
  00137	2a ca		 sub	 cl, dl
  00139	66 d3 ef	 shr	 di, cl
  0013c	8b 4c 24 10	 mov	 ecx, DWORD PTR _len$2380[esp+28]
  00140	8d 54 0a f0	 lea	 edx, DWORD PTR [edx+ecx-16]
  00144	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  0014a	8b 54 24 14	 mov	 edx, DWORD PTR _code$[esp+28]
  0014e	66 89 b8 b0 16
	00 00		 mov	 WORD PTR [eax+5808], di
  00155	eb 1e		 jmp	 SHORT $L2610
$L2383:
  00157	66 8b bc 97 04
	04 00 00	 mov	 di, WORD PTR [edi+edx*4+1028]
  0015f	66 d3 e7	 shl	 di, cl
  00162	66 09 b8 b0 16
	00 00		 or	 WORD PTR [eax+5808], di
  00169	8b 7c 24 10	 mov	 edi, DWORD PTR _len$2380[esp+28]
  0016d	03 cf		 add	 ecx, edi
  0016f	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2610:

; 1092 :             extra = extra_lbits[code];

  00175	8b 3c 95 00 00
	00 00		 mov	 edi, DWORD PTR _extra_lbits[edx*4]

; 1093 :             if (extra != 0) {

  0017c	85 ff		 test	 edi, edi
  0017e	8b 5c 24 20	 mov	 ebx, DWORD PTR _ltree$[esp+24]
  00182	0f 84 7d 00 00
	00		 je	 $L2404

; 1094 :                 lc -= base_length[code];

  00188	2b 34 95 00 00
	00 00		 sub	 esi, DWORD PTR _base_length[edx*4]

; 1095 :                 send_bits(s, lc, extra);       /* send the extra length bits */

  0018f	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  00195	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0019a	2b d7		 sub	 edx, edi
  0019c	3b ca		 cmp	 ecx, edx
  0019e	7e 54		 jle	 SHORT $L2396
  001a0	8b d6		 mov	 edx, esi
  001a2	d3 e2		 shl	 edx, cl
  001a4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001a7	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  001ae	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  001b1	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  001b7	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  001ba	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  001bd	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  001c3	42		 inc	 edx
  001c4	89 50 14	 mov	 DWORD PTR [eax+20], edx
  001c7	8b ca		 mov	 ecx, edx
  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  001cf	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001d2	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  001d8	8b 5c 24 20	 mov	 ebx, DWORD PTR _ltree$[esp+24]
  001dc	41		 inc	 ecx
  001dd	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  001e0	b1 10		 mov	 cl, 16			; 00000010H
  001e2	2a ca		 sub	 cl, dl
  001e4	66 d3 ee	 shr	 si, cl
  001e7	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  001eb	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  001f2	eb 0b		 jmp	 SHORT $L2611
$L2396:
  001f4	d3 e6		 shl	 esi, cl
  001f6	66 09 b0 b0 16
	00 00		 or	 WORD PTR [eax+5808], si
  001fd	03 cf		 add	 ecx, edi
$L2611:
  001ff	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2404:

; 1096 :             }
; 1097 :             dist--; /* dist is now the match distance - 1 */

  00205	4d		 dec	 ebp

; 1098 :             code = d_code(dist);

  00206	81 fd 00 01 00
	00		 cmp	 ebp, 256		; 00000100H
  0020c	73 09		 jae	 SHORT $L2604
  0020e	0f b6 bd 00 00
	00 00		 movzx	 edi, BYTE PTR __dist_code[ebp]
  00215	eb 0c		 jmp	 SHORT $L2605
$L2604:
  00217	8b d5		 mov	 edx, ebp
  00219	c1 ea 07	 shr	 edx, 7
  0021c	0f b6 ba 00 01
	00 00		 movzx	 edi, BYTE PTR __dist_code[edx+256]
$L2605:

; 1099 :             Assert (code < D_CODES, "bad d_code");
; 1100 : 
; 1101 :             send_code(s, code, dtree);       /* send the distance code */

  00223	8b 4c 24 24	 mov	 ecx, DWORD PTR _dtree$[esp+24]
  00227	0f b7 54 b9 02	 movzx	 edx, WORD PTR [ecx+edi*4+2]
  0022c	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  00232	be 10 00 00 00	 mov	 esi, 16			; 00000010H
  00237	2b f2		 sub	 esi, edx
  00239	3b ce		 cmp	 ecx, esi
  0023b	89 54 24 14	 mov	 DWORD PTR _len$2405[esp+28], edx
  0023f	7e 66		 jle	 SHORT $L2408
  00241	8b 54 24 24	 mov	 edx, DWORD PTR _dtree$[esp+24]
  00245	0f b7 34 ba	 movzx	 esi, WORD PTR [edx+edi*4]
  00249	8b d6		 mov	 edx, esi
  0024b	d3 e2		 shl	 edx, cl
  0024d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00250	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00257	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0025a	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00260	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00263	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00266	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  0026c	42		 inc	 edx
  0026d	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00270	8b ca		 mov	 ecx, edx
  00272	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00275	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00278	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0027b	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00281	8b 5c 24 20	 mov	 ebx, DWORD PTR _ltree$[esp+24]
  00285	41		 inc	 ecx
  00286	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00289	b1 10		 mov	 cl, 16			; 00000010H
  0028b	2a ca		 sub	 cl, dl
  0028d	66 d3 ee	 shr	 si, cl
  00290	8b 4c 24 14	 mov	 ecx, DWORD PTR _len$2405[esp+28]
  00294	8d 54 0a f0	 lea	 edx, DWORD PTR [edx+ecx-16]
  00298	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  0029e	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  002a5	eb 1a		 jmp	 SHORT $L2416
$L2408:
  002a7	8b 74 24 24	 mov	 esi, DWORD PTR _dtree$[esp+24]
  002ab	66 8b 34 be	 mov	 si, WORD PTR [esi+edi*4]
  002af	66 d3 e6	 shl	 si, cl
  002b2	66 09 b0 b0 16
	00 00		 or	 WORD PTR [eax+5808], si
  002b9	03 ca		 add	 ecx, edx
  002bb	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2416:

; 1102 :             extra = extra_dbits[code];

  002c1	8b 34 bd 00 00
	00 00		 mov	 esi, DWORD PTR _extra_dbits[edi*4]

; 1103 :             if (extra != 0) {

  002c8	85 f6		 test	 esi, esi
  002ca	0f 84 81 00 00
	00		 je	 $L2364

; 1104 :                 dist -= base_dist[code];

  002d0	2b 2c bd 00 00
	00 00		 sub	 ebp, DWORD PTR _base_dist[edi*4]

; 1105 :                 send_bits(s, dist, extra);   /* send the extra distance bits */

  002d7	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  002dd	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  002e2	2b d6		 sub	 edx, esi
  002e4	3b ca		 cmp	 ecx, edx
  002e6	7e 58		 jle	 SHORT $L2421
  002e8	8b d5		 mov	 edx, ebp
  002ea	d3 e2		 shl	 edx, cl
  002ec	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002ef	89 5c 24 14	 mov	 DWORD PTR tv867[esp+28], ebx
  002f3	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  002fa	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  002fd	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00303	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00306	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00309	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  0030f	42		 inc	 edx
  00310	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00313	8b ca		 mov	 ecx, edx
  00315	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00318	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0031b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0031e	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00324	8b 5c 24 14	 mov	 ebx, DWORD PTR tv867[esp+28]
  00328	41		 inc	 ecx
  00329	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0032c	b1 10		 mov	 cl, 16			; 00000010H
  0032e	2a ca		 sub	 cl, dl
  00330	66 d3 ed	 shr	 bp, cl
  00333	8d 4c 32 f0	 lea	 ecx, DWORD PTR [edx+esi-16]
  00337	66 89 a8 b0 16
	00 00		 mov	 WORD PTR [eax+5808], bp
  0033e	eb 0b		 jmp	 SHORT $L2609
$L2421:
  00340	d3 e5		 shl	 ebp, cl
  00342	66 09 a8 b0 16
	00 00		 or	 WORD PTR [eax+5808], bp
  00349	03 ce		 add	 ecx, esi
$L2609:
  0034b	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2364:

; 1106 :             }
; 1107 :         } /* literal or match pair ? */
; 1108 : 
; 1109 :         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
; 1110 :         Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");
; 1111 : 
; 1112 :     } while (lx < s->last_lit);

  00351	8b 4c 24 18	 mov	 ecx, DWORD PTR _lx$[esp+28]
  00355	3b 88 98 16 00
	00		 cmp	 ecx, DWORD PTR [eax+5784]
  0035b	0f 82 bf fc ff
	ff		 jb	 $L2363
$L2365:

; 1113 : 
; 1114 :     send_code(s, END_BLOCK, ltree);

  00361	0f b7 bb 02 04
	00 00		 movzx	 edi, WORD PTR [ebx+1026]
  00368	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  0036e	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00373	2b d7		 sub	 edx, edi
  00375	3b ca		 cmp	 ecx, edx
  00377	7e 7a		 jle	 SHORT $L2433
  00379	0f b7 b3 00 04
	00 00		 movzx	 esi, WORD PTR [ebx+1024]
  00380	8b d6		 mov	 edx, esi
  00382	d3 e2		 shl	 edx, cl
  00384	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00387	89 5c 24 20	 mov	 DWORD PTR tv866[esp+24], ebx
  0038b	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00392	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00395	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  0039b	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0039e	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  003a1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003a4	8b 5c 24 20	 mov	 ebx, DWORD PTR tv866[esp+24]
  003a8	42		 inc	 edx
  003a9	89 50 14	 mov	 DWORD PTR [eax+20], edx
  003ac	8b ea		 mov	 ebp, edx
  003ae	8a 90 b1 16 00
	00		 mov	 dl, BYTE PTR [eax+5809]
  003b4	88 14 29	 mov	 BYTE PTR [ecx+ebp], dl
  003b7	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  003ba	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  003c0	41		 inc	 ecx
  003c1	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  003c4	b1 10		 mov	 cl, 16			; 00000010H
  003c6	2a ca		 sub	 cl, dl
  003c8	66 d3 ee	 shr	 si, cl
  003cb	8d 4c 3a f0	 lea	 ecx, DWORD PTR [edx+edi-16]
  003cf	5f		 pop	 edi
  003d0	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
  003d6	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si

; 1115 :     s->last_eob_len = ltree[END_BLOCK].Len;

  003dd	0f b7 93 02 04
	00 00		 movzx	 edx, WORD PTR [ebx+1026]
  003e4	5e		 pop	 esi
  003e5	5d		 pop	 ebp
  003e6	89 90 ac 16 00
	00		 mov	 DWORD PTR [eax+5804], edx
  003ec	5b		 pop	 ebx

; 1116 : }

  003ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  003f0	c2 08 00	 ret	 8
$L2433:

; 1113 : 
; 1114 :     send_code(s, END_BLOCK, ltree);

  003f3	66 8b 93 00 04
	00 00		 mov	 dx, WORD PTR [ebx+1024]
  003fa	66 d3 e2	 shl	 dx, cl
  003fd	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00404	03 cf		 add	 ecx, edi
  00406	5f		 pop	 edi
  00407	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx

; 1115 :     s->last_eob_len = ltree[END_BLOCK].Len;

  0040d	0f b7 8b 02 04
	00 00		 movzx	 ecx, WORD PTR [ebx+1026]
  00414	5e		 pop	 esi
  00415	5d		 pop	 ebp
  00416	89 88 ac 16 00
	00		 mov	 DWORD PTR [eax+5804], ecx
  0041c	5b		 pop	 ebx

; 1116 : }

  0041d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00420	c2 08 00	 ret	 8
@compress_block@12 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @set_data_type@4
_TEXT	SEGMENT
@set_data_type@4 PROC NEAR				; COMDAT
; _s$ = ecx

; 1127 :     int n = 0;
; 1128 :     unsigned ascii_freq = 0;
; 1129 :     unsigned bin_freq = 0;
; 1130 :     while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;

  00000	0f b7 91 a0 00
	00 00		 movzx	 edx, WORD PTR [ecx+160]
  00007	0f b7 81 a4 00
	00 00		 movzx	 eax, WORD PTR [ecx+164]

; 1131 :     while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
; 1132 :     while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
; 1133 :     s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
; 1134 : }

  0000e	03 c2		 add	 eax, edx
  00010	0f b7 91 9c 00
	00 00		 movzx	 edx, WORD PTR [ecx+156]
  00017	03 c2		 add	 eax, edx
  00019	0f b7 91 98 00
	00 00		 movzx	 edx, WORD PTR [ecx+152]
  00020	03 c2		 add	 eax, edx
  00022	0f b7 91 94 00
	00 00		 movzx	 edx, WORD PTR [ecx+148]
  00029	03 c2		 add	 eax, edx
  0002b	0f b7 91 90 00
	00 00		 movzx	 edx, WORD PTR [ecx+144]
  00032	03 c2		 add	 eax, edx
  00034	0f b7 91 8c 00
	00 00		 movzx	 edx, WORD PTR [ecx+140]
  0003b	53		 push	 ebx
  0003c	56		 push	 esi
  0003d	33 f6		 xor	 esi, esi
  0003f	57		 push	 edi
  00040	03 c2		 add	 eax, edx
  00042	8d 91 a8 00 00
	00		 lea	 edx, DWORD PTR [ecx+168]
  00048	bf 79 00 00 00	 mov	 edi, 121		; 00000079H
  0004d	8d 49 00	 npad	 3
$L2452:
  00050	0f b7 1a	 movzx	 ebx, WORD PTR [edx]
  00053	03 f3		 add	 esi, ebx
  00055	83 c2 04	 add	 edx, 4
  00058	4f		 dec	 edi
  00059	75 f5		 jne	 SHORT $L2452
  0005b	8d 91 8c 02 00
	00		 lea	 edx, DWORD PTR [ecx+652]
  00061	bf 80 00 00 00	 mov	 edi, 128		; 00000080H
$L2455:
  00066	0f b7 1a	 movzx	 ebx, WORD PTR [edx]
  00069	03 c3		 add	 eax, ebx
  0006b	83 c2 04	 add	 edx, 4
  0006e	4f		 dec	 edi
  0006f	75 f5		 jne	 SHORT $L2455
  00071	c1 ee 02	 shr	 esi, 2
  00074	3b f0		 cmp	 esi, eax
  00076	5f		 pop	 edi
  00077	1a c0		 sbb	 al, al
  00079	fe c0		 inc	 al
  0007b	5e		 pop	 esi
  0007c	88 41 1c	 mov	 BYTE PTR [ecx+28], al
  0007f	5b		 pop	 ebx
  00080	c3		 ret	 0
@set_data_type@4 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @bi_reverse@8
_TEXT	SEGMENT
@bi_reverse@8 PROC NEAR					; COMDAT
; _code$ = ecx
; _len$ = edx

; 1145 :     register unsigned res = 0;

  00000	33 c0		 xor	 eax, eax
  00002	56		 push	 esi
$L2463:

; 1146 :     do {
; 1147 :         res |= code & 1;

  00003	8b f1		 mov	 esi, ecx
  00005	83 e6 01	 and	 esi, 1
  00008	0b c6		 or	 eax, esi

; 1148 :         code >>= 1, res <<= 1;

  0000a	d1 e9		 shr	 ecx, 1
  0000c	d1 e0		 shl	 eax, 1

; 1149 :     } while (--len > 0);

  0000e	4a		 dec	 edx
  0000f	85 d2		 test	 edx, edx
  00011	7f f0		 jg	 SHORT $L2463

; 1150 :     return res >> 1;

  00013	d1 e8		 shr	 eax, 1
  00015	5e		 pop	 esi

; 1151 : }

  00016	c3		 ret	 0
@bi_reverse@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @bi_flush@4
_TEXT	SEGMENT
@bi_flush@4 PROC NEAR					; COMDAT
; _s$ = eax

; 1159 :     if (s->bi_valid == 16) {

  00000	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00009	53		 push	 ebx
  0000a	75 38		 jne	 SHORT $L2469

; 1160 :         put_short(s, s->bi_buf);

  0000c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0000f	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00015	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00018	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0001b	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0001e	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00024	42		 inc	 edx
  00025	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00028	8b ca		 mov	 ecx, edx
  0002a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0002d	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00030	ff 40 14	 inc	 DWORD PTR [eax+20]

; 1161 :         s->bi_buf = 0;

  00033	33 c9		 xor	 ecx, ecx
  00035	66 89 88 b0 16
	00 00		 mov	 WORD PTR [eax+5808], cx

; 1166 :         s->bi_valid -= 8;

  0003c	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
  00042	5b		 pop	 ebx

; 1167 :     }
; 1168 : }

  00043	c3		 ret	 0
$L2469:

; 1162 :         s->bi_valid = 0;
; 1163 :     } else if (s->bi_valid >= 8) {

  00044	83 f9 08	 cmp	 ecx, 8
  00047	7c 34		 jl	 SHORT $L2474

; 1164 :         put_byte(s, (Byte)s->bi_buf);

  00049	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0004f	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00055	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl

; 1165 :         s->bi_buf >>= 8;

  00058	66 0f b6 88 b1
	16 00 00	 movzx	 cx, BYTE PTR [eax+5809]
  00060	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00063	66 89 88 b0 16
	00 00		 mov	 WORD PTR [eax+5808], cx

; 1166 :         s->bi_valid -= 8;

  0006a	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  00070	42		 inc	 edx
  00071	83 c1 f8	 add	 ecx, -8			; fffffff8H
  00074	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00077	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2474:
  0007d	5b		 pop	 ebx

; 1167 :     }
; 1168 : }

  0007e	c3		 ret	 0
@bi_flush@4 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @bi_windup@4
_TEXT	SEGMENT
@bi_windup@4 PROC NEAR					; COMDAT
; _s$ = eax

; 1176 :     if (s->bi_valid > 8) {

  00000	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00006	83 fa 08	 cmp	 edx, 8
  00009	53		 push	 ebx
  0000a	7e 38		 jle	 SHORT $L2479

; 1177 :         put_short(s, s->bi_buf);

  0000c	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0000f	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00015	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00018	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0001b	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0001e	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00024	42		 inc	 edx
  00025	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00028	8b ca		 mov	 ecx, edx
  0002a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0002d	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00030	ff 40 14	 inc	 DWORD PTR [eax+20]

; 1180 :     }
; 1181 :     s->bi_buf = 0;

  00033	33 c9		 xor	 ecx, ecx
  00035	66 89 88 b0 16
	00 00		 mov	 WORD PTR [eax+5808], cx

; 1182 :     s->bi_valid = 0;

  0003c	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
  00042	5b		 pop	 ebx

; 1183 : #ifdef DEBUG
; 1184 :     s->bits_sent = (s->bits_sent+7) & ~7;
; 1185 : #endif
; 1186 : }

  00043	c3		 ret	 0
$L2479:

; 1178 :     } else if (s->bi_valid > 0) {

  00044	33 c9		 xor	 ecx, ecx
  00046	3b d1		 cmp	 edx, ecx
  00048	7e 14		 jle	 SHORT $L2638

; 1179 :         put_byte(s, (Byte)s->bi_buf);

  0004a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0004d	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00053	56		 push	 esi
  00054	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00057	88 1c 32	 mov	 BYTE PTR [edx+esi], bl
  0005a	ff 40 14	 inc	 DWORD PTR [eax+20]
  0005d	5e		 pop	 esi
$L2638:

; 1180 :     }
; 1181 :     s->bi_buf = 0;

  0005e	66 89 88 b0 16
	00 00		 mov	 WORD PTR [eax+5808], cx

; 1182 :     s->bi_valid = 0;

  00065	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
  0006b	5b		 pop	 ebx

; 1183 : #ifdef DEBUG
; 1184 :     s->bits_sent = (s->bits_sent+7) & ~7;
; 1185 : #endif
; 1186 : }

  0006c	c3		 ret	 0
@bi_windup@4 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @copy_block@16
_TEXT	SEGMENT
tv220 = 8						; size = 4
_header$ = 8						; size = 4
@copy_block@16 PROC NEAR				; COMDAT
; _s$ = eax
; _buf$ = edx
; _len$ = ecx

; 1197 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b d9		 mov	 ebx, ecx
  00005	8b fa		 mov	 edi, edx

; 1198 :     bi_windup(s);        /* align on byte boundary */

  00007	e8 00 00 00 00	 call	 @bi_windup@4

; 1199 :     s->last_eob_len = 8; /* enough lookahead for inflate */
; 1200 : 
; 1201 :     if (header) {

  0000c	8b 4c 24 10	 mov	 ecx, DWORD PTR _header$[esp+8]
  00010	85 c9		 test	 ecx, ecx
  00012	c7 80 ac 16 00
	00 08 00 00 00	 mov	 DWORD PTR [eax+5804], 8
  0001c	74 3b		 je	 SHORT $L2641

; 1202 :         put_short(s, (ush)len);   

  0001e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00021	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00024	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00027	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0002d	41		 inc	 ecx
  0002e	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00031	88 3c 11	 mov	 BYTE PTR [ecx+edx], bh
  00034	8b 70 14	 mov	 esi, DWORD PTR [eax+20]

; 1203 :         put_short(s, (ush)~len);

  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	46		 inc	 esi
  0003b	89 70 14	 mov	 DWORD PTR [eax+20], esi
  0003e	8a cb		 mov	 cl, bl
  00040	f6 d1		 not	 cl
  00042	88 0c 16	 mov	 BYTE PTR [esi+edx], cl
  00045	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00048	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0004b	46		 inc	 esi
  0004c	8b cb		 mov	 ecx, ebx
  0004e	f7 d1		 not	 ecx
  00050	89 70 14	 mov	 DWORD PTR [eax+20], esi
  00053	88 2c 16	 mov	 BYTE PTR [esi+edx], ch
  00056	ff 40 14	 inc	 DWORD PTR [eax+20]
$L2641:

; 1204 : #ifdef DEBUG
; 1205 :         s->bits_sent += 2*16;
; 1206 : #endif
; 1207 :     }
; 1208 : #ifdef DEBUG
; 1209 :     s->bits_sent += (ulg)len<<3;
; 1210 : #endif
; 1211 :     while (len--) {

  00059	85 db		 test	 ebx, ebx
  0005b	74 21		 je	 SHORT $L2642
  0005d	8d 49 00	 npad	 3
$L2504:

; 1212 :         put_byte(s, *buf++);

  00060	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00063	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00066	89 5c 24 10	 mov	 DWORD PTR tv220[esp+8], ebx
  0006a	8a 1f		 mov	 bl, BYTE PTR [edi]
  0006c	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0006f	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  00072	8b 5c 24 10	 mov	 ebx, DWORD PTR tv220[esp+8]
  00076	46		 inc	 esi
  00077	47		 inc	 edi
  00078	4b		 dec	 ebx
  00079	89 70 14	 mov	 DWORD PTR [eax+20], esi
  0007c	75 e2		 jne	 SHORT $L2504
$L2642:
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx

; 1213 :     }
; 1214 : }

  00081	c2 04 00	 ret	 4
@copy_block@16 ENDP
_TEXT	ENDS
PUBLIC	@_tr_init@4
; Function compile flags: /Ogty
;	COMDAT @_tr_init@4
_TEXT	SEGMENT
@_tr_init@4 PROC NEAR					; COMDAT
; _s$ = ecx

; 386  :     tr_static_init();
; 387  : 
; 388  :     s->l_desc.dyn_tree = s->dyn_ltree;

  00000	8d 81 8c 00 00
	00		 lea	 eax, DWORD PTR [ecx+140]
  00006	89 81 10 0b 00
	00		 mov	 DWORD PTR [ecx+2832], eax

; 389  :     s->l_desc.stat_desc = &static_l_desc;
; 390  : 
; 391  :     s->d_desc.dyn_tree = s->dyn_dtree;
; 392  :     s->d_desc.stat_desc = &static_d_desc;
; 393  : 
; 394  :     s->bl_desc.dyn_tree = s->bl_tree;

  0000c	8d 81 74 0a 00
	00		 lea	 eax, DWORD PTR [ecx+2676]
  00012	8d 91 80 09 00
	00		 lea	 edx, DWORD PTR [ecx+2432]
  00018	89 81 28 0b 00
	00		 mov	 DWORD PTR [ecx+2856], eax

; 395  :     s->bl_desc.stat_desc = &static_bl_desc;
; 396  : 
; 397  :     s->bi_buf = 0;

  0001e	33 c0		 xor	 eax, eax
  00020	89 91 1c 0b 00
	00		 mov	 DWORD PTR [ecx+2844], edx
  00026	c7 81 18 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2840], OFFSET FLAT:_static_l_desc
  00030	c7 81 24 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2852], OFFSET FLAT:_static_d_desc
  0003a	c7 81 30 0b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2864], OFFSET FLAT:_static_bl_desc
  00044	66 89 81 b0 16
	00 00		 mov	 WORD PTR [ecx+5808], ax

; 398  :     s->bi_valid = 0;

  0004b	89 81 b4 16 00
	00		 mov	 DWORD PTR [ecx+5812], eax

; 399  :     s->last_eob_len = 8; /* enough lookahead for inflate */

  00051	c7 81 ac 16 00
	00 08 00 00 00	 mov	 DWORD PTR [ecx+5804], 8

; 400  : #ifdef DEBUG
; 401  :     s->compressed_len = 0L;
; 402  :     s->bits_sent = 0L;
; 403  : #endif
; 404  : 
; 405  :     /* Initialize the first block of the first file: */
; 406  :     init_block(s);

  0005b	8b d1		 mov	 edx, ecx
  0005d	e9 00 00 00 00	 jmp	 @init_block@4
@_tr_init@4 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @gen_codes@12
_TEXT	SEGMENT
_next_code$ = -32					; size = 32
@gen_codes@12 PROC NEAR					; COMDAT
; _tree$ = edi
; _max_code$ = ebx
; _bl_count$ = edx

; 582  : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H
  00003	56		 push	 esi

; 583  :     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
; 584  :     ush code = 0;              /* running code value */
; 585  :     int bits;                  /* bit index */
; 586  :     int n;                     /* code index */
; 587  : 
; 588  :     /* The distribution counts are first used to generate the code values
; 589  :      * without bit reversal.
; 590  :      */
; 591  :     for (bits = 1; bits <= MAX_BITS; bits++) {

  00004	8d 74 24 06	 lea	 esi, DWORD PTR _next_code$[esp+38]
  00008	33 c9		 xor	 ecx, ecx
  0000a	b8 01 00 00 00	 mov	 eax, 1
  0000f	2b d6		 sub	 edx, esi
$L1956:
  00011	8d 34 42	 lea	 esi, DWORD PTR [edx+eax*2]

; 592  :         next_code[bits] = code = (code + bl_count[bits-1]) << 1;

  00014	0f b7 74 34 04	 movzx	 esi, WORD PTR _next_code$[esp+esi+36]
  00019	66 03 f1	 add	 si, cx
  0001c	d1 e6		 shl	 esi, 1
  0001e	8b ce		 mov	 ecx, esi
  00020	66 89 4c 44 04	 mov	 WORD PTR _next_code$[esp+eax*2+36], cx
  00025	40		 inc	 eax
  00026	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00029	7e e6		 jle	 SHORT $L1956

; 593  :     }
; 594  :     /* Check that the bit counts in bl_count are consistent. The last code
; 595  :      * must be all ones.
; 596  :      */
; 597  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 598  :             "inconsistent bit counts");
; 599  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 600  : 
; 601  :     for (n = 0;  n <= max_code; n++) {

  0002b	33 f6		 xor	 esi, esi
  0002d	85 db		 test	 ebx, ebx
  0002f	7c 3b		 jl	 SHORT $L1961
  00031	55		 push	 ebp
$L1959:

; 602  :         int len = tree[n].Len;

  00032	0f b7 54 b7 02	 movzx	 edx, WORD PTR [edi+esi*4+2]

; 603  :         if (len == 0) continue;

  00037	85 d2		 test	 edx, edx
  00039	74 2b		 je	 SHORT $L1960

; 604  :         /* Now reverse the bits */
; 605  :         tree[n].Code = bi_reverse(next_code[len]++, len);

  0003b	33 c0		 xor	 eax, eax
  0003d	66 8b 44 54 08	 mov	 ax, WORD PTR _next_code$[esp+edx*2+40]
  00042	0f b7 c8	 movzx	 ecx, ax
  00045	40		 inc	 eax
  00046	66 89 44 54 08	 mov	 WORD PTR _next_code$[esp+edx*2+40], ax
  0004b	33 c0		 xor	 eax, eax
  0004d	8d 49 00	 npad	 3
$L2654:
  00050	8b e9		 mov	 ebp, ecx
  00052	83 e5 01	 and	 ebp, 1
  00055	0b c5		 or	 eax, ebp
  00057	d1 e9		 shr	 ecx, 1
  00059	d1 e0		 shl	 eax, 1
  0005b	4a		 dec	 edx
  0005c	85 d2		 test	 edx, edx
  0005e	7f f0		 jg	 SHORT $L2654
  00060	d1 e8		 shr	 eax, 1
  00062	66 89 04 b7	 mov	 WORD PTR [edi+esi*4], ax
$L1960:
  00066	46		 inc	 esi
  00067	3b f3		 cmp	 esi, ebx
  00069	7e c7		 jle	 SHORT $L1959
  0006b	5d		 pop	 ebp
$L1961:
  0006c	5e		 pop	 esi

; 606  : 
; 607  :         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
; 608  :              n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
; 609  :     }
; 610  : }

  0006d	83 c4 20	 add	 esp, 32			; 00000020H
  00070	c3		 ret	 0
@gen_codes@12 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @build_tree@8
_TEXT	SEGMENT
_max_code$ = -8						; size = 4
_elems$ = -4						; size = 4
_desc$ = 8						; size = 4
@build_tree@8 PROC NEAR					; COMDAT
; _s$ = esi

; 623  : {

  00000	83 ec 08	 sub	 esp, 8

; 624  :     ct_data *tree         = desc->dyn_tree;

  00003	8b 44 24 0c	 mov	 eax, DWORD PTR _desc$[esp+4]
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	57		 push	 edi
  0000a	8b 38		 mov	 edi, DWORD PTR [eax]

; 625  :     const ct_data *stree  = desc->stat_desc->static_tree;

  0000c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 626  :     int elems             = desc->stat_desc->elems;

  0000f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00012	8b 18		 mov	 ebx, DWORD PTR [eax]

; 627  :     int n, m;          /* iterate over heap elements */
; 628  :     int max_code = -1; /* largest code with non zero frequency */
; 629  :     int node;          /* new node being created */
; 630  : 
; 631  :     /* Construct the initial heap, with least frequent element in
; 632  :      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
; 633  :      * heap[0] is not used.
; 634  :      */
; 635  :     s->heap_len = 0, s->heap_max = HEAP_SIZE;

  00014	33 d2		 xor	 edx, edx
  00016	83 cd ff	 or	 ebp, -1

; 636  : 
; 637  :     for (n = 0; n < elems; n++) {

  00019	33 c0		 xor	 eax, eax
  0001b	3b ca		 cmp	 ecx, edx
  0001d	89 4c 24 10	 mov	 DWORD PTR _elems$[esp+20], ecx
  00021	89 6c 24 0c	 mov	 DWORD PTR _max_code$[esp+20], ebp
  00025	89 96 48 14 00
	00		 mov	 DWORD PTR [esi+5192], edx
  0002b	c7 86 4c 14 00
	00 3d 02 00 00	 mov	 DWORD PTR [esi+5196], 573 ; 0000023dH
  00035	7e 37		 jle	 SHORT $L2672
$L1975:

; 638  :         if (tree[n].Freq != 0) {

  00037	66 39 14 87	 cmp	 WORD PTR [edi+eax*4], dx
  0003b	74 23		 je	 SHORT $L1978

; 639  :             s->heap[++(s->heap_len)] = max_code = n;

  0003d	8b 8e 48 14 00
	00		 mov	 ecx, DWORD PTR [esi+5192]
  00043	41		 inc	 ecx
  00044	89 8e 48 14 00
	00		 mov	 DWORD PTR [esi+5192], ecx
  0004a	89 84 8e 54 0b
	00 00		 mov	 DWORD PTR [esi+ecx*4+2900], eax
  00051	89 44 24 0c	 mov	 DWORD PTR _max_code$[esp+20], eax

; 640  :             s->depth[n] = 0;

  00055	88 94 30 50 14
	00 00		 mov	 BYTE PTR [eax+esi+5200], dl

; 641  :         } else {

  0005c	8b e8		 mov	 ebp, eax
  0005e	eb 05		 jmp	 SHORT $L1976
$L1978:

; 642  :             tree[n].Len = 0;

  00060	66 89 54 87 02	 mov	 WORD PTR [edi+eax*4+2], dx
$L1976:

; 636  : 
; 637  :     for (n = 0; n < elems; n++) {

  00065	8b 4c 24 10	 mov	 ecx, DWORD PTR _elems$[esp+20]
  00069	40		 inc	 eax
  0006a	3b c1		 cmp	 eax, ecx
  0006c	7c c9		 jl	 SHORT $L1975
$L2672:

; 643  :         }
; 644  :     }
; 645  : 
; 646  :     /* The pkzip format requires that at least one distance code exists,
; 647  :      * and that at least one bit should be sent even if there is only one
; 648  :      * possible code. So to avoid special checks later on we force at least
; 649  :      * two codes of non zero frequency.
; 650  :      */
; 651  :     while (s->heap_len < 2) {

  0006e	83 be 48 14 00
	00 02		 cmp	 DWORD PTR [esi+5192], 2
  00075	7d 56		 jge	 SHORT $L1982
$L1981:

; 652  :         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);

  00077	83 fd 02	 cmp	 ebp, 2
  0007a	7d 05		 jge	 SHORT $L2667
  0007c	45		 inc	 ebp
  0007d	8b c5		 mov	 eax, ebp
  0007f	eb 02		 jmp	 SHORT $L2668
$L2667:
  00081	33 c0		 xor	 eax, eax
$L2668:
  00083	8b 8e 48 14 00
	00		 mov	 ecx, DWORD PTR [esi+5192]
  00089	41		 inc	 ecx
  0008a	89 8e 48 14 00
	00		 mov	 DWORD PTR [esi+5192], ecx
  00090	89 84 8e 54 0b
	00 00		 mov	 DWORD PTR [esi+ecx*4+2900], eax

; 653  :         tree[node].Freq = 1;

  00097	66 c7 04 87 01
	00		 mov	 WORD PTR [edi+eax*4], 1

; 654  :         s->depth[node] = 0;

  0009d	88 94 06 50 14
	00 00		 mov	 BYTE PTR [esi+eax+5200], dl

; 655  :         s->opt_len--; if (stree) s->static_len -= stree[node].Len;

  000a4	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  000aa	49		 dec	 ecx
  000ab	3b da		 cmp	 ebx, edx
  000ad	89 8e a0 16 00
	00		 mov	 DWORD PTR [esi+5792], ecx
  000b3	74 0b		 je	 SHORT $L1983
  000b5	0f b7 44 83 02	 movzx	 eax, WORD PTR [ebx+eax*4+2]
  000ba	29 86 a4 16 00
	00		 sub	 DWORD PTR [esi+5796], eax
$L1983:
  000c0	83 be 48 14 00
	00 02		 cmp	 DWORD PTR [esi+5192], 2
  000c7	7c ae		 jl	 SHORT $L1981

; 652  :         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);

  000c9	89 6c 24 0c	 mov	 DWORD PTR _max_code$[esp+20], ebp
$L1982:

; 656  :         /* node is 0 or 1 so it does not have extra bits */
; 657  :     }
; 658  :     desc->max_code = max_code;

  000cd	8b 4c 24 18	 mov	 ecx, DWORD PTR _desc$[esp+16]
  000d1	89 69 04	 mov	 DWORD PTR [ecx+4], ebp

; 659  : 
; 660  :     /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
; 661  :      * establish sub-heaps of increasing lengths:
; 662  :      */
; 663  :     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

  000d4	8b 86 48 14 00
	00		 mov	 eax, DWORD PTR [esi+5192]
  000da	99		 cdq
  000db	2b c2		 sub	 eax, edx
  000dd	8b d8		 mov	 ebx, eax
  000df	d1 fb		 sar	 ebx, 1
  000e1	83 fb 01	 cmp	 ebx, 1
  000e4	7c 0e		 jl	 SHORT $L1986
$L1984:
  000e6	53		 push	 ebx
  000e7	8b c6		 mov	 eax, esi
  000e9	e8 00 00 00 00	 call	 @pqdownheap@12
  000ee	4b		 dec	 ebx
  000ef	83 fb 01	 cmp	 ebx, 1
  000f2	7d f2		 jge	 SHORT $L1984
$L1986:

; 664  : 
; 665  :     /* Construct the Huffman tree by repeatedly combining the least two
; 666  :      * frequent nodes.
; 667  :      */
; 668  :     node = elems;              /* next internal node of the tree */

  000f4	8b 6c 24 10	 mov	 ebp, DWORD PTR _elems$[esp+20]
  000f8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L1987:

; 669  :     do {
; 670  :         pqremove(s, tree, n);  /* n = node of least frequency */

  00100	8b 86 48 14 00
	00		 mov	 eax, DWORD PTR [esi+5192]
  00106	8b 94 86 54 0b
	00 00		 mov	 edx, DWORD PTR [esi+eax*4+2900]
  0010d	8b 9e 58 0b 00
	00		 mov	 ebx, DWORD PTR [esi+2904]
  00113	48		 dec	 eax
  00114	89 86 48 14 00
	00		 mov	 DWORD PTR [esi+5192], eax
  0011a	6a 01		 push	 1
  0011c	8b c6		 mov	 eax, esi
  0011e	89 96 58 0b 00
	00		 mov	 DWORD PTR [esi+2904], edx
  00124	e8 00 00 00 00	 call	 @pqdownheap@12

; 671  :         m = s->heap[SMALLEST]; /* m = node of next least frequency */
; 672  : 
; 673  :         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */

  00129	8b 96 4c 14 00
	00		 mov	 edx, DWORD PTR [esi+5196]
  0012f	8b 86 58 0b 00
	00		 mov	 eax, DWORD PTR [esi+2904]
  00135	4a		 dec	 edx
  00136	89 96 4c 14 00
	00		 mov	 DWORD PTR [esi+5196], edx
  0013c	8b ca		 mov	 ecx, edx
  0013e	89 9c 8e 54 0b
	00 00		 mov	 DWORD PTR [esi+ecx*4+2900], ebx

; 674  :         s->heap[--(s->heap_max)] = m;

  00145	8b 8e 4c 14 00
	00		 mov	 ecx, DWORD PTR [esi+5196]
  0014b	49		 dec	 ecx
  0014c	89 8e 4c 14 00
	00		 mov	 DWORD PTR [esi+5196], ecx
  00152	89 84 8e 54 0b
	00 00		 mov	 DWORD PTR [esi+ecx*4+2900], eax

; 675  : 
; 676  :         /* Create a new node father of n and m */
; 677  :         tree[node].Freq = tree[n].Freq + tree[m].Freq;

  00159	66 8b 0c 87	 mov	 cx, WORD PTR [edi+eax*4]
  0015d	66 03 0c 9f	 add	 cx, WORD PTR [edi+ebx*4]
  00161	66 89 0c af	 mov	 WORD PTR [edi+ebp*4], cx

; 678  :         s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);

  00165	8a 8c 06 50 14
	00 00		 mov	 cl, BYTE PTR [esi+eax+5200]
  0016c	8a 94 1e 50 14
	00 00		 mov	 dl, BYTE PTR [esi+ebx+5200]
  00173	3a d1		 cmp	 dl, cl
  00175	72 05		 jb	 SHORT $L2669
  00177	0f b6 ca	 movzx	 ecx, dl
  0017a	eb 03		 jmp	 SHORT $L2670
$L2669:
  0017c	0f b6 c9	 movzx	 ecx, cl
$L2670:
  0017f	fe c1		 inc	 cl
  00181	88 8c 2e 50 14
	00 00		 mov	 BYTE PTR [esi+ebp+5200], cl

; 679  :         tree[n].Dad = tree[m].Dad = (ush)node;

  00188	66 89 6c 87 02	 mov	 WORD PTR [edi+eax*4+2], bp
  0018d	66 89 6c 9f 02	 mov	 WORD PTR [edi+ebx*4+2], bp

; 680  : #ifdef DUMP_BL_TREE
; 681  :         if (tree == s->bl_tree) {
; 682  :             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
; 683  :                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
; 684  :         }
; 685  : #endif
; 686  :         /* and insert the new node in the heap */
; 687  :         s->heap[SMALLEST] = node++;

  00192	89 ae 58 0b 00
	00		 mov	 DWORD PTR [esi+2904], ebp

; 688  :         pqdownheap(s, tree, SMALLEST);

  00198	6a 01		 push	 1
  0019a	8b c6		 mov	 eax, esi
  0019c	45		 inc	 ebp
  0019d	e8 00 00 00 00	 call	 @pqdownheap@12

; 689  : 
; 690  :     } while (s->heap_len >= 2);

  001a2	83 be 48 14 00
	00 02		 cmp	 DWORD PTR [esi+5192], 2
  001a9	0f 8d 51 ff ff
	ff		 jge	 $L1987

; 691  : 
; 692  :     s->heap[--(s->heap_max)] = s->heap[SMALLEST];

  001af	8b 86 4c 14 00
	00		 mov	 eax, DWORD PTR [esi+5196]
  001b5	8b 96 58 0b 00
	00		 mov	 edx, DWORD PTR [esi+2904]

; 693  : 
; 694  :     /* At this point, the fields freq and dad are set. We can now
; 695  :      * generate the bit lengths.
; 696  :      */
; 697  :     gen_bitlen(s, (tree_desc *)desc);

  001bb	8b 4c 24 18	 mov	 ecx, DWORD PTR _desc$[esp+16]
  001bf	48		 dec	 eax
  001c0	89 86 4c 14 00
	00		 mov	 DWORD PTR [esi+5196], eax
  001c6	89 94 86 54 0b
	00 00		 mov	 DWORD PTR [esi+eax*4+2900], edx
  001cd	8b c6		 mov	 eax, esi
  001cf	e8 00 00 00 00	 call	 @gen_bitlen@8

; 698  : 
; 699  :     /* The field len is now set, we can generate the bit codes */
; 700  :     gen_codes ((ct_data *)tree, max_code, s->bl_count);

  001d4	8b 5c 24 0c	 mov	 ebx, DWORD PTR _max_code$[esp+20]
  001d8	8d 96 34 0b 00
	00		 lea	 edx, DWORD PTR [esi+2868]
  001de	e8 00 00 00 00	 call	 @gen_codes@12
  001e3	5f		 pop	 edi
  001e4	5d		 pop	 ebp
  001e5	5b		 pop	 ebx

; 701  : }

  001e6	83 c4 08	 add	 esp, 8
  001e9	c2 04 00	 ret	 4
@build_tree@8 ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT @build_bl_tree@4
_TEXT	SEGMENT
@build_bl_tree@4 PROC NEAR				; COMDAT
; _s$ = eax

; 805  : {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 806  :     int max_blindex;  /* index of last bit length code of non zero freq */
; 807  : 
; 808  :     /* Determine the bit length frequencies for literal and distance trees */
; 809  :     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);

  00003	8b 8e 14 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2836]
  00009	8d 86 8c 00 00
	00		 lea	 eax, DWORD PTR [esi+140]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 @scan_tree@12

; 810  :     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

  00015	8b 8e 20 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2848]
  0001b	8d 86 80 09 00
	00		 lea	 eax, DWORD PTR [esi+2432]
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 @scan_tree@12

; 811  : 
; 812  :     /* Build the bit length tree: */
; 813  :     build_tree(s, (tree_desc *)(&(s->bl_desc)));

  00027	8d 86 28 0b 00
	00		 lea	 eax, DWORD PTR [esi+2856]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 @build_tree@8

; 814  :     /* opt_len now includes the length of the tree representations, except
; 815  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 816  :      */
; 817  : 
; 818  :     /* Determine the number of bit length codes to send. The pkzip format
; 819  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 820  :      * 3 but the actual value used is 4.)
; 821  :      */
; 822  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  00033	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  00038	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L2159:

; 823  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  00040	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _bl_order[eax]
  00047	66 83 bc 8e 76
	0a 00 00 00	 cmp	 WORD PTR [esi+ecx*4+2678], 0
  00050	75 06		 jne	 SHORT $L2681
  00052	48		 dec	 eax
  00053	83 f8 03	 cmp	 eax, 3
  00056	7d e8		 jge	 SHORT $L2159
$L2681:

; 824  :     }
; 825  :     /* Update opt_len to include the bit length tree and counts */
; 826  :     s->opt_len += 3*(max_blindex+1) + 5+5+4;

  00058	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  0005e	8d 54 40 11	 lea	 edx, DWORD PTR [eax+eax*2+17]
  00062	03 ca		 add	 ecx, edx
  00064	89 8e a0 16 00
	00		 mov	 DWORD PTR [esi+5792], ecx
  0006a	5e		 pop	 esi

; 827  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 828  :             s->opt_len, s->static_len));
; 829  : 
; 830  :     return max_blindex;
; 831  : }

  0006b	c3		 ret	 0
@build_bl_tree@4 ENDP
_TEXT	ENDS
PUBLIC	@_tr_stored_block@16
; Function compile flags: /Ogty
;	COMDAT @_tr_stored_block@16
_TEXT	SEGMENT
_stored_len$ = 8					; size = 4
_eof$ = 12						; size = 4
@_tr_stored_block@16 PROC NEAR				; COMDAT
; _s$ = ecx
; _buf$ = edx

; 872  : {

  00000	8b c1		 mov	 eax, ecx

; 873  :     send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */

  00002	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  00008	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0000b	57		 push	 edi
  0000c	8b fa		 mov	 edi, edx
  0000e	7e 66		 jle	 SHORT $L2232
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 74 24 14	 mov	 esi, DWORD PTR _eof$[esp+8]
  00016	8b d6		 mov	 edx, esi
  00018	d3 e2		 shl	 edx, cl
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00024	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00027	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  0002d	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00030	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00033	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00039	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003c	41		 inc	 ecx
  0003d	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00040	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00043	ff 40 14	 inc	 DWORD PTR [eax+20]
  00046	8b 98 b4 16 00
	00		 mov	 ebx, DWORD PTR [eax+5812]
  0004c	b1 10		 mov	 cl, 16			; 00000010H
  0004e	2a cb		 sub	 cl, bl
  00050	66 d3 ee	 shr	 si, cl

; 874  : #ifdef DEBUG
; 875  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 876  :     s->compressed_len += (stored_len + 4) << 3;
; 877  : #endif
; 878  :     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */

  00053	8b 4c 24 10	 mov	 ecx, DWORD PTR _stored_len$[esp+8]
  00057	83 c3 f3	 add	 ebx, -13		; fffffff3H
  0005a	89 98 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ebx
  00060	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	6a 01		 push	 1
  0006b	8b d7		 mov	 edx, edi
  0006d	e8 00 00 00 00	 call	 @copy_block@16
  00072	5f		 pop	 edi

; 879  : }

  00073	c2 08 00	 ret	 8
$L2232:

; 873  :     send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */

  00076	8b 54 24 0c	 mov	 edx, DWORD PTR _eof$[esp]
  0007a	d3 e2		 shl	 edx, cl
  0007c	83 c1 03	 add	 ecx, 3
  0007f	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx

; 874  : #ifdef DEBUG
; 875  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 876  :     s->compressed_len += (stored_len + 4) << 3;
; 877  : #endif
; 878  :     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */

  00085	8b 4c 24 08	 mov	 ecx, DWORD PTR _stored_len$[esp]
  00089	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00090	6a 01		 push	 1
  00092	8b d7		 mov	 edx, edi
  00094	e8 00 00 00 00	 call	 @copy_block@16
  00099	5f		 pop	 edi

; 879  : }

  0009a	c2 08 00	 ret	 8
@_tr_stored_block@16 ENDP
_TEXT	ENDS
PUBLIC	@_tr_align@4
; Function compile flags: /Ogty
;	COMDAT @_tr_align@4
_TEXT	SEGMENT
@_tr_align@4 PROC NEAR					; COMDAT
; _s$ = ecx

; 894  : {

  00000	8b c1		 mov	 eax, ecx

; 895  :     send_bits(s, STATIC_TREES<<1, 3);

  00002	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  00008	ba 02 00 00 00	 mov	 edx, 2
  0000d	d3 e2		 shl	 edx, cl
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00018	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0001b	7e 4d		 jle	 SHORT $L2248
  0001d	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00020	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00026	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00029	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0002c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002f	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00035	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00038	41		 inc	 ecx
  00039	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0003c	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0003f	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00045	8b 58 14	 mov	 ebx, DWORD PTR [eax+20]
  00048	b1 10		 mov	 cl, 16			; 00000010H
  0004a	2a ca		 sub	 cl, dl
  0004c	be 02 00 00 00	 mov	 esi, 2
  00051	66 d3 ee	 shr	 si, cl
  00054	43		 inc	 ebx
  00055	83 c2 f3	 add	 edx, -13		; fffffff3H
  00058	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  0005b	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  00062	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  00068	eb 09		 jmp	 SHORT $L2256
$L2248:
  0006a	83 c1 03	 add	 ecx, 3
  0006d	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2256:

; 896  :     send_code(s, END_BLOCK, static_ltree);

  00073	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  00079	33 d2		 xor	 edx, edx
  0007b	d3 e2		 shl	 edx, cl
  0007d	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00084	83 f9 09	 cmp	 ecx, 9
  00087	7e 4a		 jle	 SHORT $L2260
  00089	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0008c	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00092	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00095	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00098	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0009b	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  000a1	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000a4	41		 inc	 ecx
  000a5	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  000a8	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  000ab	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  000b1	8b 58 14	 mov	 ebx, DWORD PTR [eax+20]
  000b4	b1 10		 mov	 cl, 16			; 00000010H
  000b6	2a ca		 sub	 cl, dl
  000b8	33 f6		 xor	 esi, esi
  000ba	66 d3 ee	 shr	 si, cl
  000bd	43		 inc	 ebx
  000be	83 c2 f7	 add	 edx, -9			; fffffff7H
  000c1	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  000c4	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  000cb	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  000d1	eb 09		 jmp	 SHORT $L2268
$L2260:
  000d3	83 c1 07	 add	 ecx, 7
  000d6	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2268:

; 897  : #ifdef DEBUG
; 898  :     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
; 899  : #endif
; 900  :     bi_flush(s);

  000dc	e8 00 00 00 00	 call	 @bi_flush@4

; 901  :     /* Of the 10 bits for the empty block, we have already sent
; 902  :      * (10 - bi_valid) bits. The lookahead for the last real code (before
; 903  :      * the EOB of the previous block) was thus at least one plus the length
; 904  :      * of the EOB plus what we have just sent of the empty static block.
; 905  :      */
; 906  :     if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {

  000e1	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  000e7	8b 90 ac 16 00
	00		 mov	 edx, DWORD PTR [eax+5804]
  000ed	2b d1		 sub	 edx, ecx
  000ef	83 c2 0b	 add	 edx, 11			; 0000000bH
  000f2	83 fa 09	 cmp	 edx, 9
  000f5	0f 8d e7 00 00
	00		 jge	 $L2687

; 907  :         send_bits(s, STATIC_TREES<<1, 3);

  000fb	ba 02 00 00 00	 mov	 edx, 2
  00100	d3 e2		 shl	 edx, cl
  00102	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00109	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0010c	7e 4d		 jle	 SHORT $L2273
  0010e	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00111	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00117	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0011a	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0011d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00120	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00126	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00129	41		 inc	 ecx
  0012a	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0012d	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00130	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  00136	8b 58 14	 mov	 ebx, DWORD PTR [eax+20]
  00139	b1 10		 mov	 cl, 16			; 00000010H
  0013b	2a ca		 sub	 cl, dl
  0013d	be 02 00 00 00	 mov	 esi, 2
  00142	66 d3 ee	 shr	 si, cl
  00145	43		 inc	 ebx
  00146	83 c2 f3	 add	 edx, -13		; fffffff3H
  00149	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  0014c	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  00153	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx
  00159	eb 09		 jmp	 SHORT $L2281
$L2273:
  0015b	83 c1 03	 add	 ecx, 3
  0015e	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx
$L2281:

; 908  :         send_code(s, END_BLOCK, static_ltree);

  00164	8b 88 b4 16 00
	00		 mov	 ecx, DWORD PTR [eax+5812]
  0016a	33 d2		 xor	 edx, edx
  0016c	d3 e2		 shl	 edx, cl
  0016e	66 09 90 b0 16
	00 00		 or	 WORD PTR [eax+5808], dx
  00175	83 f9 09	 cmp	 ecx, 9
  00178	7e 5a		 jle	 SHORT $L2285
  0017a	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0017d	8a 98 b0 16 00
	00		 mov	 bl, BYTE PTR [eax+5808]
  00183	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00186	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  00189	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0018c	8a 98 b1 16 00
	00		 mov	 bl, BYTE PTR [eax+5809]
  00192	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00195	41		 inc	 ecx
  00196	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00199	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  0019c	8b 90 b4 16 00
	00		 mov	 edx, DWORD PTR [eax+5812]
  001a2	8b 58 14	 mov	 ebx, DWORD PTR [eax+20]
  001a5	b1 10		 mov	 cl, 16			; 00000010H
  001a7	2a ca		 sub	 cl, dl
  001a9	33 f6		 xor	 esi, esi
  001ab	66 d3 ee	 shr	 si, cl
  001ae	43		 inc	 ebx
  001af	83 c2 f7	 add	 edx, -9			; fffffff7H
  001b2	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  001b5	66 89 b0 b0 16
	00 00		 mov	 WORD PTR [eax+5808], si
  001bc	89 90 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], edx

; 909  : #ifdef DEBUG
; 910  :         s->compressed_len += 10L;
; 911  : #endif
; 912  :         bi_flush(s);

  001c2	e8 00 00 00 00	 call	 @bi_flush@4
  001c7	5e		 pop	 esi

; 913  :     }
; 914  :     s->last_eob_len = 7;

  001c8	c7 80 ac 16 00
	00 07 00 00 00	 mov	 DWORD PTR [eax+5804], 7
  001d2	5b		 pop	 ebx

; 915  : }

  001d3	c3		 ret	 0
$L2285:

; 908  :         send_code(s, END_BLOCK, static_ltree);

  001d4	83 c1 07	 add	 ecx, 7
  001d7	89 88 b4 16 00
	00		 mov	 DWORD PTR [eax+5812], ecx

; 909  : #ifdef DEBUG
; 910  :         s->compressed_len += 10L;
; 911  : #endif
; 912  :         bi_flush(s);

  001dd	e8 00 00 00 00	 call	 @bi_flush@4
$L2687:
  001e2	5e		 pop	 esi

; 913  :     }
; 914  :     s->last_eob_len = 7;

  001e3	c7 80 ac 16 00
	00 07 00 00 00	 mov	 DWORD PTR [eax+5804], 7
  001ed	5b		 pop	 ebx

; 915  : }

  001ee	c3		 ret	 0
@_tr_align@4 ENDP
_TEXT	ENDS
PUBLIC	@_tr_flush_block@16
; Function compile flags: /Ogty
;	COMDAT @_tr_flush_block@16
_TEXT	SEGMENT
_stored_len$ = 8					; size = 4
tv404 = 12						; size = 4
_eof$ = 12						; size = 4
@_tr_flush_block@16 PROC NEAR				; COMDAT
; _s$ = ecx
; _buf$ = edx

; 926  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 927  :     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
; 928  :     int max_blindex = 0;  /* index of last bit length code of non zero freq */
; 929  : 
; 930  :     /* Build the Huffman trees unless a stored block is forced */
; 931  :     if (s->level > 0) {

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _stored_len$[esp+4]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  0000c	33 c0		 xor	 eax, eax
  0000e	85 c9		 test	 ecx, ecx
  00010	57		 push	 edi
  00011	8b da		 mov	 ebx, edx
  00013	7e 4a		 jle	 SHORT $L2303

; 932  : 
; 933  : 	 /* Check if the file is ascii or binary */
; 934  : 	if (s->data_type == Z_UNKNOWN) set_data_type(s);

  00015	80 7e 1c 02	 cmp	 BYTE PTR [esi+28], 2
  00019	75 07		 jne	 SHORT $L2304
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 @set_data_type@4
$L2304:

; 935  : 
; 936  : 	/* Construct the literal and distance trees */
; 937  : 	build_tree(s, (tree_desc *)(&(s->l_desc)));

  00022	8d 86 10 0b 00
	00		 lea	 eax, DWORD PTR [esi+2832]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 @build_tree@8

; 938  : 	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
; 939  : 		s->static_len));
; 940  : 
; 941  : 	build_tree(s, (tree_desc *)(&(s->d_desc)));

  0002e	8d 8e 1c 0b 00
	00		 lea	 ecx, DWORD PTR [esi+2844]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 @build_tree@8

; 942  : 	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
; 943  : 		s->static_len));
; 944  : 	/* At this point, opt_len and static_len are the total bit lengths of
; 945  : 	 * the compressed block data, excluding the tree representations.
; 946  : 	 */
; 947  : 
; 948  : 	/* Build the bit length tree for the above two trees, and get the index
; 949  : 	 * in bl_order of the last bit length code to send.
; 950  : 	 */
; 951  : 	max_blindex = build_bl_tree(s);

  0003a	8b c6		 mov	 eax, esi
  0003c	e8 00 00 00 00	 call	 @build_bl_tree@4

; 952  : 
; 953  : 	/* Determine the best encoding. Compute first the block length in bytes*/
; 954  : 	opt_lenb = (s->opt_len+3+7)>>3;

  00041	8b 96 a0 16 00
	00		 mov	 edx, DWORD PTR [esi+5792]

; 955  : 	static_lenb = (s->static_len+3+7)>>3;

  00047	8b 8e a4 16 00
	00		 mov	 ecx, DWORD PTR [esi+5796]
  0004d	83 c2 0a	 add	 edx, 10			; 0000000aH
  00050	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00053	c1 ea 03	 shr	 edx, 3
  00056	c1 e9 03	 shr	 ecx, 3

; 956  : 
; 957  : 	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
; 958  : 		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
; 959  : 		s->last_lit));
; 960  : 
; 961  : 	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

  00059	3b ca		 cmp	 ecx, edx
  0005b	77 07		 ja	 SHORT $L2308

; 962  : 
; 963  :     } else {

  0005d	eb 03		 jmp	 SHORT $L2690
$L2303:

; 964  :         Assert(buf != (char*)0, "lost buf");
; 965  : 	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */

  0005f	8d 4d 05	 lea	 ecx, DWORD PTR [ebp+5]
$L2690:
  00062	8b d1		 mov	 edx, ecx
$L2308:

; 966  :     }
; 967  : 
; 968  : #ifdef FORCE_STORED
; 969  :     if (buf != (char*)0) { /* force stored block */
; 970  : #else
; 971  :     if (stored_len+4 <= opt_lenb && buf != (char*)0) {

  00064	8d 7d 04	 lea	 edi, DWORD PTR [ebp+4]
  00067	3b fa		 cmp	 edi, edx
  00069	77 18		 ja	 SHORT $L2310
  0006b	85 db		 test	 ebx, ebx
  0006d	74 14		 je	 SHORT $L2310

; 972  :                        /* 4: two words for the lengths */
; 973  : #endif
; 974  :         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
; 975  :          * Otherwise we can't have processed more than WSIZE input bytes since
; 976  :          * the last block flush, because compression would have been
; 977  :          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
; 978  :          * transform a block into a stored block.
; 979  :          */
; 980  :         _tr_stored_block(s, buf, stored_len, eof);

  0006f	8b 7c 24 18	 mov	 edi, DWORD PTR _eof$[esp+12]
  00073	57		 push	 edi
  00074	55		 push	 ebp
  00075	8b d3		 mov	 edx, ebx
  00077	8b ce		 mov	 ecx, esi
  00079	e8 00 00 00 00	 call	 @_tr_stored_block@16

; 981  : 
; 982  : #ifdef FORCE_STATIC
; 983  :     } else if (static_lenb >= 0) { /* force static trees */
; 984  : #else
; 985  :     } else if (static_lenb == opt_lenb) {

  0007e	e9 40 01 00 00	 jmp	 $L2327
$L2310:

; 986  : #endif
; 987  :         send_bits(s, (STATIC_TREES<<1)+eof, 3);

  00083	8b 7c 24 18	 mov	 edi, DWORD PTR _eof$[esp+12]
  00087	3b ca		 cmp	 ecx, edx
  00089	8b 8e b4 16 00
	00		 mov	 ecx, DWORD PTR [esi+5812]
  0008f	0f 85 8b 00 00
	00		 jne	 $L2312
  00095	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00098	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  0009b	7e 62		 jle	 SHORT $L2316
  0009d	8b d0		 mov	 edx, eax
  0009f	d3 e2		 shl	 edx, cl
  000a1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 988  :         compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);

  000a4	68 00 00 00 00	 push	 OFFSET FLAT:_static_dtree
  000a9	68 00 00 00 00	 push	 OFFSET FLAT:_static_ltree
  000ae	66 09 96 b0 16
	00 00		 or	 WORD PTR [esi+5808], dx
  000b5	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000b8	8a 9e b0 16 00
	00		 mov	 bl, BYTE PTR [esi+5808]
  000be	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  000c1	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000c4	8a 9e b1 16 00
	00		 mov	 bl, BYTE PTR [esi+5809]
  000ca	42		 inc	 edx
  000cb	89 56 14	 mov	 DWORD PTR [esi+20], edx
  000ce	8b ca		 mov	 ecx, edx
  000d0	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d3	88 1c 11	 mov	 BYTE PTR [ecx+edx], bl
  000d6	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000d9	8b 96 b4 16 00
	00		 mov	 edx, DWORD PTR [esi+5812]
  000df	41		 inc	 ecx
  000e0	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  000e3	b1 10		 mov	 cl, 16			; 00000010H
  000e5	2a ca		 sub	 cl, dl
  000e7	66 d3 e8	 shr	 ax, cl
  000ea	83 c2 f3	 add	 edx, -13		; fffffff3H
  000ed	89 96 b4 16 00
	00		 mov	 DWORD PTR [esi+5812], edx
  000f3	66 89 86 b0 16
	00 00		 mov	 WORD PTR [esi+5808], ax

; 989  : #ifdef DEBUG
; 990  :         s->compressed_len += 3 + s->static_len;
; 991  : #endif
; 992  :     } else {

  000fa	e9 bd 00 00 00	 jmp	 $L2691
$L2316:

; 986  : #endif
; 987  :         send_bits(s, (STATIC_TREES<<1)+eof, 3);

  000ff	d3 e0		 shl	 eax, cl

; 988  :         compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);

  00101	68 00 00 00 00	 push	 OFFSET FLAT:_static_dtree
  00106	68 00 00 00 00	 push	 OFFSET FLAT:_static_ltree
  0010b	66 09 86 b0 16
	00 00		 or	 WORD PTR [esi+5808], ax
  00112	83 c1 03	 add	 ecx, 3
  00115	89 8e b4 16 00
	00		 mov	 DWORD PTR [esi+5812], ecx

; 989  : #ifdef DEBUG
; 990  :         s->compressed_len += 3 + s->static_len;
; 991  : #endif
; 992  :     } else {

  0011b	e9 9c 00 00 00	 jmp	 $L2691
$L2312:

; 993  :         send_bits(s, (DYN_TREES<<1)+eof, 3);

  00120	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00123	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00126	7e 5b		 jle	 SHORT $L2331
  00128	8b da		 mov	 ebx, edx
  0012a	d3 e3		 shl	 ebx, cl
  0012c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0012f	89 44 24 18	 mov	 DWORD PTR tv404[esp+12], eax
  00133	66 09 9e b0 16
	00 00		 or	 WORD PTR [esi+5808], bx
  0013a	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  0013d	8a 86 b0 16 00
	00		 mov	 al, BYTE PTR [esi+5808]
  00143	88 04 19	 mov	 BYTE PTR [ecx+ebx], al
  00146	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00149	8a 86 b1 16 00
	00		 mov	 al, BYTE PTR [esi+5809]
  0014f	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  00152	41		 inc	 ecx
  00153	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  00156	88 04 19	 mov	 BYTE PTR [ecx+ebx], al
  00159	8b 9e b4 16 00
	00		 mov	 ebx, DWORD PTR [esi+5812]
  0015f	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00162	b1 10		 mov	 cl, 16			; 00000010H
  00164	2a cb		 sub	 cl, bl
  00166	66 d3 ea	 shr	 dx, cl
  00169	40		 inc	 eax
  0016a	83 c3 f3	 add	 ebx, -13		; fffffff3H
  0016d	89 46 14	 mov	 DWORD PTR [esi+20], eax
  00170	8b 44 24 18	 mov	 eax, DWORD PTR tv404[esp+12]
  00174	66 89 96 b0 16
	00 00		 mov	 WORD PTR [esi+5808], dx
  0017b	89 9e b4 16 00
	00		 mov	 DWORD PTR [esi+5812], ebx
  00181	eb 12		 jmp	 SHORT $L2339
$L2331:
  00183	d3 e2		 shl	 edx, cl
  00185	66 09 96 b0 16
	00 00		 or	 WORD PTR [esi+5808], dx
  0018c	83 c1 03	 add	 ecx, 3
  0018f	89 8e b4 16 00
	00		 mov	 DWORD PTR [esi+5812], ecx
$L2339:

; 994  :         send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
; 995  :                        max_blindex+1);

  00195	8b 8e 14 0b 00
	00		 mov	 ecx, DWORD PTR [esi+2836]
  0019b	40		 inc	 eax
  0019c	50		 push	 eax
  0019d	8b 86 20 0b 00
	00		 mov	 eax, DWORD PTR [esi+2848]
  001a3	40		 inc	 eax
  001a4	50		 push	 eax
  001a5	41		 inc	 ecx
  001a6	51		 push	 ecx
  001a7	8b c6		 mov	 eax, esi
  001a9	e8 00 00 00 00	 call	 @send_all_trees@16

; 996  :         compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);

  001ae	8d 96 80 09 00
	00		 lea	 edx, DWORD PTR [esi+2432]
  001b4	52		 push	 edx
  001b5	8d 86 8c 00 00
	00		 lea	 eax, DWORD PTR [esi+140]
  001bb	50		 push	 eax
$L2691:
  001bc	8b c6		 mov	 eax, esi
  001be	e8 00 00 00 00	 call	 @compress_block@12
$L2327:

; 997  : #ifdef DEBUG
; 998  :         s->compressed_len += 3 + s->opt_len;
; 999  : #endif
; 1000 :     }
; 1001 :     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
; 1002 :     /* The above check is made mod 2^32, for files larger than 512 MB
; 1003 :      * and uLong implemented on 32 bits.
; 1004 :      */
; 1005 :     init_block(s);

  001c3	8b d6		 mov	 edx, esi
  001c5	e8 00 00 00 00	 call	 @init_block@4

; 1006 : 
; 1007 :     if (eof) {

  001ca	85 ff		 test	 edi, edi
  001cc	74 07		 je	 SHORT $L2342

; 1008 :         bi_windup(s);

  001ce	8b c6		 mov	 eax, esi
  001d0	e8 00 00 00 00	 call	 @bi_windup@4
$L2342:
  001d5	5f		 pop	 edi
  001d6	5e		 pop	 esi
  001d7	5d		 pop	 ebp
  001d8	5b		 pop	 ebx

; 1009 : #ifdef DEBUG
; 1010 :         s->compressed_len += 7;  /* align on byte boundary */
; 1011 : #endif
; 1012 :     }
; 1013 :     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
; 1014 :            s->compressed_len-7*eof));
; 1015 : }

  001d9	c2 08 00	 ret	 8
@_tr_flush_block@16 ENDP
_TEXT	ENDS
END
