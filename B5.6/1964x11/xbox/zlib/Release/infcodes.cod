; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\infcodes.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT @inflate_codes_new@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate_codes@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate_codes_free@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	@inflate_codes_new@20
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\infcodes.c
;	COMDAT @inflate_codes_new@20
_TEXT	SEGMENT
_bl$ = -4						; size = 4
_tl$ = 8						; size = 4
_td$ = 12						; size = 4
_z$ = 16						; size = 4
@inflate_codes_new@20 PROC NEAR				; COMDAT
; _bl$ = ecx
; _bd$ = edx

; 64   : {

  00000	51		 push	 ecx

; 65   :   inflate_codes_statef *c;
; 66   : 
; 67   :   if ((c = (inflate_codes_statef *)
; 68   :        ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)

  00001	8b 44 24 10	 mov	 eax, DWORD PTR _z$[esp]
  00005	53		 push	 ebx
  00006	8b da		 mov	 ebx, edx
  00008	89 4c 24 04	 mov	 DWORD PTR _bl$[esp+8], ecx
  0000c	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0000f	6a 1c		 push	 28			; 0000001cH
  00011	ba 01 00 00 00	 mov	 edx, 1
  00016	ff 50 20	 call	 DWORD PTR [eax+32]
  00019	85 c0		 test	 eax, eax
  0001b	74 1e		 je	 SHORT $L1806

; 69   :   {
; 70   :     c->mode = START;
; 71   :     c->lbits = (Byte)bl;

  0001d	8a 4c 24 04	 mov	 cl, BYTE PTR _bl$[esp+8]

; 72   :     c->dbits = (Byte)bd;
; 73   :     c->ltree = tl;

  00021	8b 54 24 0c	 mov	 edx, DWORD PTR _tl$[esp+4]
  00025	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 74   :     c->dtree = td;

  00028	8b 4c 24 10	 mov	 ecx, DWORD PTR _td$[esp+4]
  0002c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00032	88 58 11	 mov	 BYTE PTR [eax+17], bl
  00035	89 50 14	 mov	 DWORD PTR [eax+20], edx
  00038	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$L1806:
  0003b	5b		 pop	 ebx

; 75   :     Tracev((stderr, "inflate:       codes new\n"));
; 76   :   }
; 77   :   return c;
; 78   : }

  0003c	59		 pop	 ecx
  0003d	c2 0c 00	 ret	 12			; 0000000cH
@inflate_codes_new@20 ENDP
_TEXT	ENDS
PUBLIC	@inflate_codes@12
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
EXTRN	_inflate_mask:BYTE
EXTRN	@inflate_flush@12:NEAR
EXTRN	@inflate_fast@24:NEAR
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @inflate_codes@12
_TEXT	SEGMENT
_b$ = -28						; size = 4
_c$ = -24						; size = 4
_n$ = -20						; size = 4
_m$ = -16						; size = 4
tv761 = -12						; size = 4
_t$ = -12						; size = 4
_j$ = -12						; size = 4
_f$ = -8						; size = 4
tv852 = -4						; size = 4
tv755 = -4						; size = 4
_r$ = 8							; size = 4
@inflate_codes@12 PROC NEAR				; COMDAT
; _s$ = ecx
; _z$ = edx

; 85   : {

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 86   :   uInt j;               /* temporary storage */
; 87   :   inflate_huft *t;      /* temporary pointer */
; 88   :   uInt e;               /* extra bits or operation */
; 89   :   uLong b;              /* bit buffer */
; 90   :   uInt k;               /* bits in bit buffer */
; 91   :   Bytef *p;             /* input data pointer */
; 92   :   uInt n;               /* bytes available there */
; 93   :   Bytef *q;             /* output window write pointer */
; 94   :   uInt m;               /* bytes to end of window or read pointer */
; 95   :   Bytef *f;             /* pointer to copy strings from */
; 96   :   inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */

  00008	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 97   : 
; 98   :   /* copy input/output information to locals (UPDATE macro restores) */
; 99   :   LOAD

  0000b	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  0000e	57		 push	 edi
  0000f	8b fa		 mov	 edi, edx
  00011	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00014	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00017	8b 2f		 mov	 ebp, DWORD PTR [edi]
  00019	89 44 24 18	 mov	 DWORD PTR _n$[esp+44], eax
  0001d	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00020	89 54 24 10	 mov	 DWORD PTR _b$[esp+44], edx
  00024	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00027	3b d0		 cmp	 edx, eax
  00029	89 4c 24 14	 mov	 DWORD PTR _c$[esp+44], ecx
  0002d	73 05		 jae	 SHORT $L1945
  0002f	2b c2		 sub	 eax, edx
  00031	48		 dec	 eax
  00032	eb 05		 jmp	 SHORT $L2003
$L1945:
  00034	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00037	2b c2		 sub	 eax, edx
$L2003:

; 100  : 
; 101  :   /* process input and output based on current state */
; 102  :   while (1) switch (c->mode)

  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003b	83 f9 09	 cmp	 ecx, 9
  0003e	89 44 24 1c	 mov	 DWORD PTR _m$[esp+44], eax
  00042	0f 87 49 05 00
	00		 ja	 $L1923
$L1828:
  00048	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L2013[ecx*4]
$L1834:

; 103  :   {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
; 104  :     case START:         /* x: set up for LEN */
; 105  : #ifndef SLOW
; 106  :       if (m >= 258 && n >= 10)

  0004f	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  00054	0f 82 98 00 00
	00		 jb	 $L1838
  0005a	83 7c 24 18 0a	 cmp	 DWORD PTR _n$[esp+44], 10 ; 0000000aH
  0005f	0f 82 8d 00 00
	00		 jb	 $L1838

; 107  :       {
; 108  :         UPDATE

  00065	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+44]
  00069	8b 4c 24 18	 mov	 ecx, DWORD PTR _n$[esp+44]
  0006d	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00070	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  00073	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00075	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00078	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0007b	8b c5		 mov	 eax, ebp
  0007d	2b c3		 sub	 eax, ebx
  0007f	03 c8		 add	 ecx, eax

; 109  :         r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);

  00081	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  00085	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00088	89 2f		 mov	 DWORD PTR [edi], ebp
  0008a	89 56 34	 mov	 DWORD PTR [esi+52], edx
  0008d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00090	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00093	57		 push	 edi
  00094	56		 push	 esi
  00095	51		 push	 ecx
  00096	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0009a	52		 push	 edx
  0009b	0f b6 50 11	 movzx	 edx, BYTE PTR [eax+17]
  0009f	e8 00 00 00 00	 call	 @inflate_fast@24

; 110  :         LOAD

  000a4	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000a7	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  000aa	8b 2f		 mov	 ebp, DWORD PTR [edi]
  000ac	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  000af	89 4c 24 18	 mov	 DWORD PTR _n$[esp+44], ecx
  000b3	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  000b6	89 54 24 10	 mov	 DWORD PTR _b$[esp+44], edx
  000ba	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  000bd	3b d1		 cmp	 edx, ecx
  000bf	89 44 24 30	 mov	 DWORD PTR _r$[esp+40], eax
  000c3	73 05		 jae	 SHORT $L1947
  000c5	2b ca		 sub	 ecx, edx
  000c7	49		 dec	 ecx
  000c8	eb 05		 jmp	 SHORT $L2004
$L1947:
  000ca	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000cd	2b ca		 sub	 ecx, edx
$L2004:

; 111  :         if (r != Z_OK)

  000cf	85 c0		 test	 eax, eax
  000d1	89 4c 24 1c	 mov	 DWORD PTR _m$[esp+44], ecx
  000d5	74 1b		 je	 SHORT $L1838

; 112  :         {
; 113  :           c->mode = r == Z_STREAM_END ? WASH : BADCODE;

  000d7	33 c9		 xor	 ecx, ecx
  000d9	83 f8 01	 cmp	 eax, 1
  000dc	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  000e0	0f 95 c1	 setne	 cl
  000e3	8d 4c 09 07	 lea	 ecx, DWORD PTR [ecx+ecx+7]
  000e7	89 08		 mov	 DWORD PTR [eax], ecx

; 185  :         break;

  000e9	8b 44 24 1c	 mov	 eax, DWORD PTR _m$[esp+44]
  000ed	e9 90 04 00 00	 jmp	 $L1831
$L1838:

; 114  :           break;
; 115  :         }
; 116  :       }
; 117  : #endif /* !SLOW */
; 118  :       c->sub.code.need = c->lbits;

  000f2	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  000f6	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  000fa	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 119  :       c->sub.code.tree = c->ltree;

  000fd	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00100	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 120  :       c->mode = LEN;

  00103	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
$L1998:

; 121  :     case LEN:           /* i: get length/literal/eob next */
; 122  :       j = c->sub.code.need;

  00109	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  0010d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 123  :       NEEDBITS(j)

  00110	3b d8		 cmp	 ebx, eax
  00112	89 44 24 20	 mov	 DWORD PTR _j$[esp+44], eax
  00116	73 3f		 jae	 SHORT $L1981
  00118	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L1841:
  00120	8b 44 24 18	 mov	 eax, DWORD PTR _n$[esp+44]
  00124	85 c0		 test	 eax, eax
  00126	0f 84 bf 04 00
	00		 je	 $L1879
  0012c	48		 dec	 eax
  0012d	89 44 24 18	 mov	 DWORD PTR _n$[esp+44], eax
  00131	0f b6 45 00	 movzx	 eax, BYTE PTR [ebp]
  00135	8b cb		 mov	 ecx, ebx
  00137	d3 e0		 shl	 eax, cl
  00139	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+44]
  0013d	83 c3 08	 add	 ebx, 8
  00140	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _r$[esp+40], 0
  00148	0b c8		 or	 ecx, eax
  0014a	8b 44 24 20	 mov	 eax, DWORD PTR _j$[esp+44]
  0014e	45		 inc	 ebp
  0014f	3b d8		 cmp	 ebx, eax
  00151	89 4c 24 10	 mov	 DWORD PTR _b$[esp+44], ecx
  00155	72 c9		 jb	 SHORT $L1841
$L1981:

; 124  :       t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);

  00157	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _inflate_mask[eax*4]
  0015e	23 4c 24 10	 and	 ecx, DWORD PTR _b$[esp+44]
  00162	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  00166	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00169	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 125  :       DUMPBITS(t->bits)

  0016c	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00170	89 44 24 20	 mov	 DWORD PTR _t$[esp+44], eax
  00174	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+44]
  00178	d3 e8		 shr	 eax, cl
  0017a	8b 4c 24 20	 mov	 ecx, DWORD PTR _t$[esp+44]
  0017e	89 44 24 10	 mov	 DWORD PTR _b$[esp+44], eax
  00182	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00186	2b d8		 sub	 ebx, eax

; 126  :       e = (uInt)(t->exop);

  00188	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 127  :       if (e == 0)               /* literal */

  0018b	85 c0		 test	 eax, eax
  0018d	75 19		 jne	 SHORT $L1848

; 128  :       {
; 129  :         c->sub.lit = t->base;

  0018f	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  00193	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00196	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 130  :         Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
; 131  :                  "inflate:         literal '%c'\n" :
; 132  :                  "inflate:         literal 0x%02x\n", t->base));
; 133  :         c->mode = LIT;

  00199	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6

; 185  :         break;

  0019f	8b 44 24 1c	 mov	 eax, DWORD PTR _m$[esp+44]
  001a3	e9 da 03 00 00	 jmp	 $L1831
$L1848:

; 134  :         break;
; 135  :       }
; 136  :       if (e & 16)               /* length */

  001a8	a8 10		 test	 al, 16			; 00000010H
  001aa	74 23		 je	 SHORT $L1849

; 137  :       {
; 138  :         c->sub.copy.get = e & 15;

  001ac	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  001b0	83 e0 0f	 and	 eax, 15			; 0000000fH
  001b3	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 139  :         c->len = t->base;

  001b6	8b 44 24 20	 mov	 eax, DWORD PTR _t$[esp+44]
  001ba	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001bd	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 185  :         break;

  001c0	8b 44 24 1c	 mov	 eax, DWORD PTR _m$[esp+44]
  001c4	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
  001ca	e9 b3 03 00 00	 jmp	 $L1831
$L1849:

; 140  :         c->mode = LENEXT;
; 141  :         break;
; 142  :       }
; 143  :       if ((e & 64) == 0)        /* next table */

  001cf	a8 40		 test	 al, 64			; 00000040H

; 144  :       {
; 145  :         c->sub.code.need = e;
; 146  :         c->sub.code.tree = t + t->base;
; 147  :         break;

  001d1	0f 84 3d 01 00
	00		 je	 $L2007

; 148  :       }
; 149  :       if (e & 32)               /* end of block */

  001d7	a8 20		 test	 al, 32			; 00000020H

; 150  :       {
; 151  :         Tracevv((stderr, "inflate:         end of block\n"));
; 152  :         c->mode = WASH;

  001d9	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  001dd	0f 84 e2 03 00
	00		 je	 $L1851
  001e3	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7

; 153  :         break;

  001e9	8b 44 24 1c	 mov	 eax, DWORD PTR _m$[esp+44]
  001ed	e9 90 03 00 00	 jmp	 $L1831
$L1854:

; 159  :     case LENEXT:        /* i: getting length extra (have base) */
; 160  :       j = c->sub.copy.get;

  001f2	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  001f6	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 161  :       NEEDBITS(j)

  001f9	3b d8		 cmp	 ebx, eax
  001fb	89 44 24 20	 mov	 DWORD PTR _j$[esp+44], eax
  001ff	73 37		 jae	 SHORT $L1983
$L1856:
  00201	8b 44 24 18	 mov	 eax, DWORD PTR _n$[esp+44]
  00205	85 c0		 test	 eax, eax
  00207	0f 84 de 03 00
	00		 je	 $L1879
  0020d	48		 dec	 eax
  0020e	89 44 24 18	 mov	 DWORD PTR _n$[esp+44], eax
  00212	0f b6 45 00	 movzx	 eax, BYTE PTR [ebp]
  00216	8b cb		 mov	 ecx, ebx
  00218	d3 e0		 shl	 eax, cl
  0021a	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+44]
  0021e	83 c3 08	 add	 ebx, 8
  00221	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _r$[esp+40], 0
  00229	0b c8		 or	 ecx, eax
  0022b	8b 44 24 20	 mov	 eax, DWORD PTR _j$[esp+44]
  0022f	45		 inc	 ebp
  00230	3b d8		 cmp	 ebx, eax
  00232	89 4c 24 10	 mov	 DWORD PTR _b$[esp+44], ecx
  00236	72 c9		 jb	 SHORT $L1856
$L1983:

; 162  :       c->len += (uInt)b & inflate_mask[j];

  00238	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _inflate_mask[eax*4]
  0023f	23 4c 24 10	 and	 ecx, DWORD PTR _b$[esp+44]
  00243	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  00247	01 48 04	 add	 DWORD PTR [eax+4], ecx

; 163  :       DUMPBITS(j)

  0024a	8b 4c 24 20	 mov	 ecx, DWORD PTR _j$[esp+44]
  0024e	d3 6c 24 10	 shr	 DWORD PTR _b$[esp+44], cl
  00252	8b c1		 mov	 eax, ecx
  00254	2b d8		 sub	 ebx, eax

; 164  :       c->sub.code.need = c->dbits;

  00256	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  0025a	0f b6 48 11	 movzx	 ecx, BYTE PTR [eax+17]
  0025e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 165  :       c->sub.code.tree = c->dtree;

  00261	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00264	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 166  :       Tracevv((stderr, "inflate:         length %u\n", c->len));
; 167  :       c->mode = DIST;

  00267	c7 00 03 00 00
	00		 mov	 DWORD PTR [eax], 3
  0026d	eb 04		 jmp	 SHORT $L1862
$L1984:
  0026f	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
$L1862:

; 168  :     case DIST:          /* i: get distance next */
; 169  :       j = c->sub.code.need;

  00273	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 170  :       NEEDBITS(j)

  00276	3b d8		 cmp	 ebx, eax
  00278	89 44 24 20	 mov	 DWORD PTR _j$[esp+44], eax
  0027c	73 39		 jae	 SHORT $L1986
  0027e	8b ff		 npad	 2
$L1864:
  00280	8b 44 24 18	 mov	 eax, DWORD PTR _n$[esp+44]
  00284	85 c0		 test	 eax, eax
  00286	0f 84 5f 03 00
	00		 je	 $L1879
  0028c	48		 dec	 eax
  0028d	89 44 24 18	 mov	 DWORD PTR _n$[esp+44], eax
  00291	0f b6 45 00	 movzx	 eax, BYTE PTR [ebp]
  00295	8b cb		 mov	 ecx, ebx
  00297	d3 e0		 shl	 eax, cl
  00299	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+44]
  0029d	83 c3 08	 add	 ebx, 8
  002a0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _r$[esp+40], 0
  002a8	0b c8		 or	 ecx, eax
  002aa	8b 44 24 20	 mov	 eax, DWORD PTR _j$[esp+44]
  002ae	45		 inc	 ebp
  002af	3b d8		 cmp	 ebx, eax
  002b1	89 4c 24 10	 mov	 DWORD PTR _b$[esp+44], ecx
  002b5	72 c9		 jb	 SHORT $L1864
$L1986:

; 171  :       t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);

  002b7	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _inflate_mask[eax*4]
  002be	23 4c 24 10	 and	 ecx, DWORD PTR _b$[esp+44]
  002c2	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  002c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002c9	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 172  :       DUMPBITS(t->bits)

  002cc	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  002d0	89 44 24 20	 mov	 DWORD PTR _t$[esp+44], eax
  002d4	d3 6c 24 10	 shr	 DWORD PTR _b$[esp+44], cl
  002d8	8b 44 24 20	 mov	 eax, DWORD PTR _t$[esp+44]
  002dc	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]

; 173  :       e = (uInt)(t->exop);

  002e0	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  002e3	2b d9		 sub	 ebx, ecx

; 174  :       if (e & 16)               /* distance */

  002e5	a8 10		 test	 al, 16			; 00000010H
  002e7	74 23		 je	 SHORT $L1871

; 175  :       {
; 176  :         c->sub.copy.get = e & 15;

  002e9	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  002ed	83 e0 0f	 and	 eax, 15			; 0000000fH
  002f0	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 177  :         c->sub.copy.dist = t->base;

  002f3	8b 44 24 20	 mov	 eax, DWORD PTR _t$[esp+44]
  002f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002fa	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 178  :         c->mode = DISTEXT;
; 179  :         break;

  002fd	8b 44 24 1c	 mov	 eax, DWORD PTR _m$[esp+44]
  00301	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4
  00307	e9 76 02 00 00	 jmp	 $L1831
$L1871:

; 180  :       }
; 181  :       if ((e & 64) == 0)        /* next table */

  0030c	a8 40		 test	 al, 64			; 00000040H
  0030e	0f 85 c2 02 00
	00		 jne	 $L1872
$L2007:

; 182  :       {
; 183  :         c->sub.code.need = e;

  00314	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  00318	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 184  :         c->sub.code.tree = t + t->base;

  0031b	8b 44 24 20	 mov	 eax, DWORD PTR _t$[esp+44]
  0031f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00322	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
  00325	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  00329	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 185  :         break;

  0032c	8b 44 24 1c	 mov	 eax, DWORD PTR _m$[esp+44]
  00330	e9 4d 02 00 00	 jmp	 $L1831
$L1875:

; 191  :     case DISTEXT:       /* i: getting distance extra */
; 192  :       j = c->sub.copy.get;

  00335	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  00339	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 193  :       NEEDBITS(j)

  0033c	3b d8		 cmp	 ebx, eax
  0033e	89 44 24 20	 mov	 DWORD PTR _j$[esp+44], eax
  00342	73 37		 jae	 SHORT $L1988
$L1877:
  00344	8b 44 24 18	 mov	 eax, DWORD PTR _n$[esp+44]
  00348	85 c0		 test	 eax, eax
  0034a	0f 84 9b 02 00
	00		 je	 $L1879
  00350	48		 dec	 eax
  00351	89 44 24 18	 mov	 DWORD PTR _n$[esp+44], eax
  00355	0f b6 45 00	 movzx	 eax, BYTE PTR [ebp]
  00359	8b cb		 mov	 ecx, ebx
  0035b	d3 e0		 shl	 eax, cl
  0035d	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+44]
  00361	83 c3 08	 add	 ebx, 8
  00364	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _r$[esp+40], 0
  0036c	0b c8		 or	 ecx, eax
  0036e	8b 44 24 20	 mov	 eax, DWORD PTR _j$[esp+44]
  00372	45		 inc	 ebp
  00373	3b d8		 cmp	 ebx, eax
  00375	89 4c 24 10	 mov	 DWORD PTR _b$[esp+44], ecx
  00379	72 c9		 jb	 SHORT $L1877
$L1988:

; 194  :       c->sub.copy.dist += (uInt)b & inflate_mask[j];

  0037b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _inflate_mask[eax*4]
  00382	23 4c 24 10	 and	 ecx, DWORD PTR _b$[esp+44]
  00386	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  0038a	01 48 0c	 add	 DWORD PTR [eax+12], ecx

; 195  :       DUMPBITS(j)

  0038d	8b 4c 24 20	 mov	 ecx, DWORD PTR _j$[esp+44]
  00391	d3 6c 24 10	 shr	 DWORD PTR _b$[esp+44], cl
  00395	8b c1		 mov	 eax, ecx
  00397	2b d8		 sub	 ebx, eax

; 196  :       Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
; 197  :       c->mode = COPY;

  00399	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  0039d	c7 00 05 00 00
	00		 mov	 DWORD PTR [eax], 5
$L1989:

; 198  :     case COPY:          /* o: copying bytes in window, waiting for space */
; 199  :       f = q - c->sub.copy.dist;

  003a3	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  003a7	8b c2		 mov	 eax, edx
  003a9	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]

; 200  :       while (f < s->window)             /* modulo window size-"while" instead */

  003ac	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  003af	3b c1		 cmp	 eax, ecx
  003b1	89 44 24 24	 mov	 DWORD PTR _f$[esp+44], eax
  003b5	73 24		 jae	 SHORT $L1969
  003b7	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  003ba	2b c1		 sub	 eax, ecx
  003bc	8b 4c 24 24	 mov	 ecx, DWORD PTR _f$[esp+44]
  003c0	89 44 24 28	 mov	 DWORD PTR tv852[esp+44], eax
  003c4	eb 0a		 jmp	 SHORT $L1885
$L1990:

; 198  :     case COPY:          /* o: copying bytes in window, waiting for space */
; 199  :       f = q - c->sub.copy.dist;

  003c6	8b 44 24 28	 mov	 eax, DWORD PTR tv852[esp+44]
  003ca	8d 9b 00 00 00
	00		 npad	 6
$L1885:

; 201  :         f += s->end - s->window;        /* of "if" handles invalid distances */

  003d0	03 c8		 add	 ecx, eax
  003d2	3b 4e 28	 cmp	 ecx, DWORD PTR [esi+40]
  003d5	72 ef		 jb	 SHORT $L1990
  003d7	89 4c 24 24	 mov	 DWORD PTR _f$[esp+44], ecx
$L1969:

; 202  :       while (c->len)

  003db	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  003df	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  003e2	85 c0		 test	 eax, eax
  003e4	8b 44 24 1c	 mov	 eax, DWORD PTR _m$[esp+44]
  003e8	0f 84 8e 01 00
	00		 je	 $L1889
  003ee	8b ff		 npad	 2
$L1888:

; 203  :       {
; 204  :         NEEDOUT

  003f0	85 c0		 test	 eax, eax
  003f2	0f 85 90 00 00
	00		 jne	 $L1993
  003f8	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  003fb	3b d0		 cmp	 edx, eax
  003fd	89 44 24 20	 mov	 DWORD PTR tv761[esp+44], eax
  00401	75 1f		 jne	 SHORT $L1991
  00403	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00406	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00409	3b c1		 cmp	 eax, ecx
  0040b	74 15		 je	 SHORT $L1991
  0040d	8b d1		 mov	 edx, ecx
  0040f	3b d0		 cmp	 edx, eax
  00411	73 05		 jae	 SHORT $L1949
  00413	2b c2		 sub	 eax, edx
  00415	48		 dec	 eax
  00416	eb 06		 jmp	 SHORT $L1950
$L1949:
  00418	8b 44 24 20	 mov	 eax, DWORD PTR tv761[esp+44]
  0041c	2b c2		 sub	 eax, edx
$L1950:
  0041e	85 c0		 test	 eax, eax
  00420	75 66		 jne	 SHORT $L1993
$L1991:
  00422	89 56 34	 mov	 DWORD PTR [esi+52], edx
  00425	8b 54 24 30	 mov	 edx, DWORD PTR _r$[esp+40]
  00429	52		 push	 edx
  0042a	8b d7		 mov	 edx, edi
  0042c	8b ce		 mov	 ecx, esi
  0042e	e8 00 00 00 00	 call	 @inflate_flush@12
  00433	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00436	89 44 24 30	 mov	 DWORD PTR _r$[esp+40], eax
  0043a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0043d	3b d0		 cmp	 edx, eax
  0043f	89 44 24 28	 mov	 DWORD PTR tv755[esp+44], eax
  00443	73 05		 jae	 SHORT $L1951
  00445	2b c2		 sub	 eax, edx
  00447	48		 dec	 eax
  00448	eb 05		 jmp	 SHORT $L2005
$L1951:
  0044a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0044d	2b c2		 sub	 eax, edx
$L2005:
  0044f	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00452	3b d1		 cmp	 edx, ecx
  00454	89 44 24 1c	 mov	 DWORD PTR _m$[esp+44], eax
  00458	89 4c 24 20	 mov	 DWORD PTR tv761[esp+44], ecx
  0045c	75 22		 jne	 SHORT $L2000
  0045e	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00461	8b 44 24 28	 mov	 eax, DWORD PTR tv755[esp+44]
  00465	3b c1		 cmp	 eax, ecx
  00467	74 13		 je	 SHORT $L1992
  00469	8b d1		 mov	 edx, ecx
  0046b	3b d0		 cmp	 edx, eax
  0046d	73 05		 jae	 SHORT $L1953
  0046f	2b c2		 sub	 eax, edx
  00471	48		 dec	 eax
  00472	eb 0c		 jmp	 SHORT $L2000
$L1953:
  00474	8b 44 24 20	 mov	 eax, DWORD PTR tv761[esp+44]
  00478	2b c2		 sub	 eax, edx
  0047a	eb 04		 jmp	 SHORT $L2000
$L1992:
  0047c	8b 44 24 1c	 mov	 eax, DWORD PTR _m$[esp+44]
$L2000:
  00480	85 c0		 test	 eax, eax
  00482	0f 84 9f 01 00
	00		 je	 $L1971
$L1993:

; 205  :         OUTBYTE(*f++)

  00488	8b 4c 24 24	 mov	 ecx, DWORD PTR _f$[esp+44]
  0048c	8a 09		 mov	 cl, BYTE PTR [ecx]
  0048e	88 0a		 mov	 BYTE PTR [edx], cl
  00490	8b 4c 24 24	 mov	 ecx, DWORD PTR _f$[esp+44]
  00494	42		 inc	 edx
  00495	41		 inc	 ecx
  00496	48		 dec	 eax

; 206  :         if (f == s->end)

  00497	3b 4e 2c	 cmp	 ecx, DWORD PTR [esi+44]
  0049a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _r$[esp+40], 0
  004a2	89 4c 24 24	 mov	 DWORD PTR _f$[esp+44], ecx
  004a6	89 44 24 1c	 mov	 DWORD PTR _m$[esp+44], eax
  004aa	75 07		 jne	 SHORT $L1902

; 207  :           f = s->window;

  004ac	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  004af	89 4c 24 24	 mov	 DWORD PTR _f$[esp+44], ecx
$L1902:

; 208  :         c->len--;

  004b3	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  004b7	ff 49 04	 dec	 DWORD PTR [ecx+4]
  004ba	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  004be	0f 85 2c ff ff
	ff		 jne	 $L1888

; 209  :       }
; 210  :       c->mode = START;
; 211  :       break;

  004c4	e9 b3 00 00 00	 jmp	 $L1889
$L1903:

; 212  :     case LIT:           /* o: got literal, waiting for output space */
; 213  :       NEEDOUT

  004c9	85 c0		 test	 eax, eax
  004cb	0f 85 90 00 00
	00		 jne	 $L1914
  004d1	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  004d4	3b d0		 cmp	 edx, eax
  004d6	89 44 24 20	 mov	 DWORD PTR tv761[esp+44], eax
  004da	75 1f		 jne	 SHORT $L1996
  004dc	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  004df	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  004e2	3b c1		 cmp	 eax, ecx
  004e4	74 15		 je	 SHORT $L1996
  004e6	8b d1		 mov	 edx, ecx
  004e8	3b d0		 cmp	 edx, eax
  004ea	73 05		 jae	 SHORT $L1955
  004ec	2b c2		 sub	 eax, edx
  004ee	48		 dec	 eax
  004ef	eb 06		 jmp	 SHORT $L1956
$L1955:
  004f1	8b 44 24 20	 mov	 eax, DWORD PTR tv761[esp+44]
  004f5	2b c2		 sub	 eax, edx
$L1956:
  004f7	85 c0		 test	 eax, eax
  004f9	75 66		 jne	 SHORT $L1914
$L1996:
  004fb	89 56 34	 mov	 DWORD PTR [esi+52], edx
  004fe	8b 54 24 30	 mov	 edx, DWORD PTR _r$[esp+40]
  00502	52		 push	 edx
  00503	8b d7		 mov	 edx, edi
  00505	8b ce		 mov	 ecx, esi
  00507	e8 00 00 00 00	 call	 @inflate_flush@12
  0050c	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  0050f	89 44 24 30	 mov	 DWORD PTR _r$[esp+40], eax
  00513	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00516	3b d0		 cmp	 edx, eax
  00518	89 44 24 28	 mov	 DWORD PTR tv755[esp+44], eax
  0051c	73 05		 jae	 SHORT $L1957
  0051e	2b c2		 sub	 eax, edx
  00520	48		 dec	 eax
  00521	eb 05		 jmp	 SHORT $L2006
$L1957:
  00523	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00526	2b c2		 sub	 eax, edx
$L2006:
  00528	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  0052b	3b d1		 cmp	 edx, ecx
  0052d	89 44 24 1c	 mov	 DWORD PTR _m$[esp+44], eax
  00531	89 4c 24 20	 mov	 DWORD PTR tv761[esp+44], ecx
  00535	75 22		 jne	 SHORT $L2002
  00537	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0053a	8b 44 24 28	 mov	 eax, DWORD PTR tv755[esp+44]
  0053e	3b c1		 cmp	 eax, ecx
  00540	74 13		 je	 SHORT $L1997
  00542	8b d1		 mov	 edx, ecx
  00544	3b d0		 cmp	 edx, eax
  00546	73 05		 jae	 SHORT $L1959
  00548	2b c2		 sub	 eax, edx
  0054a	48		 dec	 eax
  0054b	eb 0c		 jmp	 SHORT $L2002
$L1959:
  0054d	8b 44 24 20	 mov	 eax, DWORD PTR tv761[esp+44]
  00551	2b c2		 sub	 eax, edx
  00553	eb 04		 jmp	 SHORT $L2002
$L1997:
  00555	8b 44 24 1c	 mov	 eax, DWORD PTR _m$[esp+44]
$L2002:
  00559	85 c0		 test	 eax, eax
  0055b	0f 84 c6 00 00
	00		 je	 $L1971
$L1914:

; 214  :       OUTBYTE(c->sub.lit)

  00561	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  00565	8a 49 08	 mov	 cl, BYTE PTR [ecx+8]
  00568	88 0a		 mov	 BYTE PTR [edx], cl

; 215  :       c->mode = START;

  0056a	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  0056e	42		 inc	 edx
  0056f	48		 dec	 eax
  00570	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _r$[esp+40], 0
  00578	89 44 24 1c	 mov	 DWORD PTR _m$[esp+44], eax
$L1889:
  0057c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$L1831:

; 100  : 
; 101  :   /* process input and output based on current state */
; 102  :   while (1) switch (c->mode)

  00582	8b 4c 24 14	 mov	 ecx, DWORD PTR _c$[esp+44]
  00586	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00588	83 f9 09	 cmp	 ecx, 9
  0058b	0f 86 b7 fa ff
	ff		 jbe	 $L1828
$L1923:

; 235  :     default:
; 236  :       r = Z_STREAM_ERROR;
; 237  :       LEAVE

  00591	6a fe		 push	 -2			; fffffffeH
$L2010:
  00593	8b 4c 24 14	 mov	 ecx, DWORD PTR _b$[esp+48]
  00597	8b 44 24 1c	 mov	 eax, DWORD PTR _n$[esp+48]
  0059b	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  0059e	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  005a1	89 47 04	 mov	 DWORD PTR [edi+4], eax
  005a4	8b 07		 mov	 eax, DWORD PTR [edi]
  005a6	8b cd		 mov	 ecx, ebp
  005a8	2b c8		 sub	 ecx, eax
$L2012:
  005aa	01 4f 08	 add	 DWORD PTR [edi+8], ecx
$L2011:
  005ad	89 2f		 mov	 DWORD PTR [edi], ebp
  005af	89 56 34	 mov	 DWORD PTR [esi+52], edx
  005b2	8b ce		 mov	 ecx, esi
  005b4	8b d7		 mov	 edx, edi
  005b6	e8 00 00 00 00	 call	 @inflate_flush@12
  005bb	5f		 pop	 edi
  005bc	5e		 pop	 esi
  005bd	5d		 pop	 ebp
  005be	5b		 pop	 ebx

; 238  :   }
; 239  : #ifdef NEED_DUMMY_RETURN
; 240  :   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
; 241  : #endif
; 242  : }

  005bf	83 c4 1c	 add	 esp, 28			; 0000001cH
  005c2	c2 04 00	 ret	 4
$L1851:

; 154  :       }
; 155  :       c->mode = BADCODE;        /* invalid code */

  005c5	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9

; 156  :       z->msg = (char*)"invalid literal/length code";

  005cb	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 157  :       r = Z_DATA_ERROR;
; 158  :       LEAVE

  005d2	6a fd		 push	 -3			; fffffffdH
  005d4	eb bd		 jmp	 SHORT $L2010
$L1872:

; 186  :       }
; 187  :       c->mode = BADCODE;        /* invalid code */

  005d6	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  005da	c7 00 09 00 00
	00		 mov	 DWORD PTR [eax], 9

; 188  :       z->msg = (char*)"invalid distance code";

  005e0	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 189  :       r = Z_DATA_ERROR;
; 190  :       LEAVE

  005e7	6a fd		 push	 -3			; fffffffdH
  005e9	eb a8		 jmp	 SHORT $L2010
$L1879:

; 193  :       NEEDBITS(j)

  005eb	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+44]
  005ef	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  005f2	89 46 20	 mov	 DWORD PTR [esi+32], eax
  005f5	8b 07		 mov	 eax, DWORD PTR [edi]
  005f7	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  005fa	8b cd		 mov	 ecx, ebp
  005fc	2b c8		 sub	 ecx, eax
  005fe	03 d9		 add	 ebx, ecx
  00600	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00607	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0060a	89 2f		 mov	 DWORD PTR [edi], ebp
  0060c	89 56 34	 mov	 DWORD PTR [esi+52], edx
  0060f	8b 54 24 30	 mov	 edx, DWORD PTR _r$[esp+40]
  00613	52		 push	 edx

; 235  :     default:
; 236  :       r = Z_STREAM_ERROR;
; 237  :       LEAVE

  00614	8b ce		 mov	 ecx, esi
  00616	8b d7		 mov	 edx, edi
  00618	e8 00 00 00 00	 call	 @inflate_flush@12
  0061d	5f		 pop	 edi
  0061e	5e		 pop	 esi
  0061f	5d		 pop	 ebp
  00620	5b		 pop	 ebx

; 238  :   }
; 239  : #ifdef NEED_DUMMY_RETURN
; 240  :   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
; 241  : #endif
; 242  : }

  00621	83 c4 1c	 add	 esp, 28			; 0000001cH
  00624	c2 04 00	 ret	 4
$L1971:

; 212  :     case LIT:           /* o: got literal, waiting for output space */
; 213  :       NEEDOUT

  00627	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+44]
  0062b	8b 4c 24 18	 mov	 ecx, DWORD PTR _n$[esp+44]
  0062f	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00632	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  00635	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00637	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0063a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0063d	8b c5		 mov	 eax, ebp
  0063f	2b c3		 sub	 eax, ebx
  00641	03 c8		 add	 ecx, eax
  00643	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00646	8b 4c 24 30	 mov	 ecx, DWORD PTR _r$[esp+40]
  0064a	51		 push	 ecx
  0064b	e9 5d ff ff ff	 jmp	 $L2011
$L1916:

; 216  :       break;
; 217  :     case WASH:          /* o: got eob, possibly more output */
; 218  :       if (k > 7)        /* return unused byte, if any */

  00650	83 fb 07	 cmp	 ebx, 7
  00653	76 0d		 jbe	 SHORT $L1917

; 219  :       {
; 220  :         Assert(k < 16, "inflate_codes grabbed too many bytes")
; 221  :         k -= 8;
; 222  :         n++;

  00655	8b 4c 24 18	 mov	 ecx, DWORD PTR _n$[esp+44]
  00659	83 eb 08	 sub	 ebx, 8
  0065c	41		 inc	 ecx
  0065d	89 4c 24 18	 mov	 DWORD PTR _n$[esp+44], ecx

; 223  :         p--;            /* can always return one */

  00661	4d		 dec	 ebp
$L1917:

; 224  :       }
; 225  :       FLUSH

  00662	89 56 34	 mov	 DWORD PTR [esi+52], edx
  00665	8b 54 24 30	 mov	 edx, DWORD PTR _r$[esp+40]
  00669	52		 push	 edx
  0066a	8b d7		 mov	 edx, edi
  0066c	8b ce		 mov	 ecx, esi
  0066e	e8 00 00 00 00	 call	 @inflate_flush@12
  00673	8b 56 34	 mov	 edx, DWORD PTR [esi+52]

; 226  :       if (s->read != s->write)

  00676	39 56 30	 cmp	 DWORD PTR [esi+48], edx
  00679	74 1d		 je	 SHORT $L1920

; 227  :         LEAVE

  0067b	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+44]
  0067f	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  00682	8b 4c 24 18	 mov	 ecx, DWORD PTR _n$[esp+44]
  00686	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  00689	8b 1f		 mov	 ebx, DWORD PTR [edi]
  0068b	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0068e	8b cd		 mov	 ecx, ebp
  00690	2b cb		 sub	 ecx, ebx
  00692	50		 push	 eax
  00693	e9 12 ff ff ff	 jmp	 $L2012
$L1920:

; 228  :       c->mode = END;

  00698	8b 44 24 14	 mov	 eax, DWORD PTR _c$[esp+44]
  0069c	c7 00 08 00 00
	00		 mov	 DWORD PTR [eax], 8
$L1921:

; 229  :     case END:
; 230  :       r = Z_STREAM_END;
; 231  :       LEAVE

  006a2	6a 01		 push	 1
  006a4	e9 ea fe ff ff	 jmp	 $L2010
$L1922:

; 232  :     case BADCODE:       /* x: got error */
; 233  :       r = Z_DATA_ERROR;
; 234  :       LEAVE

  006a9	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+44]
  006ad	8b 4c 24 18	 mov	 ecx, DWORD PTR _n$[esp+44]
  006b1	89 46 20	 mov	 DWORD PTR [esi+32], eax
  006b4	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  006b7	8b 1f		 mov	 ebx, DWORD PTR [edi]
  006b9	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  006bc	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  006bf	8b c5		 mov	 eax, ebp
  006c1	2b c3		 sub	 eax, ebx
  006c3	03 c8		 add	 ecx, eax
  006c5	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  006c8	6a fd		 push	 -3			; fffffffdH
  006ca	e9 de fe ff ff	 jmp	 $L2011
  006cf	90		 npad	 1
$L2013:

; 238  :   }
; 239  : #ifdef NEED_DUMMY_RETURN
; 240  :   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
; 241  : #endif
; 242  : }

  006d0	00 00 00 00	 DD	 $L1834
  006d4	00 00 00 00	 DD	 $L1998
  006d8	00 00 00 00	 DD	 $L1854
  006dc	00 00 00 00	 DD	 $L1984
  006e0	00 00 00 00	 DD	 $L1875
  006e4	00 00 00 00	 DD	 $L1989
  006e8	00 00 00 00	 DD	 $L1903
  006ec	00 00 00 00	 DD	 $L1916
  006f0	00 00 00 00	 DD	 $L1921
  006f4	00 00 00 00	 DD	 $L1922
@inflate_codes@12 ENDP
_TEXT	ENDS
PUBLIC	@inflate_codes_free@8
; Function compile flags: /Ogty
;	COMDAT @inflate_codes_free@8
_TEXT	SEGMENT
@inflate_codes_free@8 PROC NEAR				; COMDAT
; _c$ = ecx
; _z$ = edx

; 248  : {

  00000	8b c2		 mov	 eax, edx

; 249  :   ZFREE(z, c);

  00002	8b d1		 mov	 edx, ecx
  00004	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00007	ff 60 24	 jmp	 DWORD PTR [eax+36]
@inflate_codes_free@8 ENDP
_TEXT	ENDS
END
