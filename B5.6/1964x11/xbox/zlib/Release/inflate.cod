; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\inflate.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_05DOIEBMOI@1?41?44?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT @inflateReset@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflateEnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflateInit2_@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflateInit_@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflateSetDictionary@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflateSync@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflateSyncPoint@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?mark@?3??inflateSync@@9@9 DB 00H			; `inflateSync'::`4'::mark
	DB	00H
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	@inflateReset@4
EXTRN	@inflate_blocks_reset@12:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\inflate.c
;	COMDAT @inflateReset@4
_TEXT	SEGMENT
@inflateReset@4 PROC NEAR				; COMDAT
; _z$ = ecx

; 56   :   if (z == Z_NULL || z->state == Z_NULL)

  00000	33 d2		 xor	 edx, edx
  00002	3b ca		 cmp	 ecx, edx
  00004	74 2f		 je	 SHORT $L1679
  00006	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00009	3b c2		 cmp	 eax, edx
  0000b	74 28		 je	 SHORT $L1679
  0000d	56		 push	 esi

; 58   :   z->total_in = z->total_out = 0;

  0000e	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00011	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 59   :   z->msg = Z_NULL;

  00014	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 60   :   z->state->mode = z->state->nowrap ? BLOCKS : METHOD;

  00017	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0001a	f7 de		 neg	 esi
  0001c	1b f6		 sbb	 esi, esi
  0001e	83 e6 07	 and	 esi, 7
  00021	89 30		 mov	 DWORD PTR [eax], esi

; 61   :   inflate_blocks_reset(z->state->blocks, z, Z_NULL);

  00023	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00026	52		 push	 edx
  00027	8b d1		 mov	 edx, ecx
  00029	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002c	e8 00 00 00 00	 call	 @inflate_blocks_reset@12

; 62   :   Tracev((stderr, "inflate: reset\n"));
; 63   :   return Z_OK;

  00031	33 c0		 xor	 eax, eax
  00033	5e		 pop	 esi

; 64   : }

  00034	c3		 ret	 0
$L1679:

; 57   :     return Z_STREAM_ERROR;

  00035	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 64   : }

  0003a	c3		 ret	 0
@inflateReset@4 ENDP
_TEXT	ENDS
PUBLIC	@inflateEnd@4
EXTRN	@inflate_blocks_free@8:NEAR
; Function compile flags: /Ogty
;	COMDAT @inflateEnd@4
_TEXT	SEGMENT
@inflateEnd@4 PROC NEAR					; COMDAT
; _z$ = ecx

; 69   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 70   :   if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)

  00003	85 f6		 test	 esi, esi
  00005	74 30		 je	 SHORT $L1684
  00007	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000a	85 c0		 test	 eax, eax
  0000c	74 29		 je	 SHORT $L1684
  0000e	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00011	85 c9		 test	 ecx, ecx
  00013	74 22		 je	 SHORT $L1684

; 72   :   if (z->state->blocks != Z_NULL)

  00015	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00018	85 c9		 test	 ecx, ecx
  0001a	74 07		 je	 SHORT $L1685

; 73   :     inflate_blocks_free(z->state->blocks, z);

  0001c	8b d6		 mov	 edx, esi
  0001e	e8 00 00 00 00	 call	 @inflate_blocks_free@8
$L1685:

; 74   :   ZFREE(z, z->state);

  00023	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00026	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00029	ff 56 24	 call	 DWORD PTR [esi+36]

; 75   :   z->state = Z_NULL;

  0002c	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 76   :   Tracev((stderr, "inflate: end\n"));
; 77   :   return Z_OK;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 78   : }

  00036	c3		 ret	 0
$L1684:

; 71   :     return Z_STREAM_ERROR;

  00037	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003c	5e		 pop	 esi

; 78   : }

  0003d	c3		 ret	 0
@inflateEnd@4 ENDP
_TEXT	ENDS
PUBLIC	@inflateInit2_@16
EXTRN	@zcalloc@12:NEAR
EXTRN	@zcfree@8:NEAR
EXTRN	@inflate_blocks_new@12:NEAR
EXTRN	@adler32@12:NEAR
; Function compile flags: /Ogty
;	COMDAT @inflateInit2_@16
_TEXT	SEGMENT
_version$ = 8						; size = 4
_stream_size$ = 12					; size = 4
@inflateInit2_@16 PROC NEAR				; COMDAT
; _z$ = ecx
; _w$ = edx

; 87   :   if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 88   :       stream_size != sizeof(z_stream))

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _version$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	33 db		 xor	 ebx, ebx
  00008	3b c3		 cmp	 eax, ebx
  0000a	57		 push	 edi
  0000b	8b fa		 mov	 edi, edx
  0000d	8b f1		 mov	 esi, ecx
  0000f	0f 84 db 00 00
	00		 je	 $L1695
  00015	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00018	0f 85 d2 00 00
	00		 jne	 $L1695
  0001e	83 7c 24 14 38	 cmp	 DWORD PTR _stream_size$[esp+8], 56 ; 00000038H
  00023	0f 85 c7 00 00
	00		 jne	 $L1695

; 90   : 
; 91   :   /* initialize state */
; 92   :   if (z == Z_NULL)

  00029	3b f3		 cmp	 esi, ebx

; 93   :     return Z_STREAM_ERROR;

  0002b	0f 84 b4 00 00
	00		 je	 $L1849

; 94   :   z->msg = Z_NULL;
; 95   :   if (z->zalloc == Z_NULL)

  00031	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  00034	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  00037	75 0a		 jne	 SHORT $L1698

; 96   :   {
; 97   :     z->zalloc = zcalloc;

  00039	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET FLAT:@zcalloc@12

; 98   :     z->opaque = (voidpf)0;

  00040	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
$L1698:

; 99   :   }
; 100  :   if (z->zfree == Z_NULL) z->zfree = zcfree;

  00043	39 5e 24	 cmp	 DWORD PTR [esi+36], ebx
  00046	75 07		 jne	 SHORT $L1700
  00048	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET FLAT:@zcfree@8
$L1700:

; 101  :   if ((z->state = (struct internal_state FAR *)
; 102  :        ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)

  0004f	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00052	6a 18		 push	 24			; 00000018H
  00054	ba 01 00 00 00	 mov	 edx, 1
  00059	ff 56 20	 call	 DWORD PTR [esi+32]
  0005c	3b c3		 cmp	 eax, ebx
  0005e	89 46 1c	 mov	 DWORD PTR [esi+28], eax

; 103  :     return Z_MEM_ERROR;

  00061	74 63		 je	 SHORT $L1848

; 104  :   z->state->blocks = Z_NULL;
; 105  : 
; 106  :   /* handle undocumented nowrap option (no zlib header or check) */
; 107  :   z->state->nowrap = 0;
; 108  :   if (w < 0)

  00063	3b fb		 cmp	 edi, ebx
  00065	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  00068	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0006b	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  0006e	7d 0c		 jge	 SHORT $L1704

; 109  :   {
; 110  :     w = - w;
; 111  :     z->state->nowrap = 1;

  00070	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00073	f7 df		 neg	 edi
  00075	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [ecx+12], 1
$L1704:

; 112  :   }
; 113  : 
; 114  :   /* set window size */
; 115  :   if (w < 8 || w > 15)

  0007c	83 ff 08	 cmp	 edi, 8
  0007f	7c 5d		 jl	 SHORT $L1706
  00081	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00084	7f 58		 jg	 SHORT $L1706

; 119  :   }
; 120  :   z->state->wbits = (uInt)w;

  00086	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00089	89 7a 10	 mov	 DWORD PTR [edx+16], edi

; 121  : 
; 122  :   /* create inflate_blocks state */
; 123  :   if ((z->state->blocks =
; 124  :       inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
; 125  :       == Z_NULL)

  0008c	8b cf		 mov	 ecx, edi
  0008e	b8 01 00 00 00	 mov	 eax, 1
  00093	d3 e0		 shl	 eax, cl
  00095	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00098	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]
  0009b	33 d2		 xor	 edx, edx
  0009d	3b fb		 cmp	 edi, ebx
  0009f	0f 95 c2	 setne	 dl
  000a2	50		 push	 eax
  000a3	8b ce		 mov	 ecx, esi
  000a5	4a		 dec	 edx
  000a6	81 e2 00 00 00
	00		 and	 edx, OFFSET FLAT:@adler32@12
  000ac	e8 00 00 00 00	 call	 @inflate_blocks_new@12
  000b1	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  000b4	89 42 14	 mov	 DWORD PTR [edx+20], eax
  000b7	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000ba	39 58 14	 cmp	 DWORD PTR [eax+20], ebx

; 126  :   {
; 127  :     inflateEnd(z);

  000bd	8b ce		 mov	 ecx, esi
  000bf	75 10		 jne	 SHORT $L1709
  000c1	e8 00 00 00 00	 call	 @inflateEnd@4
$L1848:
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi

; 128  :     return Z_MEM_ERROR;

  000c8	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000cd	5b		 pop	 ebx

; 135  : }

  000ce	c2 08 00	 ret	 8
$L1709:

; 129  :   }
; 130  :   Tracev((stderr, "inflate: allocated\n"));
; 131  : 
; 132  :   /* reset state */
; 133  :   inflateReset(z);

  000d1	e8 00 00 00 00	 call	 @inflateReset@4
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi

; 134  :   return Z_OK;

  000d8	33 c0		 xor	 eax, eax
  000da	5b		 pop	 ebx

; 135  : }

  000db	c2 08 00	 ret	 8
$L1706:

; 116  :   {
; 117  :     inflateEnd(z);

  000de	8b ce		 mov	 ecx, esi
  000e0	e8 00 00 00 00	 call	 @inflateEnd@4
$L1849:
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi

; 118  :     return Z_STREAM_ERROR;

  000e7	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000ec	5b		 pop	 ebx

; 135  : }

  000ed	c2 08 00	 ret	 8
$L1695:
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi

; 89   :       return Z_VERSION_ERROR;

  000f2	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000f7	5b		 pop	 ebx

; 135  : }

  000f8	c2 08 00	 ret	 8
@inflateInit2_@16 ENDP
_TEXT	ENDS
PUBLIC	@inflateInit_@12
; Function compile flags: /Ogty
;	COMDAT @inflateInit_@12
_TEXT	SEGMENT
_stream_size$ = 8					; size = 4
@inflateInit_@12 PROC NEAR				; COMDAT
; _z$ = ecx
; _version$ = edx

; 143  :   return inflateInit2_(z, DEF_WBITS, version, stream_size);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _stream_size$[esp-4]
  00004	50		 push	 eax
  00005	52		 push	 edx
  00006	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  0000b	e8 00 00 00 00	 call	 @inflateInit2_@16

; 144  : }

  00010	c2 04 00	 ret	 4
@inflateInit_@12 ENDP
_TEXT	ENDS
PUBLIC	@inflate@8
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
EXTRN	@inflate_blocks@12:NEAR
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@
CONST	SEGMENT
??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@ DB 'need dictionary', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @inflate@8
_TEXT	SEGMENT
_b$ = -4						; size = 4
@inflate@8 PROC NEAR					; COMDAT
; _z$ = ecx
; _f$ = edx

; 153  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 154  :   int r;
; 155  :   uInt b;
; 156  : 
; 157  :   if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)

  00004	85 f6		 test	 esi, esi
  00006	0f 84 a6 03 00
	00		 je	 $L1724
  0000c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000f	85 c0		 test	 eax, eax
  00011	0f 84 9b 03 00
	00		 je	 $L1724
  00017	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0001a	0f 84 92 03 00
	00		 je	 $L1724

; 159  :   f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
; 160  :   r = Z_BUF_ERROR;
; 161  :   while (1) switch (z->state->mode)

  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	33 c9		 xor	 ecx, ecx
  00024	83 fa 04	 cmp	 edx, 4
  00027	0f 95 c1	 setne	 cl
  0002a	53		 push	 ebx
  0002b	55		 push	 ebp
  0002c	57		 push	 edi
  0002d	bf fb ff ff ff	 mov	 edi, -5			; fffffffbH
  00032	49		 dec	 ecx
  00033	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00036	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00039	8b e9		 mov	 ebp, ecx
  0003b	0f 87 47 03 00
	00		 ja	 $L1783
  00041	bb 05 00 00 00	 mov	 ebx, 5
$L1726:
  00046	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L1874[eax*4]
$L1732:

; 162  :   {
; 163  :     case METHOD:
; 164  :       NEEDBYTE

  0004d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00050	85 c0		 test	 eax, eax
  00052	0f 84 3c 02 00
	00		 je	 $L1855

; 165  :       if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)

  00058	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005b	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0005e	48		 dec	 eax
  0005f	42		 inc	 edx
  00060	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00063	8b 16		 mov	 edx, DWORD PTR [esi]
  00065	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00068	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0006b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0006e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00071	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00074	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00076	80 e2 0f	 and	 dl, 15			; 0000000fH
  00079	41		 inc	 ecx
  0007a	80 fa 08	 cmp	 dl, 8
  0007d	8b fd		 mov	 edi, ebp
  0007f	89 0e		 mov	 DWORD PTR [esi], ecx
  00081	74 18		 je	 SHORT $L1734

; 166  :       {
; 167  :         z->state->mode = BAD;

  00083	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH

; 168  :         z->msg = (char*)"unknown compression method";
; 169  :         z->state->sub.marker = 5;       /* can't try inflateSync */

  00089	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0008c	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  00093	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 170  :         break;

  00096	e9 e0 01 00 00	 jmp	 $L1729
$L1734:

; 171  :       }
; 172  :       if ((z->state->sub.method >> 4) + 8 > z->state->wbits)

  0009b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0009e	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  000a1	c1 e9 04	 shr	 ecx, 4
  000a4	83 c1 08	 add	 ecx, 8
  000a7	3b ca		 cmp	 ecx, edx
  000a9	76 12		 jbe	 SHORT $L1737

; 173  :       {
; 174  :         z->state->mode = BAD;

  000ab	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH

; 175  :         z->msg = (char*)"invalid window size";

  000b1	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 176  :         z->state->sub.marker = 5;       /* can't try inflateSync */
; 177  :         break;

  000b8	e9 b8 01 00 00	 jmp	 $L1873
$L1737:

; 178  :       }
; 179  :       z->state->mode = FLAG;

  000bd	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
$L1863:

; 180  :     case FLAG:
; 181  :       NEEDBYTE

  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	85 c0		 test	 eax, eax
  000c8	0f 84 c6 01 00
	00		 je	 $L1855

; 182  :       b = NEXTBYTE;
; 183  :       if (((z->state->sub.method << 8) + b) % 31)

  000ce	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  000d1	48		 dec	 eax
  000d2	89 46 04	 mov	 DWORD PTR [esi+4], eax
  000d5	ff 46 08	 inc	 DWORD PTR [esi+8]
  000d8	8b 06		 mov	 eax, DWORD PTR [esi]
  000da	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  000dd	40		 inc	 eax
  000de	89 06		 mov	 DWORD PTR [esi], eax
  000e0	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000e3	c1 e0 08	 shl	 eax, 8
  000e6	03 c2		 add	 eax, edx
  000e8	89 54 24 10	 mov	 DWORD PTR _b$[esp+20], edx
  000ec	33 d2		 xor	 edx, edx
  000ee	bb 1f 00 00 00	 mov	 ebx, 31			; 0000001fH
  000f3	f7 f3		 div	 ebx
  000f5	8b fd		 mov	 edi, ebp

; 184  :       {
; 185  :         z->state->mode = BAD;
; 186  :         z->msg = (char*)"incorrect header check";
; 187  :         z->state->sub.marker = 5;       /* can't try inflateSync */

  000f7	bb 05 00 00 00	 mov	 ebx, 5
  000fc	85 d2		 test	 edx, edx
  000fe	74 18		 je	 SHORT $L1742
  00100	c7 01 0d 00 00
	00		 mov	 DWORD PTR [ecx], 13	; 0000000dH
  00106	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00109	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
  00110	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 188  :         break;

  00113	e9 63 01 00 00	 jmp	 $L1729
$L1742:

; 189  :       }
; 190  :       Tracev((stderr, "inflate: zlib header ok\n"));
; 191  :       if (!(b & PRESET_DICT))

  00118	f6 44 24 10 20	 test	 BYTE PTR _b$[esp+20], 32 ; 00000020H
  0011d	0f 85 79 01 00
	00		 jne	 $L1745

; 192  :       {
; 193  :         z->state->mode = BLOCKS;

  00123	c7 01 07 00 00
	00		 mov	 DWORD PTR [ecx], 7

; 194  :         break;

  00129	e9 4d 01 00 00	 jmp	 $L1729
$L1761:

; 220  :     case BLOCKS:
; 221  :       r = inflate_blocks(z->state->blocks, z, r);

  0012e	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00131	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00134	57		 push	 edi
  00135	8b d6		 mov	 edx, esi
  00137	e8 00 00 00 00	 call	 @inflate_blocks@12
  0013c	8b f8		 mov	 edi, eax

; 222  :       if (r == Z_DATA_ERROR)

  0013e	83 ff fd	 cmp	 edi, -3			; fffffffdH
  00141	75 18		 jne	 SHORT $L1762

; 223  :       {
; 224  :         z->state->mode = BAD;

  00143	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00146	c7 02 0d 00 00
	00		 mov	 DWORD PTR [edx], 13	; 0000000dH

; 225  :         z->state->sub.marker = 0;       /* can try inflateSync */

  0014c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0014f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 226  :         break;

  00156	e9 20 01 00 00	 jmp	 $L1729
$L1762:

; 227  :       }
; 228  :       if (r == Z_OK)

  0015b	85 ff		 test	 edi, edi
  0015d	75 02		 jne	 SHORT $L1763

; 229  :         r = f;

  0015f	8b fd		 mov	 edi, ebp
$L1763:

; 230  :       if (r != Z_STREAM_END)

  00161	83 ff 01	 cmp	 edi, 1
  00164	0f 85 2a 01 00
	00		 jne	 $L1855

; 231  :         return r;
; 232  :       r = f;
; 233  :       inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);

  0016a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0016d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00170	51		 push	 ecx
  00171	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00174	8b d6		 mov	 edx, esi
  00176	8b fd		 mov	 edi, ebp
  00178	e8 00 00 00 00	 call	 @inflate_blocks_reset@12

; 234  :       if (z->state->nowrap)

  0017d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00180	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00183	85 c9		 test	 ecx, ecx
  00185	74 0b		 je	 SHORT $L1765

; 235  :       {
; 236  :         z->state->mode = DONE;

  00187	c7 00 0c 00 00
	00		 mov	 DWORD PTR [eax], 12	; 0000000cH

; 237  :         break;

  0018d	e9 e9 00 00 00	 jmp	 $L1729
$L1765:

; 238  :       }
; 239  :       z->state->mode = CHECK4;

  00192	c7 00 08 00 00
	00		 mov	 DWORD PTR [eax], 8
$L1766:

; 240  :     case CHECK4:
; 241  :       NEEDBYTE

  00198	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0019b	85 c0		 test	 eax, eax
  0019d	0f 84 f1 00 00
	00		 je	 $L1855

; 242  :       z->state->sub.check.need = (uLong)NEXTBYTE << 24;

  001a3	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001a6	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  001a9	48		 dec	 eax
  001aa	42		 inc	 edx
  001ab	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001ae	8b 16		 mov	 edx, DWORD PTR [esi]
  001b0	89 46 04	 mov	 DWORD PTR [esi+4], eax
  001b3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001b6	c1 e0 18	 shl	 eax, 24			; 00000018H
  001b9	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  001bc	8b 06		 mov	 eax, DWORD PTR [esi]

; 243  :       z->state->mode = CHECK3;

  001be	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  001c1	40		 inc	 eax
  001c2	89 06		 mov	 DWORD PTR [esi], eax
  001c4	8b fd		 mov	 edi, ebp
  001c6	c7 02 09 00 00
	00		 mov	 DWORD PTR [edx], 9
$L1864:

; 244  :     case CHECK3:
; 245  :       NEEDBYTE

  001cc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001cf	85 c0		 test	 eax, eax
  001d1	0f 84 bd 00 00
	00		 je	 $L1855

; 246  :       z->state->sub.check.need += (uLong)NEXTBYTE << 16;

  001d7	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  001da	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001dc	48		 dec	 eax
  001dd	89 46 04	 mov	 DWORD PTR [esi+4], eax
  001e0	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001e3	42		 inc	 edx
  001e4	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001e7	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001ea	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001ed	c1 e2 10	 shl	 edx, 16			; 00000010H
  001f0	03 ca		 add	 ecx, edx
  001f2	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001f5	ff 06		 inc	 DWORD PTR [esi]

; 247  :       z->state->mode = CHECK2;

  001f7	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001fa	8b fd		 mov	 edi, ebp
  001fc	c7 00 0a 00 00
	00		 mov	 DWORD PTR [eax], 10	; 0000000aH
$L1865:

; 248  :     case CHECK2:
; 249  :       NEEDBYTE

  00202	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00205	85 c0		 test	 eax, eax
  00207	0f 84 87 00 00
	00		 je	 $L1855

; 250  :       z->state->sub.check.need += (uLong)NEXTBYTE << 8;

  0020d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00210	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00212	48		 dec	 eax
  00213	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00216	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00219	42		 inc	 edx
  0021a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0021d	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00220	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00223	c1 e2 08	 shl	 edx, 8
  00226	03 ca		 add	 ecx, edx
  00228	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0022b	ff 06		 inc	 DWORD PTR [esi]

; 251  :       z->state->mode = CHECK1;

  0022d	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00230	8b fd		 mov	 edi, ebp
  00232	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH
$L1866:

; 252  :     case CHECK1:
; 253  :       NEEDBYTE

  00238	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0023b	85 c0		 test	 eax, eax
  0023d	74 55		 je	 SHORT $L1855

; 254  :       z->state->sub.check.need += (uLong)NEXTBYTE;

  0023f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00242	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00244	48		 dec	 eax
  00245	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00248	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0024b	42		 inc	 edx
  0024c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0024f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00252	01 50 08	 add	 DWORD PTR [eax+8], edx
  00255	ff 06		 inc	 DWORD PTR [esi]

; 255  : 
; 256  :       if (z->state->sub.check.was != z->state->sub.check.need)

  00257	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0025a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0025d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00260	8b fd		 mov	 edi, ebp
  00262	0f 84 2b 01 00
	00		 je	 $L1778

; 257  :       {
; 258  :         z->state->mode = BAD;

  00268	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH

; 259  :         z->msg = (char*)"incorrect data check";

  0026e	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
$L1873:

; 260  :         z->state->sub.marker = 5;       /* can't try inflateSync */

  00275	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00278	89 5a 04	 mov	 DWORD PTR [edx+4], ebx
$L1729:
  0027b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0027e	8b 00		 mov	 eax, DWORD PTR [eax]
  00280	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00283	0f 86 bd fd ff
	ff		 jbe	 $L1726
  00289	5f		 pop	 edi
  0028a	5d		 pop	 ebp
  0028b	5b		 pop	 ebx
  0028c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00291	5e		 pop	 esi

; 269  :     default:
; 270  :       return Z_STREAM_ERROR;
; 271  :   }
; 272  : #ifdef NEED_DUMMY_RETURN
; 273  :   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
; 274  : #endif
; 275  : }

  00292	59		 pop	 ecx
  00293	c3		 ret	 0
$L1855:

; 162  :   {
; 163  :     case METHOD:
; 164  :       NEEDBYTE

  00294	8b c7		 mov	 eax, edi
  00296	5f		 pop	 edi
  00297	5d		 pop	 ebp
  00298	5b		 pop	 ebx
  00299	5e		 pop	 esi

; 269  :     default:
; 270  :       return Z_STREAM_ERROR;
; 271  :   }
; 272  : #ifdef NEED_DUMMY_RETURN
; 273  :   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
; 274  : #endif
; 275  : }

  0029a	59		 pop	 ecx
  0029b	c3		 ret	 0
$L1745:

; 195  :       }
; 196  :       z->state->mode = DICT4;

  0029c	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0029f	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
$L1746:

; 197  :     case DICT4:
; 198  :       NEEDBYTE

  002a5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002a8	85 c0		 test	 eax, eax
  002aa	74 e8		 je	 SHORT $L1855

; 199  :       z->state->sub.check.need = (uLong)NEXTBYTE << 24;

  002ac	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  002af	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  002b2	48		 dec	 eax
  002b3	42		 inc	 edx
  002b4	89 56 08	 mov	 DWORD PTR [esi+8], edx
  002b7	8b 16		 mov	 edx, DWORD PTR [esi]
  002b9	89 46 04	 mov	 DWORD PTR [esi+4], eax
  002bc	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002bf	c1 e0 18	 shl	 eax, 24			; 00000018H
  002c2	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  002c5	8b 06		 mov	 eax, DWORD PTR [esi]

; 200  :       z->state->mode = DICT3;

  002c7	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  002ca	40		 inc	 eax
  002cb	89 06		 mov	 DWORD PTR [esi], eax
  002cd	8b fd		 mov	 edi, ebp
  002cf	c7 02 03 00 00
	00		 mov	 DWORD PTR [edx], 3
$L1867:

; 201  :     case DICT3:
; 202  :       NEEDBYTE

  002d5	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002d8	85 c0		 test	 eax, eax
  002da	74 b8		 je	 SHORT $L1855

; 203  :       z->state->sub.check.need += (uLong)NEXTBYTE << 16;

  002dc	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  002df	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002e1	48		 dec	 eax
  002e2	89 46 04	 mov	 DWORD PTR [esi+4], eax
  002e5	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  002e8	42		 inc	 edx
  002e9	89 56 08	 mov	 DWORD PTR [esi+8], edx
  002ec	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  002ef	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002f2	c1 e2 10	 shl	 edx, 16			; 00000010H
  002f5	03 ca		 add	 ecx, edx
  002f7	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  002fa	ff 06		 inc	 DWORD PTR [esi]

; 204  :       z->state->mode = DICT2;

  002fc	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  002ff	8b fd		 mov	 edi, ebp
  00301	c7 00 04 00 00
	00		 mov	 DWORD PTR [eax], 4
$L1868:

; 205  :     case DICT2:
; 206  :       NEEDBYTE

  00307	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0030a	85 c0		 test	 eax, eax
  0030c	74 86		 je	 SHORT $L1855

; 207  :       z->state->sub.check.need += (uLong)NEXTBYTE << 8;

  0030e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00310	48		 dec	 eax
  00311	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00314	ff 46 08	 inc	 DWORD PTR [esi+8]
  00317	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0031a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0031d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00320	c1 e2 08	 shl	 edx, 8
  00323	03 ca		 add	 ecx, edx
  00325	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00328	ff 06		 inc	 DWORD PTR [esi]

; 208  :       z->state->mode = DICT1;

  0032a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0032d	8b fd		 mov	 edi, ebp
  0032f	89 18		 mov	 DWORD PTR [eax], ebx
$L1869:

; 209  :     case DICT1:
; 210  :       NEEDBYTE

  00331	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00334	85 c0		 test	 eax, eax
  00336	0f 84 58 ff ff
	ff		 je	 $L1855

; 211  :       z->state->sub.check.need += (uLong)NEXTBYTE;

  0033c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0033f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00341	48		 dec	 eax
  00342	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00345	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00348	42		 inc	 edx
  00349	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0034c	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0034f	01 50 08	 add	 DWORD PTR [eax+8], edx
  00352	ff 06		 inc	 DWORD PTR [esi]

; 212  :       z->adler = z->state->sub.check.need;

  00354	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00357	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0035a	5f		 pop	 edi
  0035b	5d		 pop	 ebp
  0035c	89 4e 30	 mov	 DWORD PTR [esi+48], ecx
  0035f	5b		 pop	 ebx

; 213  :       z->state->mode = DICT0;

  00360	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6

; 214  :       return Z_NEED_DICT;

  00366	b8 02 00 00 00	 mov	 eax, 2
  0036b	5e		 pop	 esi

; 269  :     default:
; 270  :       return Z_STREAM_ERROR;
; 271  :   }
; 272  : #ifdef NEED_DUMMY_RETURN
; 273  :   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
; 274  : #endif
; 275  : }

  0036c	59		 pop	 ecx
  0036d	c3		 ret	 0
$L1758:

; 215  :     case DICT0:
; 216  :       z->state->mode = BAD;

  0036e	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00371	c7 02 0d 00 00
	00		 mov	 DWORD PTR [edx], 13	; 0000000dH

; 217  :       z->msg = (char*)"need dictionary";
; 218  :       z->state->sub.marker = 0;       /* can try inflateSync */

  00377	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0037a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET FLAT:??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@
  00381	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L1783:
  00388	5f		 pop	 edi
  00389	5d		 pop	 ebp
  0038a	5b		 pop	 ebx

; 219  :       return Z_STREAM_ERROR;

  0038b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00390	5e		 pop	 esi

; 269  :     default:
; 270  :       return Z_STREAM_ERROR;
; 271  :   }
; 272  : #ifdef NEED_DUMMY_RETURN
; 273  :   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
; 274  : #endif
; 275  : }

  00391	59		 pop	 ecx
  00392	c3		 ret	 0
$L1778:

; 261  :         break;
; 262  :       }
; 263  :       Tracev((stderr, "inflate: zlib check ok\n"));
; 264  :       z->state->mode = DONE;

  00393	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00396	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH
$L1781:
  0039c	5f		 pop	 edi
  0039d	5d		 pop	 ebp
  0039e	5b		 pop	 ebx

; 265  :     case DONE:
; 266  :       return Z_STREAM_END;

  0039f	b8 01 00 00 00	 mov	 eax, 1
  003a4	5e		 pop	 esi

; 269  :     default:
; 270  :       return Z_STREAM_ERROR;
; 271  :   }
; 272  : #ifdef NEED_DUMMY_RETURN
; 273  :   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
; 274  : #endif
; 275  : }

  003a5	59		 pop	 ecx
  003a6	c3		 ret	 0
$L1782:
  003a7	5f		 pop	 edi
  003a8	5d		 pop	 ebp
  003a9	5b		 pop	 ebx

; 267  :     case BAD:
; 268  :       return Z_DATA_ERROR;

  003aa	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  003af	5e		 pop	 esi

; 269  :     default:
; 270  :       return Z_STREAM_ERROR;
; 271  :   }
; 272  : #ifdef NEED_DUMMY_RETURN
; 273  :   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
; 274  : #endif
; 275  : }

  003b0	59		 pop	 ecx
  003b1	c3		 ret	 0
$L1724:

; 158  :     return Z_STREAM_ERROR;

  003b2	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  003b7	5e		 pop	 esi

; 269  :     default:
; 270  :       return Z_STREAM_ERROR;
; 271  :   }
; 272  : #ifdef NEED_DUMMY_RETURN
; 273  :   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
; 274  : #endif
; 275  : }

  003b8	59		 pop	 ecx
  003b9	c3		 ret	 0
  003ba	8b ff		 npad	 2
$L1874:
  003bc	00 00 00 00	 DD	 $L1732
  003c0	00 00 00 00	 DD	 $L1863
  003c4	00 00 00 00	 DD	 $L1746
  003c8	00 00 00 00	 DD	 $L1867
  003cc	00 00 00 00	 DD	 $L1868
  003d0	00 00 00 00	 DD	 $L1869
  003d4	00 00 00 00	 DD	 $L1758
  003d8	00 00 00 00	 DD	 $L1761
  003dc	00 00 00 00	 DD	 $L1766
  003e0	00 00 00 00	 DD	 $L1864
  003e4	00 00 00 00	 DD	 $L1865
  003e8	00 00 00 00	 DD	 $L1866
  003ec	00 00 00 00	 DD	 $L1781
  003f0	00 00 00 00	 DD	 $L1782
@inflate@8 ENDP
_TEXT	ENDS
PUBLIC	@inflateSetDictionary@12
EXTRN	@inflate_set_dictionary@12:NEAR
; Function compile flags: /Ogty
;	COMDAT @inflateSetDictionary@12
_TEXT	SEGMENT
_length$ = 8						; size = 4
_dictLength$ = 8					; size = 4
@inflateSetDictionary@12 PROC NEAR			; COMDAT
; _z$ = ecx
; _dictionary$ = edx

; 282  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 283  :   uInt length = dictLength;

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _dictLength$[esp+8]
  00007	8b f1		 mov	 esi, ecx

; 284  : 
; 285  :   if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)

  00009	85 f6		 test	 esi, esi
  0000b	8b da		 mov	 ebx, edx
  0000d	89 7c 24 10	 mov	 DWORD PTR _length$[esp+8], edi
  00011	74 68		 je	 SHORT $L1791
  00013	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00016	85 c0		 test	 eax, eax
  00018	74 61		 je	 SHORT $L1791
  0001a	83 38 06	 cmp	 DWORD PTR [eax], 6
  0001d	75 5c		 jne	 SHORT $L1791

; 287  : 
; 288  :   if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;

  0001f	57		 push	 edi
  00020	b9 01 00 00 00	 mov	 ecx, 1
  00025	e8 00 00 00 00	 call	 @adler32@12
  0002a	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  0002d	74 0b		 je	 SHORT $L1792
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00036	5b		 pop	 ebx

; 299  : }

  00037	c2 04 00	 ret	 4
$L1792:
  0003a	55		 push	 ebp

; 289  :   z->adler = 1L;
; 290  : 
; 291  :   if (length >= ((uInt)1<<z->state->wbits))

  0003b	8b 6e 1c	 mov	 ebp, DWORD PTR [esi+28]
  0003e	c7 46 30 01 00
	00 00		 mov	 DWORD PTR [esi+48], 1
  00045	8b 4d 10	 mov	 ecx, DWORD PTR [ebp+16]
  00048	b8 01 00 00 00	 mov	 eax, 1
  0004d	d3 e0		 shl	 eax, cl
  0004f	3b f8		 cmp	 edi, eax
  00051	72 07		 jb	 SHORT $L1877

; 292  :   {
; 293  :     length = (1<<z->state->wbits)-1;

  00053	48		 dec	 eax

; 294  :     dictionary += dictLength - length;

  00054	2b f8		 sub	 edi, eax
  00056	03 df		 add	 ebx, edi
  00058	eb 04		 jmp	 SHORT $L1794
$L1877:
  0005a	8b 44 24 14	 mov	 eax, DWORD PTR _length$[esp+12]
$L1794:

; 295  :   }
; 296  :   inflate_set_dictionary(z->state->blocks, dictionary, length);

  0005e	8b 4d 14	 mov	 ecx, DWORD PTR [ebp+20]
  00061	50		 push	 eax
  00062	8b d3		 mov	 edx, ebx
  00064	e8 00 00 00 00	 call	 @inflate_set_dictionary@12

; 297  :   z->state->mode = BLOCKS;

  00069	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0006c	5d		 pop	 ebp
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7

; 298  :   return Z_OK;

  00075	33 c0		 xor	 eax, eax
  00077	5b		 pop	 ebx

; 299  : }

  00078	c2 04 00	 ret	 4
$L1791:
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 286  :     return Z_STREAM_ERROR;

  0007d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00082	5b		 pop	 ebx

; 299  : }

  00083	c2 04 00	 ret	 4
@inflateSetDictionary@12 ENDP
_TEXT	ENDS
PUBLIC	@inflateSync@4
; Function compile flags: /Ogty
;	COMDAT @inflateSync@4
_TEXT	SEGMENT
@inflateSync@4 PROC NEAR				; COMDAT
; _z$ = ecx

; 304  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 305  :   uInt n;       /* number of bytes to look at */
; 306  :   Bytef *p;     /* pointer to bytes */
; 307  :   uInt m;       /* number of marker bytes found in a row */
; 308  :   uLong r, w;   /* temporaries to save total_in and total_out */
; 309  : 
; 310  :   /* set up */
; 311  :   if (z == Z_NULL || z->state == Z_NULL)

  00003	85 f6		 test	 esi, esi
  00005	0f 84 a9 00 00
	00		 je	 $L1804
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	0f 84 9e 00 00
	00		 je	 $L1804

; 313  :   if (z->state->mode != BAD)

  00016	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  00019	74 10		 je	 SHORT $L1805

; 314  :   {
; 315  :     z->state->mode = BAD;

  0001b	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH

; 316  :     z->state->sub.marker = 0;

  00021	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00024	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$L1805:
  0002b	55		 push	 ebp

; 317  :   }
; 318  :   if ((n = z->avail_in) == 0)

  0002c	8b 6e 04	 mov	 ebp, DWORD PTR [esi+4]
  0002f	85 ed		 test	 ebp, ebp
  00031	75 08		 jne	 SHORT $L1806
  00033	5d		 pop	 ebp

; 319  :     return Z_BUF_ERROR;

  00034	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00039	5e		 pop	 esi

; 350  : }

  0003a	c3		 ret	 0
$L1806:
  0003b	53		 push	 ebx

; 320  :   p = z->next_in;
; 321  :   m = z->state->sub.marker;

  0003c	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  0003f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00042	57		 push	 edi
  00043	8b 3e		 mov	 edi, DWORD PTR [esi]
  00045	8b cf		 mov	 ecx, edi
$L1808:

; 322  : 
; 323  :   /* search */
; 324  :   while (n && m < 4)

  00047	83 f8 04	 cmp	 eax, 4
  0004a	73 22		 jae	 SHORT $L1809

; 325  :   {
; 326  :     static const Byte mark[4] = {0, 0, 0xff, 0xff};
; 327  :     if (*p == mark[m])

  0004c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0004e	3a 90 00 00 00
	00		 cmp	 dl, BYTE PTR ?mark@?3??inflateSync@@9@9[eax]
  00054	75 03		 jne	 SHORT $L1812

; 328  :       m++;

  00056	40		 inc	 eax

; 329  :     else if (*p)

  00057	eb 11		 jmp	 SHORT $L1815
$L1812:
  00059	84 d2		 test	 dl, dl
  0005b	74 04		 je	 SHORT $L1814

; 330  :       m = 0;

  0005d	33 c0		 xor	 eax, eax

; 331  :     else

  0005f	eb 09		 jmp	 SHORT $L1815
$L1814:

; 332  :       m = 4 - m;

  00061	ba 04 00 00 00	 mov	 edx, 4
  00066	2b d0		 sub	 edx, eax
  00068	8b c2		 mov	 eax, edx
$L1815:

; 333  :     p++, n--;

  0006a	41		 inc	 ecx
  0006b	4d		 dec	 ebp
  0006c	75 d9		 jne	 SHORT $L1808
$L1809:

; 334  :   }
; 335  : 
; 336  :   /* restore */
; 337  :   z->total_in += p - z->next_in;

  0006e	8b d1		 mov	 edx, ecx
  00070	2b d7		 sub	 edx, edi
  00072	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00075	03 fa		 add	 edi, edx

; 338  :   z->next_in = p;
; 339  :   z->avail_in = n;
; 340  :   z->state->sub.marker = m;
; 341  : 
; 342  :   /* return no joy or set up to restart on a new block */
; 343  :   if (m != 4)

  00077	83 f8 04	 cmp	 eax, 4
  0007a	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0007d	89 0e		 mov	 DWORD PTR [esi], ecx
  0007f	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  00082	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00085	74 0a		 je	 SHORT $L1816
  00087	5f		 pop	 edi
  00088	5b		 pop	 ebx
  00089	5d		 pop	 ebp

; 344  :     return Z_DATA_ERROR;

  0008a	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0008f	5e		 pop	 esi

; 350  : }

  00090	c3		 ret	 0
$L1816:

; 345  :   r = z->total_in;  w = z->total_out;

  00091	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00094	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]

; 346  :   inflateReset(z);

  00097	8b ce		 mov	 ecx, esi
  00099	e8 00 00 00 00	 call	 @inflateReset@4

; 347  :   z->total_in = r;  z->total_out = w;
; 348  :   z->state->mode = BLOCKS;

  0009e	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000a1	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  000a4	5f		 pop	 edi
  000a5	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  000a8	5b		 pop	 ebx
  000a9	5d		 pop	 ebp
  000aa	c7 00 07 00 00
	00		 mov	 DWORD PTR [eax], 7

; 349  :   return Z_OK;

  000b0	33 c0		 xor	 eax, eax
  000b2	5e		 pop	 esi

; 350  : }

  000b3	c3		 ret	 0
$L1804:

; 312  :     return Z_STREAM_ERROR;

  000b4	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000b9	5e		 pop	 esi

; 350  : }

  000ba	c3		 ret	 0
@inflateSync@4 ENDP
_TEXT	ENDS
PUBLIC	@inflateSyncPoint@4
EXTRN	@inflate_blocks_sync_point@4:NEAR
; Function compile flags: /Ogty
;	COMDAT @inflateSyncPoint@4
_TEXT	SEGMENT
@inflateSyncPoint@4 PROC NEAR				; COMDAT
; _z$ = ecx

; 363  :   if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)

  00000	85 c9		 test	 ecx, ecx
  00002	74 15		 je	 SHORT $L1821
  00004	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00007	85 c0		 test	 eax, eax
  00009	74 0e		 je	 SHORT $L1821
  0000b	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000e	85 c0		 test	 eax, eax
  00010	74 07		 je	 SHORT $L1821

; 365  :   return inflate_blocks_sync_point(z->state->blocks);

  00012	8b c8		 mov	 ecx, eax
  00014	e9 00 00 00 00	 jmp	 @inflate_blocks_sync_point@4
$L1821:

; 364  :     return Z_STREAM_ERROR;

  00019	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 366  : }

  0001e	c3		 ret	 0
@inflateSyncPoint@4 ENDP
_TEXT	ENDS
END
