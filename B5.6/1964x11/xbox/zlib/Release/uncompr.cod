; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\uncompr.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_05DOIEBMOI@1?41?44?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT @uncompress@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	@uncompress@16
PUBLIC	??_C@_05DOIEBMOI@1?41?44?$AA@			; `string'
EXTRN	@inflate@8:NEAR
EXTRN	@inflateEnd@4:NEAR
EXTRN	@inflateInit_@12:NEAR
;	COMDAT ??_C@_05DOIEBMOI@1?41?44?$AA@
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\uncompr.c
CONST	SEGMENT
??_C@_05DOIEBMOI@1?41?44?$AA@ DB '1.1.4', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @uncompress@16
_TEXT	SEGMENT
_stream$ = -56						; size = 56
_source$ = 8						; size = 4
_sourceLen$ = 12					; size = 4
@uncompress@16 PROC NEAR				; COMDAT
; _dest$ = ecx
; _destLen$ = edx

; 30   : {

  00000	83 ec 38	 sub	 esp, 56			; 00000038H

; 31   :     z_stream stream;
; 32   :     int err;
; 33   : 
; 34   :     stream.next_in = (Bytef*)source;

  00003	8b 44 24 3c	 mov	 eax, DWORD PTR _source$[esp+52]
  00007	56		 push	 esi
  00008	8b f2		 mov	 esi, edx

; 35   :     stream.avail_in = (uInt)sourceLen;

  0000a	8b 54 24 44	 mov	 edx, DWORD PTR _sourceLen$[esp+56]
  0000e	89 44 24 04	 mov	 DWORD PTR _stream$[esp+60], eax

; 36   :     /* Check for source > 64K on 16-bit machine: */
; 37   :     if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
; 38   : 
; 39   :     stream.next_out = dest;
; 40   :     stream.avail_out = (uInt)*destLen;

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	89 54 24 08	 mov	 DWORD PTR _stream$[esp+64], edx
  00018	89 4c 24 10	 mov	 DWORD PTR _stream$[esp+72], ecx

; 41   :     if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
; 42   : 
; 43   :     stream.zalloc = (alloc_func)0;
; 44   :     stream.zfree = (free_func)0;
; 45   : 
; 46   :     err = inflateInit(&stream);

  0001c	6a 38		 push	 56			; 00000038H
  0001e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:??_C@_05DOIEBMOI@1?41?44?$AA@
  00023	8d 4c 24 08	 lea	 ecx, DWORD PTR _stream$[esp+64]
  00027	89 44 24 18	 mov	 DWORD PTR _stream$[esp+80], eax
  0002b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+96], 0
  00033	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _stream$[esp+100], 0
  0003b	e8 00 00 00 00	 call	 @inflateInit_@12

; 47   :     if (err != Z_OK) return err;

  00040	85 c0		 test	 eax, eax
  00042	75 42		 jne	 SHORT $L866
  00044	57		 push	 edi

; 48   : 
; 49   :     err = inflate(&stream, Z_FINISH);

  00045	ba 04 00 00 00	 mov	 edx, 4
  0004a	8d 4c 24 08	 lea	 ecx, DWORD PTR _stream$[esp+64]
  0004e	e8 00 00 00 00	 call	 @inflate@8
  00053	8b f8		 mov	 edi, eax

; 50   :     if (err != Z_STREAM_END) {

  00055	83 ff 01	 cmp	 edi, 1
  00058	74 1c		 je	 SHORT $L881

; 51   :         inflateEnd(&stream);

  0005a	8d 4c 24 08	 lea	 ecx, DWORD PTR _stream$[esp+64]
  0005e	e8 00 00 00 00	 call	 @inflateEnd@4

; 52   :         return err == Z_OK ? Z_BUF_ERROR : err;

  00063	85 ff		 test	 edi, edi
  00065	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0006a	74 19		 je	 SHORT $L894
  0006c	8b c7		 mov	 eax, edi
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi

; 57   :     return err;
; 58   : }

  00070	83 c4 38	 add	 esp, 56			; 00000038H
  00073	c2 08 00	 ret	 8
$L881:

; 53   :     }
; 54   :     *destLen = stream.total_out;

  00076	8b 4c 24 1c	 mov	 ecx, DWORD PTR _stream$[esp+84]
  0007a	89 0e		 mov	 DWORD PTR [esi], ecx

; 55   : 
; 56   :     err = inflateEnd(&stream);

  0007c	8d 4c 24 08	 lea	 ecx, DWORD PTR _stream$[esp+64]
  00080	e8 00 00 00 00	 call	 @inflateEnd@4
$L894:
  00085	5f		 pop	 edi
$L866:
  00086	5e		 pop	 esi

; 57   :     return err;
; 58   : }

  00087	83 c4 38	 add	 esp, 56			; 00000038H
  0008a	c2 08 00	 ret	 8
@uncompress@16 ENDP
_TEXT	ENDS
END
