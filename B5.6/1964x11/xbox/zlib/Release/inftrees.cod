; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\inftrees.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CI@CGMOPDPD@oversubscribed?5dynamic?5bit?5lengt@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@LOHAHEGK@incomplete?5dynamic?5bit?5lengths?5t@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@GJIDGCKE@oversubscribed?5literal?1length?5tr@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@NEEEJJNA@incomplete?5literal?1length?5tree?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@KBLCDIAI@oversubscribed?5distance?5tree?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CBCPDPJF@incomplete?5distance?5tree?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@KPKKKLFO@empty?5distance?5tree?5with?5lengths@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT @huft_build@40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate_trees_bits@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate_trees_dynamic@36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate_trees_fixed@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_inflate_copyright
CONST	SEGMENT
_inflate_copyright DB ' inflate 1.1.4 Copyright 1995-2002 Mark Adler ', 00H
	ORG $+1
_cplens	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
	ORG $+4
_cplext	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	070H
	DD	070H
	ORG $+4
_cpdist	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
_cpdext	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
CONST	ENDS
_DATA	SEGMENT
_fixed_bl DD	09H
_fixed_bd DD	05H
_fixed_tl DB	060H
	DB	07H
	ORG $+2
	DD	0100H
	DB	00H
	DB	08H
	ORG $+2
	DD	050H
	DB	00H
	DB	08H
	ORG $+2
	DD	010H
	DB	054H
	DB	08H
	ORG $+2
	DD	073H
	DB	052H
	DB	07H
	ORG $+2
	DD	01fH
	DB	00H
	DB	08H
	ORG $+2
	DD	070H
	DB	00H
	DB	08H
	ORG $+2
	DD	030H
	DB	00H
	DB	09H
	ORG $+2
	DD	0c0H
	DB	050H
	DB	07H
	ORG $+2
	DD	0aH
	DB	00H
	DB	08H
	ORG $+2
	DD	060H
	DB	00H
	DB	08H
	ORG $+2
	DD	020H
	DB	00H
	DB	09H
	ORG $+2
	DD	0a0H
	DB	00H
	DB	08H
	ORG $+2
	DD	00H
	DB	00H
	DB	08H
	ORG $+2
	DD	080H
	DB	00H
	DB	08H
	ORG $+2
	DD	040H
	DB	00H
	DB	09H
	ORG $+2
	DD	0e0H
	DB	050H
	DB	07H
	ORG $+2
	DD	06H
	DB	00H
	DB	08H
	ORG $+2
	DD	058H
	DB	00H
	DB	08H
	ORG $+2
	DD	018H
	DB	00H
	DB	09H
	ORG $+2
	DD	090H
	DB	053H
	DB	07H
	ORG $+2
	DD	03bH
	DB	00H
	DB	08H
	ORG $+2
	DD	078H
	DB	00H
	DB	08H
	ORG $+2
	DD	038H
	DB	00H
	DB	09H
	ORG $+2
	DD	0d0H
	DB	051H
	DB	07H
	ORG $+2
	DD	011H
	DB	00H
	DB	08H
	ORG $+2
	DD	068H
	DB	00H
	DB	08H
	ORG $+2
	DD	028H
	DB	00H
	DB	09H
	ORG $+2
	DD	0b0H
	DB	00H
	DB	08H
	ORG $+2
	DD	08H
	DB	00H
	DB	08H
	ORG $+2
	DD	088H
	DB	00H
	DB	08H
	ORG $+2
	DD	048H
	DB	00H
	DB	09H
	ORG $+2
	DD	0f0H
	DB	050H
	DB	07H
	ORG $+2
	DD	04H
	DB	00H
	DB	08H
	ORG $+2
	DD	054H
	DB	00H
	DB	08H
	ORG $+2
	DD	014H
	DB	055H
	DB	08H
	ORG $+2
	DD	0e3H
	DB	053H
	DB	07H
	ORG $+2
	DD	02bH
	DB	00H
	DB	08H
	ORG $+2
	DD	074H
	DB	00H
	DB	08H
	ORG $+2
	DD	034H
	DB	00H
	DB	09H
	ORG $+2
	DD	0c8H
	DB	051H
	DB	07H
	ORG $+2
	DD	0dH
	DB	00H
	DB	08H
	ORG $+2
	DD	064H
	DB	00H
	DB	08H
	ORG $+2
	DD	024H
	DB	00H
	DB	09H
	ORG $+2
	DD	0a8H
	DB	00H
	DB	08H
	ORG $+2
	DD	04H
	DB	00H
	DB	08H
	ORG $+2
	DD	084H
	DB	00H
	DB	08H
	ORG $+2
	DD	044H
	DB	00H
	DB	09H
	ORG $+2
	DD	0e8H
	DB	050H
	DB	07H
	ORG $+2
	DD	08H
	DB	00H
	DB	08H
	ORG $+2
	DD	05cH
	DB	00H
	DB	08H
	ORG $+2
	DD	01cH
	DB	00H
	DB	09H
	ORG $+2
	DD	098H
	DB	054H
	DB	07H
	ORG $+2
	DD	053H
	DB	00H
	DB	08H
	ORG $+2
	DD	07cH
	DB	00H
	DB	08H
	ORG $+2
	DD	03cH
	DB	00H
	DB	09H
	ORG $+2
	DD	0d8H
	DB	052H
	DB	07H
	ORG $+2
	DD	017H
	DB	00H
	DB	08H
	ORG $+2
	DD	06cH
	DB	00H
	DB	08H
	ORG $+2
	DD	02cH
	DB	00H
	DB	09H
	ORG $+2
	DD	0b8H
	DB	00H
	DB	08H
	ORG $+2
	DD	0cH
	DB	00H
	DB	08H
	ORG $+2
	DD	08cH
	DB	00H
	DB	08H
	ORG $+2
	DD	04cH
	DB	00H
	DB	09H
	ORG $+2
	DD	0f8H
	DB	050H
	DB	07H
	ORG $+2
	DD	03H
	DB	00H
	DB	08H
	ORG $+2
	DD	052H
	DB	00H
	DB	08H
	ORG $+2
	DD	012H
	DB	055H
	DB	08H
	ORG $+2
	DD	0a3H
	DB	053H
	DB	07H
	ORG $+2
	DD	023H
	DB	00H
	DB	08H
	ORG $+2
	DD	072H
	DB	00H
	DB	08H
	ORG $+2
	DD	032H
	DB	00H
	DB	09H
	ORG $+2
	DD	0c4H
	DB	051H
	DB	07H
	ORG $+2
	DD	0bH
	DB	00H
	DB	08H
	ORG $+2
	DD	062H
	DB	00H
	DB	08H
	ORG $+2
	DD	022H
	DB	00H
	DB	09H
	ORG $+2
	DD	0a4H
	DB	00H
	DB	08H
	ORG $+2
	DD	02H
	DB	00H
	DB	08H
	ORG $+2
	DD	082H
	DB	00H
	DB	08H
	ORG $+2
	DD	042H
	DB	00H
	DB	09H
	ORG $+2
	DD	0e4H
	DB	050H
	DB	07H
	ORG $+2
	DD	07H
	DB	00H
	DB	08H
	ORG $+2
	DD	05aH
	DB	00H
	DB	08H
	ORG $+2
	DD	01aH
	DB	00H
	DB	09H
	ORG $+2
	DD	094H
	DB	054H
	DB	07H
	ORG $+2
	DD	043H
	DB	00H
	DB	08H
	ORG $+2
	DD	07aH
	DB	00H
	DB	08H
	ORG $+2
	DD	03aH
	DB	00H
	DB	09H
	ORG $+2
	DD	0d4H
	DB	052H
	DB	07H
	ORG $+2
	DD	013H
	DB	00H
	DB	08H
	ORG $+2
	DD	06aH
	DB	00H
	DB	08H
	ORG $+2
	DD	02aH
	DB	00H
	DB	09H
	ORG $+2
	DD	0b4H
	DB	00H
	DB	08H
	ORG $+2
	DD	0aH
	DB	00H
	DB	08H
	ORG $+2
	DD	08aH
	DB	00H
	DB	08H
	ORG $+2
	DD	04aH
	DB	00H
	DB	09H
	ORG $+2
	DD	0f4H
	DB	050H
	DB	07H
	ORG $+2
	DD	05H
	DB	00H
	DB	08H
	ORG $+2
	DD	056H
	DB	00H
	DB	08H
	ORG $+2
	DD	016H
	DB	0c0H
	DB	08H
	ORG $+2
	DD	00H
	DB	053H
	DB	07H
	ORG $+2
	DD	033H
	DB	00H
	DB	08H
	ORG $+2
	DD	076H
	DB	00H
	DB	08H
	ORG $+2
	DD	036H
	DB	00H
	DB	09H
	ORG $+2
	DD	0ccH
	DB	051H
	DB	07H
	ORG $+2
	DD	0fH
	DB	00H
	DB	08H
	ORG $+2
	DD	066H
	DB	00H
	DB	08H
	ORG $+2
	DD	026H
	DB	00H
	DB	09H
	ORG $+2
	DD	0acH
	DB	00H
	DB	08H
	ORG $+2
	DD	06H
	DB	00H
	DB	08H
	ORG $+2
	DD	086H
	DB	00H
	DB	08H
	ORG $+2
	DD	046H
	DB	00H
	DB	09H
	ORG $+2
	DD	0ecH
	DB	050H
	DB	07H
	ORG $+2
	DD	09H
	DB	00H
	DB	08H
	ORG $+2
	DD	05eH
	DB	00H
	DB	08H
	ORG $+2
	DD	01eH
	DB	00H
	DB	09H
	ORG $+2
	DD	09cH
	DB	054H
	DB	07H
	ORG $+2
	DD	063H
	DB	00H
	DB	08H
	ORG $+2
	DD	07eH
	DB	00H
	DB	08H
	ORG $+2
	DD	03eH
	DB	00H
	DB	09H
	ORG $+2
	DD	0dcH
	DB	052H
	DB	07H
	ORG $+2
	DD	01bH
	DB	00H
	DB	08H
	ORG $+2
	DD	06eH
	DB	00H
	DB	08H
	ORG $+2
	DD	02eH
	DB	00H
	DB	09H
	ORG $+2
	DD	0bcH
	DB	00H
	DB	08H
	ORG $+2
	DD	0eH
	DB	00H
	DB	08H
	ORG $+2
	DD	08eH
	DB	00H
	DB	08H
	ORG $+2
	DD	04eH
	DB	00H
	DB	09H
	ORG $+2
	DD	0fcH
	DB	060H
	DB	07H
	ORG $+2
	DD	0100H
	DB	00H
	DB	08H
	ORG $+2
	DD	051H
	DB	00H
	DB	08H
	ORG $+2
	DD	011H
	DB	055H
	DB	08H
	ORG $+2
	DD	083H
	DB	052H
	DB	07H
	ORG $+2
	DD	01fH
	DB	00H
	DB	08H
	ORG $+2
	DD	071H
	DB	00H
	DB	08H
	ORG $+2
	DD	031H
	DB	00H
	DB	09H
	ORG $+2
	DD	0c2H
	DB	050H
	DB	07H
	ORG $+2
	DD	0aH
	DB	00H
	DB	08H
	ORG $+2
	DD	061H
	DB	00H
	DB	08H
	ORG $+2
	DD	021H
	DB	00H
	DB	09H
	ORG $+2
	DD	0a2H
	DB	00H
	DB	08H
	ORG $+2
	DD	01H
	DB	00H
	DB	08H
	ORG $+2
	DD	081H
	DB	00H
	DB	08H
	ORG $+2
	DD	041H
	DB	00H
	DB	09H
	ORG $+2
	DD	0e2H
	DB	050H
	DB	07H
	ORG $+2
	DD	06H
	DB	00H
	DB	08H
	ORG $+2
	DD	059H
	DB	00H
	DB	08H
	ORG $+2
	DD	019H
	DB	00H
	DB	09H
	ORG $+2
	DD	092H
	DB	053H
	DB	07H
	ORG $+2
	DD	03bH
	DB	00H
	DB	08H
	ORG $+2
	DD	079H
	DB	00H
	DB	08H
	ORG $+2
	DD	039H
	DB	00H
	DB	09H
	ORG $+2
	DD	0d2H
	DB	051H
	DB	07H
	ORG $+2
	DD	011H
	DB	00H
	DB	08H
	ORG $+2
	DD	069H
	DB	00H
	DB	08H
	ORG $+2
	DD	029H
	DB	00H
	DB	09H
	ORG $+2
	DD	0b2H
	DB	00H
	DB	08H
	ORG $+2
	DD	09H
	DB	00H
	DB	08H
	ORG $+2
	DD	089H
	DB	00H
	DB	08H
	ORG $+2
	DD	049H
	DB	00H
	DB	09H
	ORG $+2
	DD	0f2H
	DB	050H
	DB	07H
	ORG $+2
	DD	04H
	DB	00H
	DB	08H
	ORG $+2
	DD	055H
	DB	00H
	DB	08H
	ORG $+2
	DD	015H
	DB	050H
	DB	08H
	ORG $+2
	DD	0102H
	DB	053H
	DB	07H
	ORG $+2
	DD	02bH
	DB	00H
	DB	08H
	ORG $+2
	DD	075H
	DB	00H
	DB	08H
	ORG $+2
	DD	035H
	DB	00H
	DB	09H
	ORG $+2
	DD	0caH
	DB	051H
	DB	07H
	ORG $+2
	DD	0dH
	DB	00H
	DB	08H
	ORG $+2
	DD	065H
	DB	00H
	DB	08H
	ORG $+2
	DD	025H
	DB	00H
	DB	09H
	ORG $+2
	DD	0aaH
	DB	00H
	DB	08H
	ORG $+2
	DD	05H
	DB	00H
	DB	08H
	ORG $+2
	DD	085H
	DB	00H
	DB	08H
	ORG $+2
	DD	045H
	DB	00H
	DB	09H
	ORG $+2
	DD	0eaH
	DB	050H
	DB	07H
	ORG $+2
	DD	08H
	DB	00H
	DB	08H
	ORG $+2
	DD	05dH
	DB	00H
	DB	08H
	ORG $+2
	DD	01dH
	DB	00H
	DB	09H
	ORG $+2
	DD	09aH
	DB	054H
	DB	07H
	ORG $+2
	DD	053H
	DB	00H
	DB	08H
	ORG $+2
	DD	07dH
	DB	00H
	DB	08H
	ORG $+2
	DD	03dH
	DB	00H
	DB	09H
	ORG $+2
	DD	0daH
	DB	052H
	DB	07H
	ORG $+2
	DD	017H
	DB	00H
	DB	08H
	ORG $+2
	DD	06dH
	DB	00H
	DB	08H
	ORG $+2
	DD	02dH
	DB	00H
	DB	09H
	ORG $+2
	DD	0baH
	DB	00H
	DB	08H
	ORG $+2
	DD	0dH
	DB	00H
	DB	08H
	ORG $+2
	DD	08dH
	DB	00H
	DB	08H
	ORG $+2
	DD	04dH
	DB	00H
	DB	09H
	ORG $+2
	DD	0faH
	DB	050H
	DB	07H
	ORG $+2
	DD	03H
	DB	00H
	DB	08H
	ORG $+2
	DD	053H
	DB	00H
	DB	08H
	ORG $+2
	DD	013H
	DB	055H
	DB	08H
	ORG $+2
	DD	0c3H
	DB	053H
	DB	07H
	ORG $+2
	DD	023H
	DB	00H
	DB	08H
	ORG $+2
	DD	073H
	DB	00H
	DB	08H
	ORG $+2
	DD	033H
	DB	00H
	DB	09H
	ORG $+2
	DD	0c6H
	DB	051H
	DB	07H
	ORG $+2
	DD	0bH
	DB	00H
	DB	08H
	ORG $+2
	DD	063H
	DB	00H
	DB	08H
	ORG $+2
	DD	023H
	DB	00H
	DB	09H
	ORG $+2
	DD	0a6H
	DB	00H
	DB	08H
	ORG $+2
	DD	03H
	DB	00H
	DB	08H
	ORG $+2
	DD	083H
	DB	00H
	DB	08H
	ORG $+2
	DD	043H
	DB	00H
	DB	09H
	ORG $+2
	DD	0e6H
	DB	050H
	DB	07H
	ORG $+2
	DD	07H
	DB	00H
	DB	08H
	ORG $+2
	DD	05bH
	DB	00H
	DB	08H
	ORG $+2
	DD	01bH
	DB	00H
	DB	09H
	ORG $+2
	DD	096H
	DB	054H
	DB	07H
	ORG $+2
	DD	043H
	DB	00H
	DB	08H
	ORG $+2
	DD	07bH
	DB	00H
	DB	08H
	ORG $+2
	DD	03bH
	DB	00H
	DB	09H
	ORG $+2
	DD	0d6H
	DB	052H
	DB	07H
	ORG $+2
	DD	013H
	DB	00H
	DB	08H
	ORG $+2
	DD	06bH
	DB	00H
	DB	08H
	ORG $+2
	DD	02bH
	DB	00H
	DB	09H
	ORG $+2
	DD	0b6H
	DB	00H
	DB	08H
	ORG $+2
	DD	0bH
	DB	00H
	DB	08H
	ORG $+2
	DD	08bH
	DB	00H
	DB	08H
	ORG $+2
	DD	04bH
	DB	00H
	DB	09H
	ORG $+2
	DD	0f6H
	DB	050H
	DB	07H
	ORG $+2
	DD	05H
	DB	00H
	DB	08H
	ORG $+2
	DD	057H
	DB	00H
	DB	08H
	ORG $+2
	DD	017H
	DB	0c0H
	DB	08H
	ORG $+2
	DD	00H
	DB	053H
	DB	07H
	ORG $+2
	DD	033H
	DB	00H
	DB	08H
	ORG $+2
	DD	077H
	DB	00H
	DB	08H
	ORG $+2
	DD	037H
	DB	00H
	DB	09H
	ORG $+2
	DD	0ceH
	DB	051H
	DB	07H
	ORG $+2
	DD	0fH
	DB	00H
	DB	08H
	ORG $+2
	DD	067H
	DB	00H
	DB	08H
	ORG $+2
	DD	027H
	DB	00H
	DB	09H
	ORG $+2
	DD	0aeH
	DB	00H
	DB	08H
	ORG $+2
	DD	07H
	DB	00H
	DB	08H
	ORG $+2
	DD	087H
	DB	00H
	DB	08H
	ORG $+2
	DD	047H
	DB	00H
	DB	09H
	ORG $+2
	DD	0eeH
	DB	050H
	DB	07H
	ORG $+2
	DD	09H
	DB	00H
	DB	08H
	ORG $+2
	DD	05fH
	DB	00H
	DB	08H
	ORG $+2
	DD	01fH
	DB	00H
	DB	09H
	ORG $+2
	DD	09eH
	DB	054H
	DB	07H
	ORG $+2
	DD	063H
	DB	00H
	DB	08H
	ORG $+2
	DD	07fH
	DB	00H
	DB	08H
	ORG $+2
	DD	03fH
	DB	00H
	DB	09H
	ORG $+2
	DD	0deH
	DB	052H
	DB	07H
	ORG $+2
	DD	01bH
	DB	00H
	DB	08H
	ORG $+2
	DD	06fH
	DB	00H
	DB	08H
	ORG $+2
	DD	02fH
	DB	00H
	DB	09H
	ORG $+2
	DD	0beH
	DB	00H
	DB	08H
	ORG $+2
	DD	0fH
	DB	00H
	DB	08H
	ORG $+2
	DD	08fH
	DB	00H
	DB	08H
	ORG $+2
	DD	04fH
	DB	00H
	DB	09H
	ORG $+2
	DD	0feH
	DB	060H
	DB	07H
	ORG $+2
	DD	0100H
	DB	00H
	DB	08H
	ORG $+2
	DD	050H
	DB	00H
	DB	08H
	ORG $+2
	DD	010H
	DB	054H
	DB	08H
	ORG $+2
	DD	073H
	DB	052H
	DB	07H
	ORG $+2
	DD	01fH
	DB	00H
	DB	08H
	ORG $+2
	DD	070H
	DB	00H
	DB	08H
	ORG $+2
	DD	030H
	DB	00H
	DB	09H
	ORG $+2
	DD	0c1H
	DB	050H
	DB	07H
	ORG $+2
	DD	0aH
	DB	00H
	DB	08H
	ORG $+2
	DD	060H
	DB	00H
	DB	08H
	ORG $+2
	DD	020H
	DB	00H
	DB	09H
	ORG $+2
	DD	0a1H
	DB	00H
	DB	08H
	ORG $+2
	DD	00H
	DB	00H
	DB	08H
	ORG $+2
	DD	080H
	DB	00H
	DB	08H
	ORG $+2
	DD	040H
	DB	00H
	DB	09H
	ORG $+2
	DD	0e1H
	DB	050H
	DB	07H
	ORG $+2
	DD	06H
	DB	00H
	DB	08H
	ORG $+2
	DD	058H
	DB	00H
	DB	08H
	ORG $+2
	DD	018H
	DB	00H
	DB	09H
	ORG $+2
	DD	091H
	DB	053H
	DB	07H
	ORG $+2
	DD	03bH
	DB	00H
	DB	08H
	ORG $+2
	DD	078H
	DB	00H
	DB	08H
	ORG $+2
	DD	038H
	DB	00H
	DB	09H
	ORG $+2
	DD	0d1H
	DB	051H
	DB	07H
	ORG $+2
	DD	011H
	DB	00H
	DB	08H
	ORG $+2
	DD	068H
	DB	00H
	DB	08H
	ORG $+2
	DD	028H
	DB	00H
	DB	09H
	ORG $+2
	DD	0b1H
	DB	00H
	DB	08H
	ORG $+2
	DD	08H
	DB	00H
	DB	08H
	ORG $+2
	DD	088H
	DB	00H
	DB	08H
	ORG $+2
	DD	048H
	DB	00H
	DB	09H
	ORG $+2
	DD	0f1H
	DB	050H
	DB	07H
	ORG $+2
	DD	04H
	DB	00H
	DB	08H
	ORG $+2
	DD	054H
	DB	00H
	DB	08H
	ORG $+2
	DD	014H
	DB	055H
	DB	08H
	ORG $+2
	DD	0e3H
	DB	053H
	DB	07H
	ORG $+2
	DD	02bH
	DB	00H
	DB	08H
	ORG $+2
	DD	074H
	DB	00H
	DB	08H
	ORG $+2
	DD	034H
	DB	00H
	DB	09H
	ORG $+2
	DD	0c9H
	DB	051H
	DB	07H
	ORG $+2
	DD	0dH
	DB	00H
	DB	08H
	ORG $+2
	DD	064H
	DB	00H
	DB	08H
	ORG $+2
	DD	024H
	DB	00H
	DB	09H
	ORG $+2
	DD	0a9H
	DB	00H
	DB	08H
	ORG $+2
	DD	04H
	DB	00H
	DB	08H
	ORG $+2
	DD	084H
	DB	00H
	DB	08H
	ORG $+2
	DD	044H
	DB	00H
	DB	09H
	ORG $+2
	DD	0e9H
	DB	050H
	DB	07H
	ORG $+2
	DD	08H
	DB	00H
	DB	08H
	ORG $+2
	DD	05cH
	DB	00H
	DB	08H
	ORG $+2
	DD	01cH
	DB	00H
	DB	09H
	ORG $+2
	DD	099H
	DB	054H
	DB	07H
	ORG $+2
	DD	053H
	DB	00H
	DB	08H
	ORG $+2
	DD	07cH
	DB	00H
	DB	08H
	ORG $+2
	DD	03cH
	DB	00H
	DB	09H
	ORG $+2
	DD	0d9H
	DB	052H
	DB	07H
	ORG $+2
	DD	017H
	DB	00H
	DB	08H
	ORG $+2
	DD	06cH
	DB	00H
	DB	08H
	ORG $+2
	DD	02cH
	DB	00H
	DB	09H
	ORG $+2
	DD	0b9H
	DB	00H
	DB	08H
	ORG $+2
	DD	0cH
	DB	00H
	DB	08H
	ORG $+2
	DD	08cH
	DB	00H
	DB	08H
	ORG $+2
	DD	04cH
	DB	00H
	DB	09H
	ORG $+2
	DD	0f9H
	DB	050H
	DB	07H
	ORG $+2
	DD	03H
	DB	00H
	DB	08H
	ORG $+2
	DD	052H
	DB	00H
	DB	08H
	ORG $+2
	DD	012H
	DB	055H
	DB	08H
	ORG $+2
	DD	0a3H
	DB	053H
	DB	07H
	ORG $+2
	DD	023H
	DB	00H
	DB	08H
	ORG $+2
	DD	072H
	DB	00H
	DB	08H
	ORG $+2
	DD	032H
	DB	00H
	DB	09H
	ORG $+2
	DD	0c5H
	DB	051H
	DB	07H
	ORG $+2
	DD	0bH
	DB	00H
	DB	08H
	ORG $+2
	DD	062H
	DB	00H
	DB	08H
	ORG $+2
	DD	022H
	DB	00H
	DB	09H
	ORG $+2
	DD	0a5H
	DB	00H
	DB	08H
	ORG $+2
	DD	02H
	DB	00H
	DB	08H
	ORG $+2
	DD	082H
	DB	00H
	DB	08H
	ORG $+2
	DD	042H
	DB	00H
	DB	09H
	ORG $+2
	DD	0e5H
	DB	050H
	DB	07H
	ORG $+2
	DD	07H
	DB	00H
	DB	08H
	ORG $+2
	DD	05aH
	DB	00H
	DB	08H
	ORG $+2
	DD	01aH
	DB	00H
	DB	09H
	ORG $+2
	DD	095H
	DB	054H
	DB	07H
	ORG $+2
	DD	043H
	DB	00H
	DB	08H
	ORG $+2
	DD	07aH
	DB	00H
	DB	08H
	ORG $+2
	DD	03aH
	DB	00H
	DB	09H
	ORG $+2
	DD	0d5H
	DB	052H
	DB	07H
	ORG $+2
	DD	013H
	DB	00H
	DB	08H
	ORG $+2
	DD	06aH
	DB	00H
	DB	08H
	ORG $+2
	DD	02aH
	DB	00H
	DB	09H
	ORG $+2
	DD	0b5H
	DB	00H
	DB	08H
	ORG $+2
	DD	0aH
	DB	00H
	DB	08H
	ORG $+2
	DD	08aH
	DB	00H
	DB	08H
	ORG $+2
	DD	04aH
	DB	00H
	DB	09H
	ORG $+2
	DD	0f5H
	DB	050H
	DB	07H
	ORG $+2
	DD	05H
	DB	00H
	DB	08H
	ORG $+2
	DD	056H
	DB	00H
	DB	08H
	ORG $+2
	DD	016H
	DB	0c0H
	DB	08H
	ORG $+2
	DD	00H
	DB	053H
	DB	07H
	ORG $+2
	DD	033H
	DB	00H
	DB	08H
	ORG $+2
	DD	076H
	DB	00H
	DB	08H
	ORG $+2
	DD	036H
	DB	00H
	DB	09H
	ORG $+2
	DD	0cdH
	DB	051H
	DB	07H
	ORG $+2
	DD	0fH
	DB	00H
	DB	08H
	ORG $+2
	DD	066H
	DB	00H
	DB	08H
	ORG $+2
	DD	026H
	DB	00H
	DB	09H
	ORG $+2
	DD	0adH
	DB	00H
	DB	08H
	ORG $+2
	DD	06H
	DB	00H
	DB	08H
	ORG $+2
	DD	086H
	DB	00H
	DB	08H
	ORG $+2
	DD	046H
	DB	00H
	DB	09H
	ORG $+2
	DD	0edH
	DB	050H
	DB	07H
	ORG $+2
	DD	09H
	DB	00H
	DB	08H
	ORG $+2
	DD	05eH
	DB	00H
	DB	08H
	ORG $+2
	DD	01eH
	DB	00H
	DB	09H
	ORG $+2
	DD	09dH
	DB	054H
	DB	07H
	ORG $+2
	DD	063H
	DB	00H
	DB	08H
	ORG $+2
	DD	07eH
	DB	00H
	DB	08H
	ORG $+2
	DD	03eH
	DB	00H
	DB	09H
	ORG $+2
	DD	0ddH
	DB	052H
	DB	07H
	ORG $+2
	DD	01bH
	DB	00H
	DB	08H
	ORG $+2
	DD	06eH
	DB	00H
	DB	08H
	ORG $+2
	DD	02eH
	DB	00H
	DB	09H
	ORG $+2
	DD	0bdH
	DB	00H
	DB	08H
	ORG $+2
	DD	0eH
	DB	00H
	DB	08H
	ORG $+2
	DD	08eH
	DB	00H
	DB	08H
	ORG $+2
	DD	04eH
	DB	00H
	DB	09H
	ORG $+2
	DD	0fdH
	DB	060H
	DB	07H
	ORG $+2
	DD	0100H
	DB	00H
	DB	08H
	ORG $+2
	DD	051H
	DB	00H
	DB	08H
	ORG $+2
	DD	011H
	DB	055H
	DB	08H
	ORG $+2
	DD	083H
	DB	052H
	DB	07H
	ORG $+2
	DD	01fH
	DB	00H
	DB	08H
	ORG $+2
	DD	071H
	DB	00H
	DB	08H
	ORG $+2
	DD	031H
	DB	00H
	DB	09H
	ORG $+2
	DD	0c3H
	DB	050H
	DB	07H
	ORG $+2
	DD	0aH
	DB	00H
	DB	08H
	ORG $+2
	DD	061H
	DB	00H
	DB	08H
	ORG $+2
	DD	021H
	DB	00H
	DB	09H
	ORG $+2
	DD	0a3H
	DB	00H
	DB	08H
	ORG $+2
	DD	01H
	DB	00H
	DB	08H
	ORG $+2
	DD	081H
	DB	00H
	DB	08H
	ORG $+2
	DD	041H
	DB	00H
	DB	09H
	ORG $+2
	DD	0e3H
	DB	050H
	DB	07H
	ORG $+2
	DD	06H
	DB	00H
	DB	08H
	ORG $+2
	DD	059H
	DB	00H
	DB	08H
	ORG $+2
	DD	019H
	DB	00H
	DB	09H
	ORG $+2
	DD	093H
	DB	053H
	DB	07H
	ORG $+2
	DD	03bH
	DB	00H
	DB	08H
	ORG $+2
	DD	079H
	DB	00H
	DB	08H
	ORG $+2
	DD	039H
	DB	00H
	DB	09H
	ORG $+2
	DD	0d3H
	DB	051H
	DB	07H
	ORG $+2
	DD	011H
	DB	00H
	DB	08H
	ORG $+2
	DD	069H
	DB	00H
	DB	08H
	ORG $+2
	DD	029H
	DB	00H
	DB	09H
	ORG $+2
	DD	0b3H
	DB	00H
	DB	08H
	ORG $+2
	DD	09H
	DB	00H
	DB	08H
	ORG $+2
	DD	089H
	DB	00H
	DB	08H
	ORG $+2
	DD	049H
	DB	00H
	DB	09H
	ORG $+2
	DD	0f3H
	DB	050H
	DB	07H
	ORG $+2
	DD	04H
	DB	00H
	DB	08H
	ORG $+2
	DD	055H
	DB	00H
	DB	08H
	ORG $+2
	DD	015H
	DB	050H
	DB	08H
	ORG $+2
	DD	0102H
	DB	053H
	DB	07H
	ORG $+2
	DD	02bH
	DB	00H
	DB	08H
	ORG $+2
	DD	075H
	DB	00H
	DB	08H
	ORG $+2
	DD	035H
	DB	00H
	DB	09H
	ORG $+2
	DD	0cbH
	DB	051H
	DB	07H
	ORG $+2
	DD	0dH
	DB	00H
	DB	08H
	ORG $+2
	DD	065H
	DB	00H
	DB	08H
	ORG $+2
	DD	025H
	DB	00H
	DB	09H
	ORG $+2
	DD	0abH
	DB	00H
	DB	08H
	ORG $+2
	DD	05H
	DB	00H
	DB	08H
	ORG $+2
	DD	085H
	DB	00H
	DB	08H
	ORG $+2
	DD	045H
	DB	00H
	DB	09H
	ORG $+2
	DD	0ebH
	DB	050H
	DB	07H
	ORG $+2
	DD	08H
	DB	00H
	DB	08H
	ORG $+2
	DD	05dH
	DB	00H
	DB	08H
	ORG $+2
	DD	01dH
	DB	00H
	DB	09H
	ORG $+2
	DD	09bH
	DB	054H
	DB	07H
	ORG $+2
	DD	053H
	DB	00H
	DB	08H
	ORG $+2
	DD	07dH
	DB	00H
	DB	08H
	ORG $+2
	DD	03dH
	DB	00H
	DB	09H
	ORG $+2
	DD	0dbH
	DB	052H
	DB	07H
	ORG $+2
	DD	017H
	DB	00H
	DB	08H
	ORG $+2
	DD	06dH
	DB	00H
	DB	08H
	ORG $+2
	DD	02dH
	DB	00H
	DB	09H
	ORG $+2
	DD	0bbH
	DB	00H
	DB	08H
	ORG $+2
	DD	0dH
	DB	00H
	DB	08H
	ORG $+2
	DD	08dH
	DB	00H
	DB	08H
	ORG $+2
	DD	04dH
	DB	00H
	DB	09H
	ORG $+2
	DD	0fbH
	DB	050H
	DB	07H
	ORG $+2
	DD	03H
	DB	00H
	DB	08H
	ORG $+2
	DD	053H
	DB	00H
	DB	08H
	ORG $+2
	DD	013H
	DB	055H
	DB	08H
	ORG $+2
	DD	0c3H
	DB	053H
	DB	07H
	ORG $+2
	DD	023H
	DB	00H
	DB	08H
	ORG $+2
	DD	073H
	DB	00H
	DB	08H
	ORG $+2
	DD	033H
	DB	00H
	DB	09H
	ORG $+2
	DD	0c7H
	DB	051H
	DB	07H
	ORG $+2
	DD	0bH
	DB	00H
	DB	08H
	ORG $+2
	DD	063H
	DB	00H
	DB	08H
	ORG $+2
	DD	023H
	DB	00H
	DB	09H
	ORG $+2
	DD	0a7H
	DB	00H
	DB	08H
	ORG $+2
	DD	03H
	DB	00H
	DB	08H
	ORG $+2
	DD	083H
	DB	00H
	DB	08H
	ORG $+2
	DD	043H
	DB	00H
	DB	09H
	ORG $+2
	DD	0e7H
	DB	050H
	DB	07H
	ORG $+2
	DD	07H
	DB	00H
	DB	08H
	ORG $+2
	DD	05bH
	DB	00H
	DB	08H
	ORG $+2
	DD	01bH
	DB	00H
	DB	09H
	ORG $+2
	DD	097H
	DB	054H
	DB	07H
	ORG $+2
	DD	043H
	DB	00H
	DB	08H
	ORG $+2
	DD	07bH
	DB	00H
	DB	08H
	ORG $+2
	DD	03bH
	DB	00H
	DB	09H
	ORG $+2
	DD	0d7H
	DB	052H
	DB	07H
	ORG $+2
	DD	013H
	DB	00H
	DB	08H
	ORG $+2
	DD	06bH
	DB	00H
	DB	08H
	ORG $+2
	DD	02bH
	DB	00H
	DB	09H
	ORG $+2
	DD	0b7H
	DB	00H
	DB	08H
	ORG $+2
	DD	0bH
	DB	00H
	DB	08H
	ORG $+2
	DD	08bH
	DB	00H
	DB	08H
	ORG $+2
	DD	04bH
	DB	00H
	DB	09H
	ORG $+2
	DD	0f7H
	DB	050H
	DB	07H
	ORG $+2
	DD	05H
	DB	00H
	DB	08H
	ORG $+2
	DD	057H
	DB	00H
	DB	08H
	ORG $+2
	DD	017H
	DB	0c0H
	DB	08H
	ORG $+2
	DD	00H
	DB	053H
	DB	07H
	ORG $+2
	DD	033H
	DB	00H
	DB	08H
	ORG $+2
	DD	077H
	DB	00H
	DB	08H
	ORG $+2
	DD	037H
	DB	00H
	DB	09H
	ORG $+2
	DD	0cfH
	DB	051H
	DB	07H
	ORG $+2
	DD	0fH
	DB	00H
	DB	08H
	ORG $+2
	DD	067H
	DB	00H
	DB	08H
	ORG $+2
	DD	027H
	DB	00H
	DB	09H
	ORG $+2
	DD	0afH
	DB	00H
	DB	08H
	ORG $+2
	DD	07H
	DB	00H
	DB	08H
	ORG $+2
	DD	087H
	DB	00H
	DB	08H
	ORG $+2
	DD	047H
	DB	00H
	DB	09H
	ORG $+2
	DD	0efH
	DB	050H
	DB	07H
	ORG $+2
	DD	09H
	DB	00H
	DB	08H
	ORG $+2
	DD	05fH
	DB	00H
	DB	08H
	ORG $+2
	DD	01fH
	DB	00H
	DB	09H
	ORG $+2
	DD	09fH
	DB	054H
	DB	07H
	ORG $+2
	DD	063H
	DB	00H
	DB	08H
	ORG $+2
	DD	07fH
	DB	00H
	DB	08H
	ORG $+2
	DD	03fH
	DB	00H
	DB	09H
	ORG $+2
	DD	0dfH
	DB	052H
	DB	07H
	ORG $+2
	DD	01bH
	DB	00H
	DB	08H
	ORG $+2
	DD	06fH
	DB	00H
	DB	08H
	ORG $+2
	DD	02fH
	DB	00H
	DB	09H
	ORG $+2
	DD	0bfH
	DB	00H
	DB	08H
	ORG $+2
	DD	0fH
	DB	00H
	DB	08H
	ORG $+2
	DD	08fH
	DB	00H
	DB	08H
	ORG $+2
	DD	04fH
	DB	00H
	DB	09H
	ORG $+2
	DD	0ffH
_fixed_td DB	050H
	DB	05H
	ORG $+2
	DD	01H
	DB	057H
	DB	05H
	ORG $+2
	DD	0101H
	DB	053H
	DB	05H
	ORG $+2
	DD	011H
	DB	05bH
	DB	05H
	ORG $+2
	DD	01001H
	DB	051H
	DB	05H
	ORG $+2
	DD	05H
	DB	059H
	DB	05H
	ORG $+2
	DD	0401H
	DB	055H
	DB	05H
	ORG $+2
	DD	041H
	DB	05dH
	DB	05H
	ORG $+2
	DD	04001H
	DB	050H
	DB	05H
	ORG $+2
	DD	03H
	DB	058H
	DB	05H
	ORG $+2
	DD	0201H
	DB	054H
	DB	05H
	ORG $+2
	DD	021H
	DB	05cH
	DB	05H
	ORG $+2
	DD	02001H
	DB	052H
	DB	05H
	ORG $+2
	DD	09H
	DB	05aH
	DB	05H
	ORG $+2
	DD	0801H
	DB	056H
	DB	05H
	ORG $+2
	DD	081H
	DB	0c0H
	DB	05H
	ORG $+2
	DD	06001H
	DB	050H
	DB	05H
	ORG $+2
	DD	02H
	DB	057H
	DB	05H
	ORG $+2
	DD	0181H
	DB	053H
	DB	05H
	ORG $+2
	DD	019H
	DB	05bH
	DB	05H
	ORG $+2
	DD	01801H
	DB	051H
	DB	05H
	ORG $+2
	DD	07H
	DB	059H
	DB	05H
	ORG $+2
	DD	0601H
	DB	055H
	DB	05H
	ORG $+2
	DD	061H
	DB	05dH
	DB	05H
	ORG $+2
	DD	06001H
	DB	050H
	DB	05H
	ORG $+2
	DD	04H
	DB	058H
	DB	05H
	ORG $+2
	DD	0301H
	DB	054H
	DB	05H
	ORG $+2
	DD	031H
	DB	05cH
	DB	05H
	ORG $+2
	DD	03001H
	DB	052H
	DB	05H
	ORG $+2
	DD	0dH
	DB	05aH
	DB	05H
	ORG $+2
	DD	0c01H
	DB	056H
	DB	05H
	ORG $+2
	DD	0c1H
	DB	0c0H
	DB	05H
	ORG $+2
	DD	06001H
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\inftrees.c
_DATA	ENDS
;	COMDAT @huft_build@40
_TEXT	SEGMENT
_l$ = -252						; size = 4
_k$ = -248						; size = 4
_h$ = -244						; size = 4
_a$ = -240						; size = 4
_p$ = -236						; size = 4
tv1158 = -232						; size = 4
_g$ = -228						; size = 4
_i$ = -224						; size = 4
tv540 = -220						; size = 4
_q$ = -220						; size = 4
_r$ = -216						; size = 8
tv1082 = -208						; size = 4
tv1144 = -204						; size = 4
tv1084 = -200						; size = 4
tv608 = -196						; size = 4
_y$ = -192						; size = 4
_c$ = -188						; size = 64
_x$ = -124						; size = 64
_u$ = -60						; size = 60
_n$ = 8							; size = 4
_s$ = 12						; size = 4
_d$ = 16						; size = 4
_e$ = 20						; size = 4
_t$ = 24						; size = 4
_hp$ = 28						; size = 4
_hn$ = 32						; size = 4
_v$ = 36						; size = 4
@huft_build@40 PROC NEAR				; COMDAT
; _b$ = ecx
; _m$ = eax

; 108  : {

  00000	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00006	53		 push	 ebx
  00007	55		 push	 ebp

; 109  : 
; 110  :   uInt a;                       /* counter for codes of length k */
; 111  :   uInt c[BMAX+1];               /* bit length count table */
; 112  :   uInt f;                       /* i repeats in table every f entries */
; 113  :   int g;                        /* maximum code length */
; 114  :   int h;                        /* table level */
; 115  :   register uInt i;              /* counter, current code */
; 116  :   register uInt j;              /* counter */
; 117  :   register int k;               /* number of bits in current code */
; 118  :   int l;                        /* bits per table (returned in m) */
; 119  :   uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */
; 120  :   register uIntf *p;            /* pointer into c[], b[], or v[] */
; 121  :   inflate_huft *q;              /* points to current table */
; 122  :   struct inflate_huft_s r;      /* table entry for structure assignment */
; 123  :   inflate_huft *u[BMAX];        /* table stack */
; 124  :   register int w;               /* bits before this table == (l * h) */
; 125  :   uInt x[BMAX+1];               /* bit offsets, then code stack */
; 126  :   uIntf *xp;                    /* pointer into x */
; 127  :   int y;                        /* number of dummy codes added */
; 128  :   uInt z;                       /* number of entries in current table */
; 129  : 
; 130  : 
; 131  :   /* Generate counts for each bit length */
; 132  :   p = c;
; 133  : #define C0 *p++ = 0;
; 134  : #define C2 C0 C0 C0 C0
; 135  : #define C4 C2 C2 C2 C2
; 136  :   C4                            /* clear c[]--assume BMAX+1 is 16 */

  00008	33 ed		 xor	 ebp, ebp
  0000a	56		 push	 esi

; 137  :   p = b;  i = n;

  0000b	8b b4 24 0c 01
	00 00		 mov	 esi, DWORD PTR _n$[esp+260]
  00012	57		 push	 edi
  00013	8b d9		 mov	 ebx, ecx
  00015	8b f8		 mov	 edi, eax
  00017	89 6c 24 50	 mov	 DWORD PTR _c$[esp+268], ebp
  0001b	89 6c 24 54	 mov	 DWORD PTR _c$[esp+272], ebp
  0001f	89 6c 24 58	 mov	 DWORD PTR _c$[esp+276], ebp
  00023	89 6c 24 5c	 mov	 DWORD PTR _c$[esp+280], ebp
  00027	89 6c 24 60	 mov	 DWORD PTR _c$[esp+284], ebp
  0002b	89 6c 24 64	 mov	 DWORD PTR _c$[esp+288], ebp
  0002f	89 6c 24 68	 mov	 DWORD PTR _c$[esp+292], ebp
  00033	89 6c 24 6c	 mov	 DWORD PTR _c$[esp+296], ebp
  00037	89 6c 24 70	 mov	 DWORD PTR _c$[esp+300], ebp
  0003b	89 6c 24 74	 mov	 DWORD PTR _c$[esp+304], ebp
  0003f	89 6c 24 78	 mov	 DWORD PTR _c$[esp+308], ebp
  00043	89 6c 24 7c	 mov	 DWORD PTR _c$[esp+312], ebp
  00047	89 ac 24 80 00
	00 00		 mov	 DWORD PTR _c$[esp+316], ebp
  0004e	89 ac 24 84 00
	00 00		 mov	 DWORD PTR _c$[esp+320], ebp
  00055	89 ac 24 88 00
	00 00		 mov	 DWORD PTR _c$[esp+324], ebp
  0005c	89 ac 24 8c 00
	00 00		 mov	 DWORD PTR _c$[esp+328], ebp
  00063	8b c3		 mov	 eax, ebx
  00065	8b d6		 mov	 edx, esi
  00067	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L1703:

; 138  :   do {
; 139  :     c[*p++]++;                  /* assume all entries <= BMAX */

  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	ff 44 8c 50	 inc	 DWORD PTR _c$[esp+ecx*4+268]
  00076	8d 4c 8c 50	 lea	 ecx, DWORD PTR _c$[esp+ecx*4+268]
  0007a	83 c0 04	 add	 eax, 4

; 140  :   } while (--i);

  0007d	4a		 dec	 edx
  0007e	75 f0		 jne	 SHORT $L1703

; 141  :   if (c[0] == n)                /* null input--all zero length codes */

  00080	39 74 24 50	 cmp	 DWORD PTR _c$[esp+268], esi
  00084	75 1a		 jne	 SHORT $L1706

; 142  :   {
; 143  :     *t = (inflate_huft *)Z_NULL;

  00086	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR _t$[esp+264]
  0008d	89 28		 mov	 DWORD PTR [eax], ebp

; 144  :     *m = 0;

  0008f	89 2f		 mov	 DWORD PTR [edi], ebp
$L1869:
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5d		 pop	 ebp

; 283  :       }
; 284  :     }
; 285  :   }
; 286  : 
; 287  : 
; 288  :   /* Return Z_BUF_ERROR if we were given an incomplete table */
; 289  :   return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;

  00094	33 c0		 xor	 eax, eax
  00096	5b		 pop	 ebx

; 290  : }

  00097	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  0009d	c2 20 00	 ret	 32			; 00000020H
$L1706:

; 145  :     return Z_OK;
; 146  :   }
; 147  : 
; 148  : 
; 149  :   /* Find minimum and maximum length, bound *m by those */
; 150  :   l = *m;

  000a0	8b 07		 mov	 eax, DWORD PTR [edi]
  000a2	89 44 24 10	 mov	 DWORD PTR _l$[esp+268], eax

; 151  :   for (j = 1; j <= BMAX; j++)

  000a6	b9 01 00 00 00	 mov	 ecx, 1
  000ab	eb 03 8d 49 00	 npad	 5
$L1708:

; 152  :     if (c[j])

  000b0	39 6c 8c 50	 cmp	 DWORD PTR _c$[esp+ecx*4+268], ebp
  000b4	75 32		 jne	 SHORT $L1905
  000b6	39 6c 8c 54	 cmp	 DWORD PTR _c$[esp+ecx*4+272], ebp
  000ba	75 1c		 jne	 SHORT $L1901
  000bc	39 6c 8c 58	 cmp	 DWORD PTR _c$[esp+ecx*4+276], ebp
  000c0	75 19		 jne	 SHORT $L1902
  000c2	39 6c 8c 5c	 cmp	 DWORD PTR _c$[esp+ecx*4+280], ebp
  000c6	75 18		 jne	 SHORT $L1903
  000c8	39 6c 8c 60	 cmp	 DWORD PTR _c$[esp+ecx*4+284], ebp
  000cc	75 17		 jne	 SHORT $L1904
  000ce	83 c1 05	 add	 ecx, 5
  000d1	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  000d4	76 da		 jbe	 SHORT $L1708

; 283  :       }
; 284  :     }
; 285  :   }
; 286  : 
; 287  : 
; 288  :   /* Return Z_BUF_ERROR if we were given an incomplete table */
; 289  :   return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;

  000d6	eb 10		 jmp	 SHORT $L1905
$L1901:

; 152  :     if (c[j])

  000d8	41		 inc	 ecx

; 283  :       }
; 284  :     }
; 285  :   }
; 286  : 
; 287  : 
; 288  :   /* Return Z_BUF_ERROR if we were given an incomplete table */
; 289  :   return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;

  000d9	eb 0d		 jmp	 SHORT $L1905
$L1902:

; 152  :     if (c[j])

  000db	83 c1 02	 add	 ecx, 2

; 283  :       }
; 284  :     }
; 285  :   }
; 286  : 
; 287  : 
; 288  :   /* Return Z_BUF_ERROR if we were given an incomplete table */
; 289  :   return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;

  000de	eb 08		 jmp	 SHORT $L1905
$L1903:

; 152  :     if (c[j])

  000e0	83 c1 03	 add	 ecx, 3

; 283  :       }
; 284  :     }
; 285  :   }
; 286  : 
; 287  : 
; 288  :   /* Return Z_BUF_ERROR if we were given an incomplete table */
; 289  :   return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;

  000e3	eb 03		 jmp	 SHORT $L1905
$L1904:

; 152  :     if (c[j])

  000e5	83 c1 04	 add	 ecx, 4
$L1905:

; 153  :       break;
; 154  :   k = j;                        /* minimum code length */
; 155  :   if ((uInt)l < j)

  000e8	3b c1		 cmp	 eax, ecx
  000ea	89 4c 24 14	 mov	 DWORD PTR _k$[esp+268], ecx
  000ee	73 06		 jae	 SHORT $L1713

; 156  :     l = j;

  000f0	89 4c 24 10	 mov	 DWORD PTR _l$[esp+268], ecx
  000f4	8b c1		 mov	 eax, ecx
$L1713:

; 157  :   for (i = BMAX; i; i--)

  000f6	be 0f 00 00 00	 mov	 esi, 15			; 0000000fH
  000fb	eb 03 8d 49 00	 npad	 5
$L1714:

; 158  :     if (c[i])

  00100	39 6c b4 50	 cmp	 DWORD PTR _c$[esp+esi*4+268], ebp
  00104	75 03		 jne	 SHORT $L1887

; 157  :   for (i = BMAX; i; i--)

  00106	4e		 dec	 esi
  00107	75 f7		 jne	 SHORT $L1714
$L1887:

; 159  :       break;
; 160  :   g = i;                        /* maximum code length */
; 161  :   if ((uInt)l > i)

  00109	3b c6		 cmp	 eax, esi
  0010b	89 74 24 28	 mov	 DWORD PTR _g$[esp+268], esi
  0010f	76 06		 jbe	 SHORT $L1719

; 162  :     l = i;

  00111	89 74 24 10	 mov	 DWORD PTR _l$[esp+268], esi
  00115	8b c6		 mov	 eax, esi
$L1719:

; 163  :   *m = l;
; 164  : 
; 165  : 
; 166  :   /* Adjust last length count to fill out codes, if needed */
; 167  :   for (y = 1 << j; j < i; j++, y <<= 1)

  00117	ba 01 00 00 00	 mov	 edx, 1
  0011c	d3 e2		 shl	 edx, cl
  0011e	3b ce		 cmp	 ecx, esi
  00120	89 07		 mov	 DWORD PTR [edi], eax
  00122	73 11		 jae	 SHORT $L1722
$L1720:

; 168  :     if ((y -= c[j]) < 0)

  00124	2b 54 8c 50	 sub	 edx, DWORD PTR _c$[esp+ecx*4+268]
  00128	0f 88 ac 03 00
	00		 js	 $L1890
  0012e	41		 inc	 ecx
  0012f	d1 e2		 shl	 edx, 1
  00131	3b ce		 cmp	 ecx, esi
  00133	72 ef		 jb	 SHORT $L1720
$L1722:

; 169  :       return Z_DATA_ERROR;
; 170  :   if ((y -= c[i]) < 0)

  00135	8d 0c b5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*4]
  0013c	8d 7c 0c 50	 lea	 edi, DWORD PTR _c$[esp+ecx+268]
  00140	89 4c 24 30	 mov	 DWORD PTR tv540[esp+268], ecx
  00144	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00146	2b d1		 sub	 edx, ecx
  00148	89 54 24 4c	 mov	 DWORD PTR _y$[esp+268], edx

; 171  :     return Z_DATA_ERROR;

  0014c	0f 88 88 03 00
	00		 js	 $L1890

; 172  :   c[i] += y;

  00152	03 ca		 add	 ecx, edx
  00154	89 0f		 mov	 DWORD PTR [edi], ecx

; 173  : 
; 174  : 
; 175  :   /* Generate starting offsets into the value table for each length */
; 176  :   x[1] = j = 0;

  00156	33 c9		 xor	 ecx, ecx

; 177  :   p = c + 1;  xp = x + 2;
; 178  :   while (--i) {                 /* note that i == g from above */

  00158	4e		 dec	 esi
  00159	89 ac 24 94 00
	00 00		 mov	 DWORD PTR _x$[esp+272], ebp
  00160	74 13		 je	 SHORT $L1727
  00162	33 ff		 xor	 edi, edi
$L1726:

; 179  :     *xp++ = (j += *p++);

  00164	03 4c 3c 54	 add	 ecx, DWORD PTR _c$[esp+edi+272]
  00168	83 c7 04	 add	 edi, 4
  0016b	4e		 dec	 esi
  0016c	89 8c 3c 94 00
	00 00		 mov	 DWORD PTR _x$[esp+edi+272], ecx
  00173	75 ef		 jne	 SHORT $L1726
$L1727:

; 180  :   }
; 181  : 
; 182  : 
; 183  :   /* Make a table of values in order of bit lengths */
; 184  :   p = b;  i = 0;

  00175	8b f3		 mov	 esi, ebx
  00177	33 ff		 xor	 edi, edi
  00179	8d a4 24 00 00
	00 00		 npad	 7
$L1728:

; 185  :   do {
; 186  :     if ((j = *p++) != 0)

  00180	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00182	83 c6 04	 add	 esi, 4
  00185	3b cd		 cmp	 ecx, ebp
  00187	89 74 24 20	 mov	 DWORD PTR _p$[esp+268], esi
  0018b	74 1f		 je	 SHORT $L1729

; 187  :       v[x[j]++] = i;

  0018d	8b b4 8c 90 00
	00 00		 mov	 esi, DWORD PTR _x$[esp+ecx*4+268]
  00194	8b 9c 24 2c 01
	00 00		 mov	 ebx, DWORD PTR _v$[esp+264]
  0019b	8d 8c 8c 90 00
	00 00		 lea	 ecx, DWORD PTR _x$[esp+ecx*4+268]
  001a2	89 3c b3	 mov	 DWORD PTR [ebx+esi*4], edi
  001a5	46		 inc	 esi
  001a6	89 31		 mov	 DWORD PTR [ecx], esi
  001a8	8b 74 24 20	 mov	 esi, DWORD PTR _p$[esp+268]
$L1729:

; 188  :   } while (++i < n);

  001ac	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR _n$[esp+264]
  001b3	47		 inc	 edi
  001b4	3b f9		 cmp	 edi, ecx
  001b6	72 c8		 jb	 SHORT $L1728

; 189  :   n = x[g];                     /* set n to length of v */

  001b8	8b 4c 24 30	 mov	 ecx, DWORD PTR tv540[esp+268]
  001bc	8b 8c 0c 90 00
	00 00		 mov	 ecx, DWORD PTR _x$[esp+ecx+268]

; 190  : 
; 191  : 
; 192  :   /* Generate the Huffman codes and for each, make the table entries */
; 193  :   x[0] = i = 0;                 /* first Huffman code is zero */
; 194  :   p = v;                        /* grab values in bit order */
; 195  :   h = -1;                       /* no tables yet--level -1 */
; 196  :   w = -l;                       /* bits decoded == (l * h) */
; 197  :   u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
; 198  :   q = (inflate_huft *)Z_NULL;   /* ditto */
; 199  :   z = 0;                        /* ditto */
; 200  : 
; 201  :   /* go through the bit lengths (k already is bits in shortest code) */
; 202  :   for (; k <= g; k++)

  001c3	8b 74 24 28	 mov	 esi, DWORD PTR _g$[esp+268]
  001c7	89 8c 24 10 01
	00 00		 mov	 DWORD PTR _n$[esp+264], ecx
  001ce	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR _v$[esp+264]
  001d5	89 4c 24 20	 mov	 DWORD PTR _p$[esp+268], ecx
  001d9	8b 4c 24 14	 mov	 ecx, DWORD PTR _k$[esp+268]
  001dd	8b d8		 mov	 ebx, eax
  001df	33 ff		 xor	 edi, edi
  001e1	f7 db		 neg	 ebx
  001e3	3b ce		 cmp	 ecx, esi
  001e5	89 6c 24 2c	 mov	 DWORD PTR _i$[esp+268], ebp
  001e9	89 ac 24 90 00
	00 00		 mov	 DWORD PTR _x$[esp+268], ebp
  001f0	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR _h$[esp+268], -1
  001f8	89 bc 24 d0 00
	00 00		 mov	 DWORD PTR _u$[esp+268], edi
  001ff	89 7c 24 30	 mov	 DWORD PTR _q$[esp+268], edi
  00203	0f 8f ac 02 00
	00		 jg	 $L1736
  00209	8b 74 24 38	 mov	 esi, DWORD PTR _r$[esp+272]
  0020d	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  00210	89 54 24 40	 mov	 DWORD PTR tv1144[esp+268], edx
  00214	8d 54 8c 50	 lea	 edx, DWORD PTR _c$[esp+ecx*4+268]
  00218	89 54 24 24	 mov	 DWORD PTR tv1158[esp+268], edx
  0021c	8d 64 24 00	 npad	 4
$L1910:

; 203  :   {
; 204  :     a = c[k];

  00220	8b 54 24 24	 mov	 edx, DWORD PTR tv1158[esp+268]
  00224	8b 12		 mov	 edx, DWORD PTR [edx]

; 205  :     while (a--)

  00226	85 d2		 test	 edx, edx
  00228	89 54 24 1c	 mov	 DWORD PTR _a$[esp+268], edx
  0022c	0f 84 62 02 00
	00		 je	 $L1913
$L1738:
  00232	8b 4c 24 1c	 mov	 ecx, DWORD PTR _a$[esp+268]

; 206  :     {
; 207  :       /* here i is the Huffman code of length k bits for value *p */
; 208  :       /* make tables up to required level */
; 209  :       while (k > w + l)

  00236	8b 54 24 14	 mov	 edx, DWORD PTR _k$[esp+268]
  0023a	49		 dec	 ecx
  0023b	89 4c 24 1c	 mov	 DWORD PTR _a$[esp+268], ecx
  0023f	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  00242	3b d1		 cmp	 edx, ecx
  00244	0f 8e 23 01 00
	00		 jle	 $L1912
  0024a	89 4c 24 3c	 mov	 DWORD PTR tv1082[esp+268], ecx
  0024e	8b cb		 mov	 ecx, ebx
  00250	2b c8		 sub	 ecx, eax
  00252	eb 0c		 jmp	 SHORT $L1741
$L1907:

; 205  :     while (a--)

  00254	8b 44 24 10	 mov	 eax, DWORD PTR _l$[esp+268]
  00258	8b 4c 24 44	 mov	 ecx, DWORD PTR tv1084[esp+268]
  0025c	8d 64 24 00	 npad	 4
$L1741:

; 210  :       {
; 211  :         h++;

  00260	8b 6c 24 18	 mov	 ebp, DWORD PTR _h$[esp+268]

; 212  :         w += l;                 /* previous table always l bits */
; 213  : 
; 214  :         /* compute minimum size table less than or equal to l bits */
; 215  :         z = g - w;

  00264	8b 54 24 28	 mov	 edx, DWORD PTR _g$[esp+268]
  00268	45		 inc	 ebp
  00269	89 6c 24 18	 mov	 DWORD PTR _h$[esp+268], ebp
  0026d	8b 6c 24 3c	 mov	 ebp, DWORD PTR tv1082[esp+268]
  00271	03 d8		 add	 ebx, eax
  00273	03 c8		 add	 ecx, eax
  00275	03 e8		 add	 ebp, eax
  00277	2b d3		 sub	 edx, ebx

; 216  :         z = z > (uInt)l ? l : z;        /* table size upper limit */

  00279	3b d0		 cmp	 edx, eax
  0027b	89 4c 24 44	 mov	 DWORD PTR tv1084[esp+268], ecx
  0027f	89 6c 24 3c	 mov	 DWORD PTR tv1082[esp+268], ebp
  00283	76 02		 jbe	 SHORT $L1867
  00285	8b d0		 mov	 edx, eax
$L1867:

; 217  :         if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */

  00287	8b 4c 24 14	 mov	 ecx, DWORD PTR _k$[esp+268]
  0028b	8b 6c 24 1c	 mov	 ebp, DWORD PTR _a$[esp+268]
  0028f	2b cb		 sub	 ecx, ebx
  00291	b8 01 00 00 00	 mov	 eax, 1
  00296	d3 e0		 shl	 eax, cl
  00298	8d 7d 01	 lea	 edi, DWORD PTR [ebp+1]
  0029b	3b c7		 cmp	 eax, edi
  0029d	76 27		 jbe	 SHORT $L1908

; 218  :         {                       /* too few codes for k-w bit table */
; 219  :           f -= a + 1;           /* deduct codes from patterns left */

  0029f	83 cf ff	 or	 edi, -1
  002a2	2b fd		 sub	 edi, ebp

; 220  :           xp = c + k;

  002a4	8b 6c 24 24	 mov	 ebp, DWORD PTR tv1158[esp+268]
  002a8	03 c7		 add	 eax, edi

; 221  :           if (j < z)

  002aa	3b ca		 cmp	 ecx, edx
  002ac	73 18		 jae	 SHORT $L1908

; 222  :             while (++j < z)     /* try smaller tables up to z bits */

  002ae	41		 inc	 ecx
  002af	3b ca		 cmp	 ecx, edx
  002b1	73 13		 jae	 SHORT $L1908
$L1747:

; 223  :             {
; 224  :               if ((f <<= 1) <= *++xp)

  002b3	8b 7d 04	 mov	 edi, DWORD PTR [ebp+4]
  002b6	83 c5 04	 add	 ebp, 4
  002b9	d1 e0		 shl	 eax, 1
  002bb	3b c7		 cmp	 eax, edi
  002bd	76 07		 jbe	 SHORT $L1908

; 225  :                 break;          /* enough codes to use up j bits */
; 226  :               f -= *xp;         /* else deduct codes from patterns */

  002bf	2b c7		 sub	 eax, edi
  002c1	41		 inc	 ecx
  002c2	3b ca		 cmp	 ecx, edx
  002c4	72 ed		 jb	 SHORT $L1747
$L1908:

; 227  :             }
; 228  :         }
; 229  :         z = 1 << j;             /* table entries for j-bit table */
; 230  : 
; 231  :         /* allocate new table */
; 232  :         if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */

  002c6	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR _hn$[esp+264]
  002cd	8b 00		 mov	 eax, DWORD PTR [eax]
  002cf	bf 01 00 00 00	 mov	 edi, 1
  002d4	d3 e7		 shl	 edi, cl
  002d6	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  002d9	81 fa a0 05 00
	00		 cmp	 edx, 1440		; 000005a0H
  002df	0f 87 f5 01 00
	00		 ja	 $L1890

; 234  :         u[h] = q = hp + *hn;

  002e5	8b ac 24 24 01
	00 00		 mov	 ebp, DWORD PTR _hp$[esp+264]
  002ec	8d 6c c5 00	 lea	 ebp, DWORD PTR [ebp+eax*8]
  002f0	8b 44 24 18	 mov	 eax, DWORD PTR _h$[esp+268]
  002f4	8d 84 84 d0 00
	00 00		 lea	 eax, DWORD PTR _u$[esp+eax*4+268]
  002fb	89 44 24 48	 mov	 DWORD PTR tv608[esp+268], eax
  002ff	89 28		 mov	 DWORD PTR [eax], ebp

; 235  :         *hn += z;

  00301	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR _hn$[esp+264]
  00308	89 10		 mov	 DWORD PTR [eax], edx

; 236  : 
; 237  :         /* connect to last table, if there is one */
; 238  :         if (h)

  0030a	8b 44 24 18	 mov	 eax, DWORD PTR _h$[esp+268]
  0030e	85 c0		 test	 eax, eax
  00310	89 6c 24 30	 mov	 DWORD PTR _q$[esp+268], ebp
  00314	74 3c		 je	 SHORT $L1751

; 239  :         {
; 240  :           x[h] = i;             /* save pattern for backing up */

  00316	8b 74 24 2c	 mov	 esi, DWORD PTR _i$[esp+268]

; 241  :           r.bits = (Byte)l;     /* bits to dump before this table */

  0031a	8a 54 24 10	 mov	 dl, BYTE PTR _l$[esp+268]
  0031e	89 b4 84 90 00
	00 00		 mov	 DWORD PTR _x$[esp+eax*4+268], esi

; 242  :           r.exop = (Byte)j;     /* bits in this table */

  00325	88 4c 24 34	 mov	 BYTE PTR _r$[esp+268], cl

; 243  :           j = i >> (w - l);

  00329	8b 4c 24 44	 mov	 ecx, DWORD PTR tv1084[esp+268]
  0032d	8b c6		 mov	 eax, esi
  0032f	d3 e8		 shr	 eax, cl

; 244  :           r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */

  00331	8b 4c 24 48	 mov	 ecx, DWORD PTR tv608[esp+268]
  00335	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00338	8b f5		 mov	 esi, ebp
  0033a	2b f1		 sub	 esi, ecx
  0033c	88 54 24 35	 mov	 BYTE PTR _r$[esp+269], dl

; 245  :           u[h-1][j] = r;        /* connect to last table */

  00340	8b 54 24 34	 mov	 edx, DWORD PTR _r$[esp+268]
  00344	c1 fe 03	 sar	 esi, 3
  00347	2b f0		 sub	 esi, eax
  00349	89 14 c1	 mov	 DWORD PTR [ecx+eax*8], edx
  0034c	89 74 c1 04	 mov	 DWORD PTR [ecx+eax*8+4], esi

; 246  :         }
; 247  :         else

  00350	eb 09		 jmp	 SHORT $L1755
$L1751:

; 248  :           *t = q;               /* first table is returned result */

  00352	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR _t$[esp+264]
  00359	89 28		 mov	 DWORD PTR [eax], ebp
$L1755:
  0035b	8b 4c 24 3c	 mov	 ecx, DWORD PTR tv1082[esp+268]
  0035f	39 4c 24 14	 cmp	 DWORD PTR _k$[esp+268], ecx
  00363	0f 8f eb fe ff
	ff		 jg	 $L1907

; 206  :     {
; 207  :       /* here i is the Huffman code of length k bits for value *p */
; 208  :       /* make tables up to required level */
; 209  :       while (k > w + l)

  00369	8b 6c 24 2c	 mov	 ebp, DWORD PTR _i$[esp+268]
$L1912:

; 249  :       }
; 250  : 
; 251  :       /* set up table entry in r */
; 252  :       r.bits = (Byte)(k - w);

  0036d	8b 54 24 14	 mov	 edx, DWORD PTR _k$[esp+268]

; 253  :       if (p >= v + n)

  00371	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR _v$[esp+264]
  00378	8a c2		 mov	 al, dl
  0037a	2a c3		 sub	 al, bl
  0037c	88 44 24 35	 mov	 BYTE PTR _r$[esp+269], al
  00380	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR _n$[esp+264]
  00387	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  0038a	8b 44 24 20	 mov	 eax, DWORD PTR _p$[esp+268]
  0038e	3b c1		 cmp	 eax, ecx
  00390	72 07		 jb	 SHORT $L1757

; 254  :         r.exop = 128 + 64;      /* out of values--invalid code */

  00392	c6 44 24 34 c0	 mov	 BYTE PTR _r$[esp+268], 192 ; 000000c0H

; 255  :       else if (*p < s)

  00397	eb 48		 jmp	 SHORT $L1761
$L1757:
  00399	8b 30		 mov	 esi, DWORD PTR [eax]
  0039b	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR _s$[esp+264]
  003a2	3b f1		 cmp	 esi, ecx
  003a4	73 14		 jae	 SHORT $L1759

; 256  :       {
; 257  :         r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */

  003a6	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  003ac	0f 92 c1	 setb	 cl
  003af	fe c9		 dec	 cl
  003b1	83 e1 60	 and	 ecx, 96			; 00000060H
  003b4	88 4c 24 34	 mov	 BYTE PTR _r$[esp+268], cl

; 258  :         r.base = *p++;          /* simple code is just the value */
; 259  :       }
; 260  :       else

  003b8	eb 20		 jmp	 SHORT $L1914
$L1759:

; 261  :       {
; 262  :         r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */

  003ba	2b f1		 sub	 esi, ecx
  003bc	8b 8c 24 1c 01
	00 00		 mov	 ecx, DWORD PTR _e$[esp+264]
  003c3	c1 e6 02	 shl	 esi, 2
  003c6	8a 0c 0e	 mov	 cl, BYTE PTR [esi+ecx]
  003c9	80 c1 50	 add	 cl, 80			; 00000050H
  003cc	88 4c 24 34	 mov	 BYTE PTR _r$[esp+268], cl

; 263  :         r.base = d[*p++ - s];

  003d0	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR _d$[esp+264]
  003d7	8b 34 0e	 mov	 esi, DWORD PTR [esi+ecx]
$L1914:
  003da	83 c0 04	 add	 eax, 4
  003dd	89 44 24 20	 mov	 DWORD PTR _p$[esp+268], eax
$L1761:

; 264  :       }
; 265  : 
; 266  :       /* fill code-like entries with r */
; 267  :       f = 1 << (k - w);

  003e1	8b ca		 mov	 ecx, edx
  003e3	2b cb		 sub	 ecx, ebx
  003e5	ba 01 00 00 00	 mov	 edx, 1
  003ea	d3 e2		 shl	 edx, cl

; 268  :       for (j = i >> w; j < z; j += f)

  003ec	8b c5		 mov	 eax, ebp
  003ee	8b cb		 mov	 ecx, ebx
  003f0	d3 e8		 shr	 eax, cl
  003f2	3b c7		 cmp	 eax, edi
  003f4	73 26		 jae	 SHORT $L1765
  003f6	8b 4c 24 30	 mov	 ecx, DWORD PTR _q$[esp+268]
  003fa	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
  003fd	8d 49 00	 npad	 3
$L1909:

; 269  :         q[j] = r;

  00400	8b 6c 24 34	 mov	 ebp, DWORD PTR _r$[esp+268]
  00404	89 29		 mov	 DWORD PTR [ecx], ebp
  00406	8d 2c d5 00 00
	00 00		 lea	 ebp, DWORD PTR [edx*8]
  0040d	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00410	03 c2		 add	 eax, edx
  00412	03 cd		 add	 ecx, ebp
  00414	3b c7		 cmp	 eax, edi
  00416	72 e8		 jb	 SHORT $L1909

; 268  :       for (j = i >> w; j < z; j += f)

  00418	8b 6c 24 2c	 mov	 ebp, DWORD PTR _i$[esp+268]
$L1765:

; 270  : 
; 271  :       /* backwards increment the k-bit code i */
; 272  :       for (j = 1 << (k - 1); i & j; j >>= 1)

  0041c	8b 4c 24 40	 mov	 ecx, DWORD PTR tv1144[esp+268]
  00420	b8 01 00 00 00	 mov	 eax, 1
  00425	d3 e0		 shl	 eax, cl
  00427	85 c5		 test	 eax, ebp
  00429	74 0d		 je	 SHORT $L1768
  0042b	eb 03 8d 49 00	 npad	 5
$L1766:

; 273  :         i ^= j;

  00430	33 e8		 xor	 ebp, eax
  00432	d1 e8		 shr	 eax, 1
  00434	85 c5		 test	 eax, ebp
  00436	75 f8		 jne	 SHORT $L1766
$L1768:

; 274  :       i ^= j;
; 275  : 
; 276  :       /* backup over finished tables */
; 277  :       mask = (1 << w) - 1;      /* needed on HP, cc -O bug */

  00438	8b cb		 mov	 ecx, ebx
  0043a	ba 01 00 00 00	 mov	 edx, 1
  0043f	d3 e2		 shl	 edx, cl
  00441	33 e8		 xor	 ebp, eax

; 278  :       while ((i & mask) != x[h])

  00443	8b 44 24 18	 mov	 eax, DWORD PTR _h$[esp+268]
  00447	8b 8c 84 90 00
	00 00		 mov	 ecx, DWORD PTR _x$[esp+eax*4+268]
  0044e	4a		 dec	 edx
  0044f	23 d5		 and	 edx, ebp
  00451	3b d1		 cmp	 edx, ecx
  00453	89 6c 24 2c	 mov	 DWORD PTR _i$[esp+268], ebp
  00457	74 27		 je	 SHORT $L1771
  00459	8d a4 24 00 00
	00 00		 npad	 7
$L1770:

; 281  :         w -= l;

  00460	2b 5c 24 10	 sub	 ebx, DWORD PTR _l$[esp+268]

; 282  :         mask = (1 << w) - 1;

  00464	8b cb		 mov	 ecx, ebx
  00466	ba 01 00 00 00	 mov	 edx, 1
  0046b	d3 e2		 shl	 edx, cl
  0046d	8b 8c 84 8c 00
	00 00		 mov	 ecx, DWORD PTR _x$[esp+eax*4+264]
  00474	48		 dec	 eax
  00475	4a		 dec	 edx
  00476	23 d5		 and	 edx, ebp
  00478	3b d1		 cmp	 edx, ecx
  0047a	75 e4		 jne	 SHORT $L1770

; 279  :       {
; 280  :         h--;                    /* don't need to update q */

  0047c	89 44 24 18	 mov	 DWORD PTR _h$[esp+268], eax
$L1771:

; 205  :     while (a--)

  00480	8b 44 24 1c	 mov	 eax, DWORD PTR _a$[esp+268]
  00484	85 c0		 test	 eax, eax
  00486	8b 44 24 10	 mov	 eax, DWORD PTR _l$[esp+268]
  0048a	0f 85 a2 fd ff
	ff		 jne	 $L1738
  00490	8b 4c 24 14	 mov	 ecx, DWORD PTR _k$[esp+268]
$L1913:

; 190  : 
; 191  : 
; 192  :   /* Generate the Huffman codes and for each, make the table entries */
; 193  :   x[0] = i = 0;                 /* first Huffman code is zero */
; 194  :   p = v;                        /* grab values in bit order */
; 195  :   h = -1;                       /* no tables yet--level -1 */
; 196  :   w = -l;                       /* bits decoded == (l * h) */
; 197  :   u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
; 198  :   q = (inflate_huft *)Z_NULL;   /* ditto */
; 199  :   z = 0;                        /* ditto */
; 200  : 
; 201  :   /* go through the bit lengths (k already is bits in shortest code) */
; 202  :   for (; k <= g; k++)

  00494	83 44 24 24 04	 add	 DWORD PTR tv1158[esp+268], 4
  00499	8b 54 24 40	 mov	 edx, DWORD PTR tv1144[esp+268]
  0049d	41		 inc	 ecx
  0049e	42		 inc	 edx
  0049f	89 54 24 40	 mov	 DWORD PTR tv1144[esp+268], edx
  004a3	3b 4c 24 28	 cmp	 ecx, DWORD PTR _g$[esp+268]
  004a7	89 4c 24 14	 mov	 DWORD PTR _k$[esp+268], ecx
  004ab	0f 8e 6f fd ff
	ff		 jle	 $L1910

; 227  :             }
; 228  :         }
; 229  :         z = 1 << j;             /* table entries for j-bit table */
; 230  : 
; 231  :         /* allocate new table */
; 232  :         if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */

  004b1	8b 54 24 4c	 mov	 edx, DWORD PTR _y$[esp+268]
$L1736:

; 283  :       }
; 284  :     }
; 285  :   }
; 286  : 
; 287  : 
; 288  :   /* Return Z_BUF_ERROR if we were given an incomplete table */
; 289  :   return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;

  004b5	85 d2		 test	 edx, edx
  004b7	0f 84 d4 fb ff
	ff		 je	 $L1869
  004bd	83 7c 24 28 01	 cmp	 DWORD PTR _g$[esp+268], 1
  004c2	0f 84 c9 fb ff
	ff		 je	 $L1869
  004c8	5f		 pop	 edi
  004c9	5e		 pop	 esi
  004ca	5d		 pop	 ebp
  004cb	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  004d0	5b		 pop	 ebx

; 290  : }

  004d1	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  004d7	c2 20 00	 ret	 32			; 00000020H
$L1890:
  004da	5f		 pop	 edi
  004db	5e		 pop	 esi
  004dc	5d		 pop	 ebp

; 233  :           return Z_DATA_ERROR;  /* overflow of MANY */

  004dd	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  004e2	5b		 pop	 ebx

; 290  : }

  004e3	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  004e9	c2 20 00	 ret	 32			; 00000020H
@huft_build@40 ENDP
_TEXT	ENDS
PUBLIC	@inflate_trees_bits@20
PUBLIC	??_C@_0CI@CGMOPDPD@oversubscribed?5dynamic?5bit?5lengt@ ; `string'
PUBLIC	??_C@_0CE@LOHAHEGK@incomplete?5dynamic?5bit?5lengths?5t@ ; `string'
;	COMDAT ??_C@_0CI@CGMOPDPD@oversubscribed?5dynamic?5bit?5lengt@
CONST	SEGMENT
??_C@_0CI@CGMOPDPD@oversubscribed?5dynamic?5bit?5lengt@ DB 'oversubscribe'
	DB	'd dynamic bit lengths tree', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LOHAHEGK@incomplete?5dynamic?5bit?5lengths?5t@
CONST	SEGMENT
??_C@_0CE@LOHAHEGK@incomplete?5dynamic?5bit?5lengths?5t@ DB 'incomplete d'
	DB	'ynamic bit lengths tree', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @inflate_trees_bits@20
_TEXT	SEGMENT
_hn$ = -4						; size = 4
_tb$ = 8						; size = 4
_hp$ = 12						; size = 4
_z$ = 16						; size = 4
@inflate_trees_bits@20 PROC NEAR			; COMDAT
; _c$ = ecx
; _bb$ = edx

; 299  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 300  :   int r;
; 301  :   uInt hn = 0;          /* hufts used in space */
; 302  :   uIntf *v;             /* work area for huft_build */
; 303  : 
; 304  :   if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)

  00002	8b 5c 24 14	 mov	 ebx, DWORD PTR _z$[esp+4]
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b ea		 mov	 ebp, edx
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  00010	6a 04		 push	 4
  00012	ba 13 00 00 00	 mov	 edx, 19			; 00000013H
  00017	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hn$[esp+24], 0
  0001f	ff 53 20	 call	 DWORD PTR [ebx+32]
  00022	8b f8		 mov	 edi, eax
  00024	85 ff		 test	 edi, edi
  00026	75 0d		 jne	 SHORT $L1784
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp

; 305  :     return Z_MEM_ERROR;

  0002b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00030	5b		 pop	 ebx

; 317  : }

  00031	59		 pop	 ecx
  00032	c2 0c 00	 ret	 12			; 0000000cH
$L1784:

; 306  :   r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
; 307  :                  tb, bb, hp, &hn, v);

  00035	8b 4c 24 1c	 mov	 ecx, DWORD PTR _hp$[esp+16]
  00039	8b 54 24 18	 mov	 edx, DWORD PTR _tb$[esp+16]
  0003d	57		 push	 edi
  0003e	8d 44 24 14	 lea	 eax, DWORD PTR _hn$[esp+24]
  00042	50		 push	 eax
  00043	51		 push	 ecx
  00044	52		 push	 edx
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	6a 13		 push	 19			; 00000013H
  0004b	6a 13		 push	 19			; 00000013H
  0004d	8b c5		 mov	 eax, ebp
  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 @huft_build@40
  00056	8b f0		 mov	 esi, eax

; 308  :   if (r == Z_DATA_ERROR)

  00058	83 fe fd	 cmp	 esi, -3			; fffffffdH
  0005b	75 19		 jne	 SHORT $L1787

; 314  :   }
; 315  :   ZFREE(z, v);

  0005d	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  00060	8b d7		 mov	 edx, edi
  00062	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], OFFSET FLAT:??_C@_0CI@CGMOPDPD@oversubscribed?5dynamic?5bit?5lengt@
  00069	ff 53 24	 call	 DWORD PTR [ebx+36]
  0006c	5f		 pop	 edi

; 316  :   return r;

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	5d		 pop	 ebp
  00071	5b		 pop	 ebx

; 317  : }

  00072	59		 pop	 ecx
  00073	c2 0c 00	 ret	 12			; 0000000cH
$L1787:

; 309  :     z->msg = (char*)"oversubscribed dynamic bit lengths tree";
; 310  :   else if (r == Z_BUF_ERROR || *bb == 0)

  00076	83 fe fb	 cmp	 esi, -5			; fffffffbH
  00079	74 06		 je	 SHORT $L1792
  0007b	83 7d 00 00	 cmp	 DWORD PTR [ebp], 0
  0007f	75 0c		 jne	 SHORT $L1791
$L1792:

; 311  :   {
; 312  :     z->msg = (char*)"incomplete dynamic bit lengths tree";

  00081	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], OFFSET FLAT:??_C@_0CE@LOHAHEGK@incomplete?5dynamic?5bit?5lengths?5t@

; 313  :     r = Z_DATA_ERROR;

  00088	be fd ff ff ff	 mov	 esi, -3			; fffffffdH
$L1791:

; 314  :   }
; 315  :   ZFREE(z, v);

  0008d	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  00090	8b d7		 mov	 edx, edi
  00092	ff 53 24	 call	 DWORD PTR [ebx+36]
  00095	5f		 pop	 edi

; 316  :   return r;

  00096	8b c6		 mov	 eax, esi
  00098	5e		 pop	 esi
  00099	5d		 pop	 ebp
  0009a	5b		 pop	 ebx

; 317  : }

  0009b	59		 pop	 ecx
  0009c	c2 0c 00	 ret	 12			; 0000000cH
@inflate_trees_bits@20 ENDP
_TEXT	ENDS
PUBLIC	@inflate_trees_dynamic@36
PUBLIC	??_C@_0CD@GJIDGCKE@oversubscribed?5literal?1length?5tr@ ; `string'
PUBLIC	??_C@_0BP@NEEEJJNA@incomplete?5literal?1length?5tree?$AA@ ; `string'
PUBLIC	??_C@_0BN@KBLCDIAI@oversubscribed?5distance?5tree?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CBCPDPJF@incomplete?5distance?5tree?$AA@ ; `string'
PUBLIC	??_C@_0CB@KPKKKLFO@empty?5distance?5tree?5with?5lengths@ ; `string'
;	COMDAT ??_C@_0BN@KBLCDIAI@oversubscribed?5distance?5tree?$AA@
CONST	SEGMENT
??_C@_0BN@KBLCDIAI@oversubscribed?5distance?5tree?$AA@ DB 'oversubscribed'
	DB	' distance tree', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CBCPDPJF@incomplete?5distance?5tree?$AA@
CONST	SEGMENT
??_C@_0BJ@CBCPDPJF@incomplete?5distance?5tree?$AA@ DB 'incomplete distanc'
	DB	'e tree', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KPKKKLFO@empty?5distance?5tree?5with?5lengths@
CONST	SEGMENT
??_C@_0CB@KPKKKLFO@empty?5distance?5tree?5with?5lengths@ DB 'empty distan'
	DB	'ce tree with lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GJIDGCKE@oversubscribed?5literal?1length?5tr@
CONST	SEGMENT
??_C@_0CD@GJIDGCKE@oversubscribed?5literal?1length?5tr@ DB 'oversubscribe'
	DB	'd literal/length tree', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NEEEJJNA@incomplete?5literal?1length?5tree?$AA@
CONST	SEGMENT
??_C@_0BP@NEEEJJNA@incomplete?5literal?1length?5tree?$AA@ DB 'incomplete '
	DB	'literal/length tree', 00H			; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @inflate_trees_dynamic@36
_TEXT	SEGMENT
_hn$ = -8						; size = 4
_nd$ = -4						; size = 4
_c$ = 8							; size = 4
_bl$ = 12						; size = 4
_bd$ = 16						; size = 4
_tl$ = 20						; size = 4
_td$ = 24						; size = 4
_hp$ = 28						; size = 4
_z$ = 32						; size = 4
@inflate_trees_dynamic@36 PROC NEAR			; COMDAT
; _nl$ = ecx
; _nd$ = edx

; 330  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 331  :   int r;
; 332  :   uInt hn = 0;          /* hufts used in space */
; 333  :   uIntf *v;             /* work area for huft_build */
; 334  : 
; 335  :   /* allocate work area */
; 336  :   if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)

  00005	8b 6c 24 2c	 mov	 ebp, DWORD PTR _z$[esp+12]
  00009	57		 push	 edi
  0000a	89 54 24 10	 mov	 DWORD PTR _nd$[esp+20], edx
  0000e	8b d9		 mov	 ebx, ecx
  00010	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  00013	6a 04		 push	 4
  00015	ba 20 01 00 00	 mov	 edx, 288		; 00000120H
  0001a	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _hn$[esp+24], 0
  00022	ff 55 20	 call	 DWORD PTR [ebp+32]
  00025	8b f8		 mov	 edi, eax
  00027	85 ff		 test	 edi, edi
  00029	75 0e		 jne	 SHORT $L1812
  0002b	5f		 pop	 edi
  0002c	5d		 pop	 ebp

; 337  :     return Z_MEM_ERROR;

  0002d	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00032	5b		 pop	 ebx

; 381  : }

  00033	83 c4 08	 add	 esp, 8
  00036	c2 1c 00	 ret	 28			; 0000001cH
$L1812:

; 338  : 
; 339  :   /* build literal/length tree */
; 340  :   r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);

  00039	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hp$[esp+16]
  0003d	8b 54 24 24	 mov	 edx, DWORD PTR _tl$[esp+16]
  00041	56		 push	 esi
  00042	57		 push	 edi
  00043	8d 44 24 14	 lea	 eax, DWORD PTR _hn$[esp+28]
  00047	50		 push	 eax
  00048	8b 44 24 28	 mov	 eax, DWORD PTR _bl$[esp+28]
  0004c	51		 push	 ecx
  0004d	8b 4c 24 28	 mov	 ecx, DWORD PTR _c$[esp+32]
  00051	52		 push	 edx
  00052	68 00 00 00 00	 push	 OFFSET FLAT:_cplext
  00057	68 00 00 00 00	 push	 OFFSET FLAT:_cplens
  0005c	68 01 01 00 00	 push	 257			; 00000101H
  00061	53		 push	 ebx
  00062	e8 00 00 00 00	 call	 @huft_build@40
  00067	8b f0		 mov	 esi, eax

; 341  :   if (r != Z_OK || *bl == 0)

  00069	85 f6		 test	 esi, esi
  0006b	0f 85 a4 00 00
	00		 jne	 $L1814
  00071	8b 44 24 20	 mov	 eax, DWORD PTR _bl$[esp+20]
  00075	83 38 00	 cmp	 DWORD PTR [eax], 0
  00078	0f 84 bc 00 00
	00		 je	 $L1919

; 352  :   }
; 353  : 
; 354  :   /* build distance tree */
; 355  :   r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);

  0007e	8b 54 24 30	 mov	 edx, DWORD PTR _hp$[esp+20]
  00082	8b 44 24 2c	 mov	 eax, DWORD PTR _td$[esp+20]
  00086	57		 push	 edi
  00087	8d 4c 24 14	 lea	 ecx, DWORD PTR _hn$[esp+28]
  0008b	51		 push	 ecx
  0008c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _nd$[esp+32]
  00090	52		 push	 edx
  00091	8b 54 24 28	 mov	 edx, DWORD PTR _c$[esp+32]
  00095	50		 push	 eax
  00096	8b 44 24 34	 mov	 eax, DWORD PTR _bd$[esp+36]
  0009a	68 00 00 00 00	 push	 OFFSET FLAT:_cpdext
  0009f	68 00 00 00 00	 push	 OFFSET FLAT:_cpdist
  000a4	56		 push	 esi
  000a5	51		 push	 ecx
  000a6	8d 0c 9a	 lea	 ecx, DWORD PTR [edx+ebx*4]
  000a9	e8 00 00 00 00	 call	 @huft_build@40
  000ae	8b f0		 mov	 esi, eax

; 356  :   if (r != Z_OK || (*bd == 0 && nl > 257))

  000b0	85 f6		 test	 esi, esi
  000b2	75 25		 jne	 SHORT $L1824
  000b4	8b 44 24 24	 mov	 eax, DWORD PTR _bd$[esp+20]
  000b8	83 38 00	 cmp	 DWORD PTR [eax], 0
  000bb	75 08		 jne	 SHORT $L1823
  000bd	81 fb 01 01 00
	00		 cmp	 ebx, 257		; 00000101H
  000c3	77 47		 ja	 SHORT $L1920
$L1823:

; 375  : #endif
; 376  :   }
; 377  : 
; 378  :   /* done */
; 379  :   ZFREE(z, v);

  000c5	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  000c8	8b d7		 mov	 edx, edi
  000ca	ff 55 24	 call	 DWORD PTR [ebp+36]
  000cd	5e		 pop	 esi
  000ce	5f		 pop	 edi
  000cf	5d		 pop	 ebp

; 380  :   return Z_OK;

  000d0	33 c0		 xor	 eax, eax
  000d2	5b		 pop	 ebx

; 381  : }

  000d3	83 c4 08	 add	 esp, 8
  000d6	c2 1c 00	 ret	 28			; 0000001cH
$L1824:

; 357  :   {
; 358  :     if (r == Z_DATA_ERROR)

  000d9	83 fe fd	 cmp	 esi, -3			; fffffffdH
  000dc	75 1b		 jne	 SHORT $L1825
  000de	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  000e1	8b d7		 mov	 edx, edi

; 359  :       z->msg = (char*)"oversubscribed distance tree";

  000e3	c7 45 18 00 00
	00 00		 mov	 DWORD PTR [ebp+24], OFFSET FLAT:??_C@_0BN@KBLCDIAI@oversubscribed?5distance?5tree?$AA@
  000ea	ff 55 24	 call	 DWORD PTR [ebp+36]
  000ed	8b c6		 mov	 eax, esi
  000ef	5e		 pop	 esi
  000f0	5f		 pop	 edi
  000f1	5d		 pop	 ebp
  000f2	5b		 pop	 ebx

; 381  : }

  000f3	83 c4 08	 add	 esp, 8
  000f6	c2 1c 00	 ret	 28			; 0000001cH
$L1825:

; 360  :     else if (r == Z_BUF_ERROR) {

  000f9	83 fe fb	 cmp	 esi, -5			; fffffffbH
  000fc	75 09		 jne	 SHORT $L1829

; 361  : #ifdef PKZIP_BUG_WORKAROUND
; 362  :       r = Z_OK;
; 363  :     }
; 364  : #else
; 365  :       z->msg = (char*)"incomplete distance tree";

  000fe	c7 45 18 00 00
	00 00		 mov	 DWORD PTR [ebp+24], OFFSET FLAT:??_C@_0BJ@CBCPDPJF@incomplete?5distance?5tree?$AA@

; 366  :       r = Z_DATA_ERROR;
; 367  :     }
; 368  :     else if (r != Z_MEM_ERROR)

  00105	eb 3a		 jmp	 SHORT $L1922
$L1829:
  00107	83 fe fc	 cmp	 esi, -4			; fffffffcH
  0010a	74 3a		 je	 SHORT $L1819
$L1920:

; 369  :     {
; 370  :       z->msg = (char*)"empty distance tree with lengths";

  0010c	c7 45 18 00 00
	00 00		 mov	 DWORD PTR [ebp+24], OFFSET FLAT:??_C@_0CB@KPKKKLFO@empty?5distance?5tree?5with?5lengths@

; 371  :       r = Z_DATA_ERROR;
; 372  :     }
; 373  :     ZFREE(z, v);
; 374  :     return r;

  00113	eb 2c		 jmp	 SHORT $L1922
$L1814:

; 342  :   {
; 343  :     if (r == Z_DATA_ERROR)

  00115	83 fe fd	 cmp	 esi, -3			; fffffffdH
  00118	75 1b		 jne	 SHORT $L1815

; 349  :     }
; 350  :     ZFREE(z, v);

  0011a	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  0011d	8b d7		 mov	 edx, edi
  0011f	c7 45 18 00 00
	00 00		 mov	 DWORD PTR [ebp+24], OFFSET FLAT:??_C@_0CD@GJIDGCKE@oversubscribed?5literal?1length?5tr@
  00126	ff 55 24	 call	 DWORD PTR [ebp+36]

; 351  :     return r;

  00129	8b c6		 mov	 eax, esi
  0012b	5e		 pop	 esi
  0012c	5f		 pop	 edi
  0012d	5d		 pop	 ebp
  0012e	5b		 pop	 ebx

; 381  : }

  0012f	83 c4 08	 add	 esp, 8
  00132	c2 1c 00	 ret	 28			; 0000001cH
$L1815:

; 344  :       z->msg = (char*)"oversubscribed literal/length tree";
; 345  :     else if (r != Z_MEM_ERROR)

  00135	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00138	74 0c		 je	 SHORT $L1819
$L1919:

; 346  :     {
; 347  :       z->msg = (char*)"incomplete literal/length tree";

  0013a	c7 45 18 00 00
	00 00		 mov	 DWORD PTR [ebp+24], OFFSET FLAT:??_C@_0BP@NEEEJJNA@incomplete?5literal?1length?5tree?$AA@
$L1922:

; 348  :       r = Z_DATA_ERROR;

  00141	be fd ff ff ff	 mov	 esi, -3			; fffffffdH
$L1819:

; 349  :     }
; 350  :     ZFREE(z, v);

  00146	8b 4d 28	 mov	 ecx, DWORD PTR [ebp+40]
  00149	8b d7		 mov	 edx, edi
  0014b	ff 55 24	 call	 DWORD PTR [ebp+36]

; 351  :     return r;

  0014e	8b c6		 mov	 eax, esi
  00150	5e		 pop	 esi
  00151	5f		 pop	 edi
  00152	5d		 pop	 ebp
  00153	5b		 pop	 ebx

; 381  : }

  00154	83 c4 08	 add	 esp, 8
  00157	c2 1c 00	 ret	 28			; 0000001cH
@inflate_trees_dynamic@36 ENDP
_TEXT	ENDS
PUBLIC	@inflate_trees_fixed@20
; Function compile flags: /Ogty
;	COMDAT @inflate_trees_fixed@20
_TEXT	SEGMENT
_tl$ = 8						; size = 4
_td$ = 12						; size = 4
_z$ = 16						; size = 4
@inflate_trees_fixed@20 PROC NEAR			; COMDAT
; _bl$ = ecx
; _bd$ = edx

; 405  : #ifdef BUILDFIXED
; 406  :   /* build fixed tables if not already */
; 407  :   if (!fixed_built)
; 408  :   {
; 409  :     int k;              /* temporary variable */
; 410  :     uInt f = 0;         /* number of hufts used in fixed_mem */
; 411  :     uIntf *c;           /* length list for huft_build */
; 412  :     uIntf *v;           /* work area for huft_build */
; 413  : 
; 414  :     /* allocate memory */
; 415  :     if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
; 416  :       return Z_MEM_ERROR;
; 417  :     if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
; 418  :     {
; 419  :       ZFREE(z, c);
; 420  :       return Z_MEM_ERROR;
; 421  :     }
; 422  : 
; 423  :     /* literal table */
; 424  :     for (k = 0; k < 144; k++)
; 425  :       c[k] = 8;
; 426  :     for (; k < 256; k++)
; 427  :       c[k] = 9;
; 428  :     for (; k < 280; k++)
; 429  :       c[k] = 7;
; 430  :     for (; k < 288; k++)
; 431  :       c[k] = 8;
; 432  :     fixed_bl = 9;
; 433  :     huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,
; 434  :                fixed_mem, &f, v);
; 435  : 
; 436  :     /* distance table */
; 437  :     for (k = 0; k < 30; k++)
; 438  :       c[k] = 5;
; 439  :     fixed_bd = 5;
; 440  :     huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,
; 441  :                fixed_mem, &f, v);
; 442  : 
; 443  :     /* done */
; 444  :     ZFREE(z, v);
; 445  :     ZFREE(z, c);
; 446  :     fixed_built = 1;
; 447  :   }
; 448  : #endif
; 449  :   *bl = fixed_bl;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _fixed_bl
  00005	89 01		 mov	 DWORD PTR [ecx], eax

; 450  :   *bd = fixed_bd;

  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fixed_bd

; 451  :   *tl = fixed_tl;
; 452  :   *td = fixed_td;

  0000d	8b 44 24 08	 mov	 eax, DWORD PTR _td$[esp-4]
  00011	89 0a		 mov	 DWORD PTR [edx], ecx
  00013	8b 54 24 04	 mov	 edx, DWORD PTR _tl$[esp-4]
  00017	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET FLAT:_fixed_tl
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_fixed_td

; 453  :   return Z_OK;

  00023	33 c0		 xor	 eax, eax

; 454  : }

  00025	c2 0c 00	 ret	 12			; 0000000cH
@inflate_trees_fixed@20 ENDP
_TEXT	ENDS
END
