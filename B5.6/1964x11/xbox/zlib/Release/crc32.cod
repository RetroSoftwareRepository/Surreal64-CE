; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\crc32.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT @make_crc_table@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @get_crc_table@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @crc32@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_crc_table_empty DD 01H
_DATA	ENDS
CONST	SEGMENT
?p@?1??make_crc_table@@9@9 DB 00H			; `make_crc_table'::`2'::p
	DB	01H
	DB	02H
	DB	04H
	DB	05H
	DB	07H
	DB	08H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	010H
	DB	016H
	DB	017H
	DB	01aH
CONST	ENDS
_BSS	SEGMENT
_crc_table DD	0100H DUP (?)
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\crc32.c
_BSS	ENDS
;	COMDAT @make_crc_table@0
_TEXT	SEGMENT
@make_crc_table@0 PROC NEAR				; COMDAT

; 43   : {

  00000	56		 push	 esi
  00001	53		 push	 ebx

; 44   :   uLong c;
; 45   :   int n, k;
; 46   :   uLong poly;            /* polynomial exclusive-or pattern */
; 47   :   /* terms of polynomial defining this crc (except x^32): */
; 48   :   static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
; 49   : 
; 50   :   /* make exclusive-or pattern from polynomial (0xedb88320L) */
; 51   :   poly = 0L;

  00002	33 f6		 xor	 esi, esi

; 52   :   for (n = 0; n < sizeof(p)/sizeof(Byte); n++)

  00004	33 c0		 xor	 eax, eax
  00006	57		 push	 edi
  00007	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$L874:

; 53   :     poly |= 1L << (31 - p[n]);

  00010	33 d2		 xor	 edx, edx
  00012	8a 90 01 00 00
	00		 mov	 dl, BYTE PTR ?p@?1??make_crc_table@@9@9[eax+1]
  00018	33 db		 xor	 ebx, ebx
  0001a	8a 98 00 00 00
	00		 mov	 bl, BYTE PTR ?p@?1??make_crc_table@@9@9[eax]
  00020	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00025	bf 01 00 00 00	 mov	 edi, 1
  0002a	83 c0 02	 add	 eax, 2
  0002d	2b ca		 sub	 ecx, edx
  0002f	ba 01 00 00 00	 mov	 edx, 1
  00034	d3 e2		 shl	 edx, cl
  00036	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0003b	2b cb		 sub	 ecx, ebx
  0003d	d3 e7		 shl	 edi, cl
  0003f	0b d7		 or	 edx, edi
  00041	0b f2		 or	 esi, edx
  00043	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00046	72 c8		 jb	 SHORT $L874
  00048	5f		 pop	 edi

; 54   :  
; 55   :   for (n = 0; n < 256; n++)

  00049	33 c9		 xor	 ecx, ecx
  0004b	5b		 pop	 ebx
  0004c	8d 64 24 00	 npad	 4
$L877:

; 56   :   {
; 57   :     c = (uLong)n;
; 58   :     for (k = 0; k < 8; k++)
; 59   :       c = c & 1 ? poly ^ (c >> 1) : c >> 1;

  00050	8b c1		 mov	 eax, ecx
  00052	d1 e8		 shr	 eax, 1
  00054	f6 c1 01	 test	 cl, 1
  00057	74 02		 je	 SHORT $L924
  00059	33 c6		 xor	 eax, esi
$L924:
  0005b	a8 01		 test	 al, 1
  0005d	74 06		 je	 SHORT $L934
  0005f	d1 e8		 shr	 eax, 1
  00061	33 c6		 xor	 eax, esi
  00063	eb 02		 jmp	 SHORT $L935
$L934:
  00065	d1 e8		 shr	 eax, 1
$L935:
  00067	a8 01		 test	 al, 1
  00069	74 06		 je	 SHORT $L937
  0006b	d1 e8		 shr	 eax, 1
  0006d	33 c6		 xor	 eax, esi
  0006f	eb 02		 jmp	 SHORT $L938
$L937:
  00071	d1 e8		 shr	 eax, 1
$L938:
  00073	a8 01		 test	 al, 1
  00075	74 06		 je	 SHORT $L940
  00077	d1 e8		 shr	 eax, 1
  00079	33 c6		 xor	 eax, esi
  0007b	eb 02		 jmp	 SHORT $L941
$L940:
  0007d	d1 e8		 shr	 eax, 1
$L941:
  0007f	a8 01		 test	 al, 1
  00081	74 06		 je	 SHORT $L943
  00083	d1 e8		 shr	 eax, 1
  00085	33 c6		 xor	 eax, esi
  00087	eb 02		 jmp	 SHORT $L944
$L943:
  00089	d1 e8		 shr	 eax, 1
$L944:
  0008b	a8 01		 test	 al, 1
  0008d	74 06		 je	 SHORT $L946
  0008f	d1 e8		 shr	 eax, 1
  00091	33 c6		 xor	 eax, esi
  00093	eb 02		 jmp	 SHORT $L947
$L946:
  00095	d1 e8		 shr	 eax, 1
$L947:
  00097	a8 01		 test	 al, 1
  00099	74 06		 je	 SHORT $L949
  0009b	d1 e8		 shr	 eax, 1
  0009d	33 c6		 xor	 eax, esi
  0009f	eb 02		 jmp	 SHORT $L950
$L949:
  000a1	d1 e8		 shr	 eax, 1
$L950:
  000a3	a8 01		 test	 al, 1
  000a5	74 06		 je	 SHORT $L952
  000a7	d1 e8		 shr	 eax, 1
  000a9	33 c6		 xor	 eax, esi
  000ab	eb 02		 jmp	 SHORT $L953
$L952:
  000ad	d1 e8		 shr	 eax, 1
$L953:

; 60   :     crc_table[n] = c;

  000af	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _crc_table[ecx*4], eax
  000b6	41		 inc	 ecx
  000b7	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  000bd	7c 91		 jl	 SHORT $L877

; 61   :   }
; 62   :   crc_table_empty = 0;

  000bf	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _crc_table_empty, 0
  000c9	5e		 pop	 esi

; 63   : }

  000ca	c3		 ret	 0
@make_crc_table@0 ENDP
_TEXT	ENDS
PUBLIC	@get_crc_table@0
; Function compile flags: /Ogty
;	COMDAT @get_crc_table@0
_TEXT	SEGMENT
@get_crc_table@0 PROC NEAR				; COMDAT

; 129  : #ifdef DYNAMIC_CRC_TABLE
; 130  :   if (crc_table_empty) make_crc_table();

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _crc_table_empty
  00005	85 c0		 test	 eax, eax
  00007	74 05		 je	 SHORT $L956
  00009	e8 00 00 00 00	 call	 @make_crc_table@0
$L956:

; 131  : #endif
; 132  :   return (const uLongf *)crc_table;

  0000e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_crc_table

; 133  : }

  00013	c3		 ret	 0
@get_crc_table@0 ENDP
_TEXT	ENDS
PUBLIC	@crc32@12
; Function compile flags: /Ogty
;	COMDAT @crc32@12
_TEXT	SEGMENT
_len$ = 8						; size = 4
@crc32@12 PROC NEAR					; COMDAT
; _crc$ = ecx
; _buf$ = edx

; 146  : {

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx

; 147  :     if (buf == Z_NULL) return 0L;

  00003	85 f6		 test	 esi, esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx
  00008	75 07		 jne	 SHORT $L896
  0000a	5f		 pop	 edi
  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 162  : }

  0000e	c2 04 00	 ret	 4
$L896:

; 148  : #ifdef DYNAMIC_CRC_TABLE
; 149  :     if (crc_table_empty)

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR _crc_table_empty
  00016	85 c0		 test	 eax, eax
  00018	74 05		 je	 SHORT $L897

; 150  :       make_crc_table();

  0001a	e8 00 00 00 00	 call	 @make_crc_table@0
$L897:

; 151  : #endif
; 152  :     crc = crc ^ 0xffffffffL;
; 153  :     while (len >= 8)

  0001f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _len$[esp+4]
  00023	83 f9 08	 cmp	 ecx, 8
  00026	f7 d7		 not	 edi
  00028	53		 push	 ebx
  00029	8b c7		 mov	 eax, edi
  0002b	0f 82 de 00 00
	00		 jb	 $L900
  00031	8b f9		 mov	 edi, ecx
  00033	c1 ef 03	 shr	 edi, 3
$L899:

; 154  :     {
; 155  :       DO8(buf);

  00036	33 d2		 xor	 edx, edx
  00038	8a 16		 mov	 dl, BYTE PTR [esi]

; 156  :       len -= 8;

  0003a	83 e9 08	 sub	 ecx, 8
  0003d	33 d0		 xor	 edx, eax
  0003f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00045	8b 1c 95 00 00
	00 00		 mov	 ebx, DWORD PTR _crc_table[edx*4]
  0004c	33 d2		 xor	 edx, edx
  0004e	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  00051	c1 e8 08	 shr	 eax, 8
  00054	33 c3		 xor	 eax, ebx
  00056	46		 inc	 esi
  00057	33 d0		 xor	 edx, eax
  00059	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0005f	8b 1c 95 00 00
	00 00		 mov	 ebx, DWORD PTR _crc_table[edx*4]
  00066	33 d2		 xor	 edx, edx
  00068	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  0006b	c1 e8 08	 shr	 eax, 8
  0006e	33 c3		 xor	 eax, ebx
  00070	46		 inc	 esi
  00071	33 d0		 xor	 edx, eax
  00073	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00079	8b 1c 95 00 00
	00 00		 mov	 ebx, DWORD PTR _crc_table[edx*4]
  00080	33 d2		 xor	 edx, edx
  00082	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  00085	c1 e8 08	 shr	 eax, 8
  00088	33 c3		 xor	 eax, ebx
  0008a	46		 inc	 esi
  0008b	33 d0		 xor	 edx, eax
  0008d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00093	8b 1c 95 00 00
	00 00		 mov	 ebx, DWORD PTR _crc_table[edx*4]
  0009a	33 d2		 xor	 edx, edx
  0009c	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  0009f	c1 e8 08	 shr	 eax, 8
  000a2	33 c3		 xor	 eax, ebx
  000a4	46		 inc	 esi
  000a5	33 d0		 xor	 edx, eax
  000a7	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000ad	8b 1c 95 00 00
	00 00		 mov	 ebx, DWORD PTR _crc_table[edx*4]
  000b4	c1 e8 08	 shr	 eax, 8
  000b7	33 c3		 xor	 eax, ebx
  000b9	33 d2		 xor	 edx, edx
  000bb	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  000be	46		 inc	 esi
  000bf	33 d0		 xor	 edx, eax
  000c1	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000c7	8b 1c 95 00 00
	00 00		 mov	 ebx, DWORD PTR _crc_table[edx*4]
  000ce	c1 e8 08	 shr	 eax, 8
  000d1	33 c3		 xor	 eax, ebx
  000d3	33 d2		 xor	 edx, edx
  000d5	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  000d8	46		 inc	 esi
  000d9	33 d0		 xor	 edx, eax
  000db	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000e1	8b 1c 95 00 00
	00 00		 mov	 ebx, DWORD PTR _crc_table[edx*4]
  000e8	c1 e8 08	 shr	 eax, 8
  000eb	33 c3		 xor	 eax, ebx
  000ed	33 d2		 xor	 edx, edx
  000ef	8a 56 01	 mov	 dl, BYTE PTR [esi+1]
  000f2	46		 inc	 esi
  000f3	33 d0		 xor	 edx, eax
  000f5	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000fb	8b 1c 95 00 00
	00 00		 mov	 ebx, DWORD PTR _crc_table[edx*4]
  00102	c1 e8 08	 shr	 eax, 8
  00105	33 c3		 xor	 eax, ebx
  00107	46		 inc	 esi
  00108	4f		 dec	 edi
  00109	0f 85 27 ff ff
	ff		 jne	 $L899
$L900:

; 157  :     }
; 158  :     if (len) do {

  0010f	85 c9		 test	 ecx, ecx
  00111	74 1c		 je	 SHORT $L912
$L910:

; 159  :       DO1(buf);

  00113	33 d2		 xor	 edx, edx
  00115	8a 16		 mov	 dl, BYTE PTR [esi]
  00117	33 d0		 xor	 edx, eax
  00119	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0011f	8b 1c 95 00 00
	00 00		 mov	 ebx, DWORD PTR _crc_table[edx*4]
  00126	c1 e8 08	 shr	 eax, 8
  00129	33 c3		 xor	 eax, ebx
  0012b	46		 inc	 esi

; 160  :     } while (--len);

  0012c	49		 dec	 ecx
  0012d	75 e4		 jne	 SHORT $L910
$L912:
  0012f	5b		 pop	 ebx
  00130	5f		 pop	 edi

; 161  :     return crc ^ 0xffffffffL;

  00131	f7 d0		 not	 eax
  00133	5e		 pop	 esi

; 162  : }

  00134	c2 04 00	 ret	 4
@crc32@12 ENDP
_TEXT	ENDS
END
