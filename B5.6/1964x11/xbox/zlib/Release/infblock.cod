; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\infblock.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT @inflate_blocks_reset@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate_blocks_new@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate_blocks@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate_blocks_free@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate_set_dictionary@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @inflate_blocks_sync_point@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_border	DD	010H
	DD	011H
	DD	012H
	DD	00H
	DD	08H
	DD	07H
	DD	09H
	DD	06H
	DD	0aH
	DD	05H
	DD	0bH
	DD	04H
	DD	0cH
	DD	03H
	DD	0dH
	DD	02H
	DD	0eH
	DD	01H
	DD	0fH
CONST	ENDS
PUBLIC	@inflate_blocks_reset@12
EXTRN	@inflate_codes_free@8:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\infblock.c
;	COMDAT @inflate_blocks_reset@12
_TEXT	SEGMENT
_c$ = 8							; size = 4
@inflate_blocks_reset@12 PROC NEAR			; COMDAT
; _s$ = ecx
; _z$ = edx

; 73   :   if (c != Z_NULL)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _c$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	8b f1		 mov	 esi, ecx
  0000c	74 05		 je	 SHORT $L1766

; 74   :     *c = s->check;

  0000e	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
$L1766:

; 75   :   if (s->mode == BTREE || s->mode == DTREE)

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	83 f8 04	 cmp	 eax, 4
  00018	74 05		 je	 SHORT $L1768
  0001a	83 f8 05	 cmp	 eax, 5
  0001d	75 09		 jne	 SHORT $L1767
$L1768:

; 76   :     ZFREE(z, s->sub.trees.blens);

  0001f	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00022	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00025	ff 57 24	 call	 DWORD PTR [edi+36]
$L1767:

; 77   :   if (s->mode == CODES)

  00028	83 3e 06	 cmp	 DWORD PTR [esi], 6
  0002b	75 0a		 jne	 SHORT $L1770

; 78   :     inflate_codes_free(s->sub.decode.codes, z);

  0002d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00030	8b d7		 mov	 edx, edi
  00032	e8 00 00 00 00	 call	 @inflate_codes_free@8
$L1770:

; 79   :   s->mode = TYPE;
; 80   :   s->bitk = 0;
; 81   :   s->bitb = 0;
; 82   :   s->read = s->write = s->window;

  00037	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0003a	89 46 34	 mov	 DWORD PTR [esi+52], eax
  0003d	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 83   :   if (s->checkfn != Z_NULL)

  00040	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00043	85 c0		 test	 eax, eax
  00045	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0004b	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00052	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
  00059	74 0e		 je	 SHORT $L1771

; 84   :     z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);

  0005b	6a 00		 push	 0
  0005d	33 d2		 xor	 edx, edx
  0005f	33 c9		 xor	 ecx, ecx
  00061	ff d0		 call	 eax
  00063	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00066	89 47 30	 mov	 DWORD PTR [edi+48], eax
$L1771:
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi

; 85   :   Tracev((stderr, "inflate:   blocks reset\n"));
; 86   : }

  0006b	c2 04 00	 ret	 4
@inflate_blocks_reset@12 ENDP
_TEXT	ENDS
PUBLIC	@inflate_blocks_new@12
; Function compile flags: /Ogty
;	COMDAT @inflate_blocks_new@12
_TEXT	SEGMENT
_w$ = 8							; size = 4
@inflate_blocks_new@12 PROC NEAR			; COMDAT
; _z$ = ecx
; _c$ = edx

; 93   : {

  00000	55		 push	 ebp
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 94   :   inflate_blocks_statef *s;
; 95   : 
; 96   :   if ((s = (inflate_blocks_statef *)ZALLOC
; 97   :        (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)

  00005	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00008	8b ea		 mov	 ebp, edx
  0000a	6a 40		 push	 64			; 00000040H
  0000c	ba 01 00 00 00	 mov	 edx, 1
  00011	ff 57 20	 call	 DWORD PTR [edi+32]
  00014	8b f0		 mov	 esi, eax
  00016	85 f6		 test	 esi, esi

; 98   :     return s;

  00018	74 1f		 je	 SHORT $L1984

; 99   :   if ((s->hufts =
; 100  :        (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)

  0001a	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  0001d	68 a0 05 00 00	 push	 1440			; 000005a0H
  00022	ba 08 00 00 00	 mov	 edx, 8
  00027	ff 57 20	 call	 DWORD PTR [edi+32]
  0002a	85 c0		 test	 eax, eax
  0002c	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 101  :   {
; 102  :     ZFREE(z, s);

  0002f	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00032	75 0d		 jne	 SHORT $L1784
  00034	8b d6		 mov	 edx, esi
  00036	ff 57 24	 call	 DWORD PTR [edi+36]
$L1984:
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi

; 103  :     return Z_NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	5d		 pop	 ebp

; 117  : }

  0003e	c2 04 00	 ret	 4
$L1784:
  00041	53		 push	 ebx

; 104  :   }
; 105  :   if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)

  00042	8b 5c 24 14	 mov	 ebx, DWORD PTR _w$[esp+12]
  00046	53		 push	 ebx
  00047	ba 01 00 00 00	 mov	 edx, 1
  0004c	ff 57 20	 call	 DWORD PTR [edi+32]
  0004f	85 c0		 test	 eax, eax
  00051	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00054	75 1a		 jne	 SHORT $L1787

; 106  :   {
; 107  :     ZFREE(z, s->hufts);

  00056	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00059	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  0005c	ff 57 24	 call	 DWORD PTR [edi+36]

; 108  :     ZFREE(z, s);

  0005f	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00062	8b d6		 mov	 edx, esi
  00064	ff 57 24	 call	 DWORD PTR [edi+36]
  00067	5b		 pop	 ebx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi

; 109  :     return Z_NULL;

  0006a	33 c0		 xor	 eax, eax
  0006c	5d		 pop	 ebp

; 117  : }

  0006d	c2 04 00	 ret	 4
$L1787:

; 110  :   }
; 111  :   s->end = s->window + w;

  00070	03 c3		 add	 eax, ebx

; 112  :   s->checkfn = c;
; 113  :   s->mode = TYPE;
; 114  :   Tracev((stderr, "inflate:   blocks allocated\n"));
; 115  :   inflate_blocks_reset(s, z, Z_NULL);

  00072	6a 00		 push	 0
  00074	8b d7		 mov	 edx, edi
  00076	8b ce		 mov	 ecx, esi
  00078	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0007b	89 6e 38	 mov	 DWORD PTR [esi+56], ebp
  0007e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00084	e8 00 00 00 00	 call	 @inflate_blocks_reset@12
  00089	5b		 pop	 ebx
  0008a	5f		 pop	 edi

; 116  :   return s;

  0008b	8b c6		 mov	 eax, esi
  0008d	5e		 pop	 esi
  0008e	5d		 pop	 ebp

; 117  : }

  0008f	c2 04 00	 ret	 4
@inflate_blocks_new@12 ENDP
_TEXT	ENDS
PUBLIC	@inflate_blocks@12
PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
EXTRN	@inflate_trees_bits@20:NEAR
EXTRN	@inflate_trees_dynamic@36:NEAR
EXTRN	@inflate_trees_fixed@20:NEAR
EXTRN	@inflate_codes_new@20:NEAR
EXTRN	@inflate_codes@12:NEAR
EXTRN	_inflate_mask:BYTE
EXTRN	@inflate_flush@12:NEAR
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @inflate_blocks@12
_TEXT	SEGMENT
_b$ = -60						; size = 4
_n$ = -56						; size = 4
_q$ = -52						; size = 4
_t$ = -48						; size = 4
_m$ = -48						; size = 4
_bl$1925 = -44						; size = 4
_j$1899 = -44						; size = 4
_p$ = -44						; size = 4
tv1040 = -40						; size = 4
_bd$1926 = -40						; size = 4
_i$1898 = -40						; size = 4
_z$ = -36						; size = 4
_td$1828 = -32						; size = 4
_tl$1827 = -28						; size = 4
_bd$1826 = -24						; size = 4
_bl$1825 = -20						; size = 4
tv1046 = -16						; size = 4
$T2035 = -16						; size = 4
_c$1900 = -12						; size = 4
_td$1928 = -8						; size = 4
_tl$1927 = -4						; size = 4
_r$ = 8							; size = 4
@inflate_blocks@12 PROC NEAR				; COMDAT
; _s$ = ecx
; _z$ = edx

; 124  : {

  00000	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	8b d9		 mov	 ebx, ecx

; 125  :   uInt t;               /* temporary storage */
; 126  :   uLong b;              /* bit buffer */
; 127  :   uInt k;               /* bits in bit buffer */
; 128  :   Bytef *p;             /* input data pointer */
; 129  :   uInt n;               /* bytes available there */
; 130  :   Bytef *q;             /* output window write pointer */
; 131  :   uInt m;               /* bytes to end of window or read pointer */
; 132  : 
; 133  :   /* copy input/output information to locals (UPDATE macro restores) */
; 134  :   LOAD

  00007	8b 4b 20	 mov	 ecx, DWORD PTR [ebx+32]
  0000a	8b 6b 1c	 mov	 ebp, DWORD PTR [ebx+28]
  0000d	56		 push	 esi
  0000e	8b f2		 mov	 esi, edx
  00010	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00013	89 44 24 10	 mov	 DWORD PTR _n$[esp+72], eax
  00017	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  0001a	89 4c 24 0c	 mov	 DWORD PTR _b$[esp+72], ecx
  0001e	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  00021	3b c1		 cmp	 eax, ecx
  00023	57		 push	 edi
  00024	8b 3e		 mov	 edi, DWORD PTR [esi]
  00026	89 74 24 28	 mov	 DWORD PTR _z$[esp+76], esi
  0002a	89 7c 24 20	 mov	 DWORD PTR _p$[esp+76], edi
  0002e	89 44 24 18	 mov	 DWORD PTR _q$[esp+76], eax
  00032	73 05		 jae	 SHORT $L1987
  00034	2b c8		 sub	 ecx, eax
  00036	49		 dec	 ecx
  00037	eb 05		 jmp	 SHORT $L2056
$L1987:
  00039	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  0003c	2b c8		 sub	 ecx, eax
$L2056:

; 135  : 
; 136  :   /* process input based on current state */
; 137  :   while (1) switch (s->mode)

  0003e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00040	83 fa 09	 cmp	 edx, 9
  00043	89 4c 24 1c	 mov	 DWORD PTR _m$[esp+76], ecx
  00047	76 41		 jbe	 SHORT $L2057
$L1947:

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  00049	6a fe		 push	 -2			; fffffffeH
$L2063:
  0004b	8b 54 24 14	 mov	 edx, DWORD PTR _b$[esp+80]
  0004f	8b 44 24 18	 mov	 eax, DWORD PTR _n$[esp+80]
  00053	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  00056	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  00059	89 46 04	 mov	 DWORD PTR [esi+4], eax
$L2061:
  0005c	8b 2e		 mov	 ebp, DWORD PTR [esi]
  0005e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00061	8b cf		 mov	 ecx, edi
  00063	2b cd		 sub	 ecx, ebp
  00065	03 d1		 add	 edx, ecx
  00067	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006a	8b 54 24 1c	 mov	 edx, DWORD PTR _q$[esp+80]
  0006e	89 3e		 mov	 DWORD PTR [esi], edi
  00070	89 53 34	 mov	 DWORD PTR [ebx+52], edx
  00073	8b d6		 mov	 edx, esi
  00075	8b cb		 mov	 ecx, ebx
  00077	e8 00 00 00 00	 call	 @inflate_flush@12
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5d		 pop	 ebp
  0007f	5b		 pop	 ebx

; 368  :   }
; 369  : }

  00080	83 c4 3c	 add	 esp, 60			; 0000003cH
  00083	c2 04 00	 ret	 4
$L2040:

; 135  : 
; 136  :   /* process input based on current state */
; 137  :   while (1) switch (s->mode)

  00086	8b 4c 24 1c	 mov	 ecx, DWORD PTR _m$[esp+76]
$L2057:
  0008a	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+76]
  0008e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L2067[edx*4]
$L2006:

; 138  :   {
; 139  :     case TYPE:
; 140  :       NEEDBITS(3)

  00095	83 fd 03	 cmp	 ebp, 3
  00098	73 3b		 jae	 SHORT $L2048
  0009a	8d 9b 00 00 00
	00		 npad	 6
$L1813:
  000a0	8b 4c 24 14	 mov	 ecx, DWORD PTR _n$[esp+76]
  000a4	85 c9		 test	 ecx, ecx
  000a6	0f 84 e8 06 00
	00		 je	 $L1815
  000ac	8b d1		 mov	 edx, ecx
  000ae	4a		 dec	 edx
  000af	89 54 24 14	 mov	 DWORD PTR _n$[esp+76], edx
  000b3	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  000b6	8b cd		 mov	 ecx, ebp
  000b8	d3 e2		 shl	 edx, cl
  000ba	83 c5 08	 add	 ebp, 8
  000bd	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _r$[esp+72], 0
  000c5	0b c2		 or	 eax, edx
  000c7	47		 inc	 edi
  000c8	83 fd 03	 cmp	 ebp, 3
  000cb	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax
  000cf	89 7c 24 20	 mov	 DWORD PTR _p$[esp+76], edi
  000d3	72 cb		 jb	 SHORT $L1813
$L2048:

; 141  :       t = (uInt)b & 7;

  000d5	8b c8		 mov	 ecx, eax
  000d7	83 e1 07	 and	 ecx, 7

; 142  :       s->last = t & 1;

  000da	8b d1		 mov	 edx, ecx
  000dc	83 e2 01	 and	 edx, 1

; 143  :       switch (t >> 1)

  000df	d1 e9		 shr	 ecx, 1
  000e1	83 f9 03	 cmp	 ecx, 3
  000e4	89 53 18	 mov	 DWORD PTR [ebx+24], edx
  000e7	0f 87 8f 06 00
	00		 ja	 $L1808
  000ed	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L2068[ecx*4]
$L1823:

; 144  :       {
; 145  :         case 0:                         /* stored */
; 146  :           Tracev((stderr, "inflate:     stored block%s\n",
; 147  :                  s->last ? " (last)" : ""));
; 148  :           DUMPBITS(3)

  000f4	83 ed 03	 sub	 ebp, 3

; 149  :           t = k & 7;                    /* go to byte boundary */

  000f7	8b cd		 mov	 ecx, ebp
  000f9	83 e1 07	 and	 ecx, 7
  000fc	c1 e8 03	 shr	 eax, 3

; 150  :           DUMPBITS(t)

  000ff	d3 e8		 shr	 eax, cl
  00101	2b e9		 sub	 ebp, ecx

; 151  :           s->mode = LENS;               /* get length of stored block */

  00103	c7 03 01 00 00
	00		 mov	 DWORD PTR [ebx], 1
  00109	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax

; 152  :           break;

  0010d	e9 6a 06 00 00	 jmp	 $L1808
$L1824:

; 153  :         case 1:                         /* fixed */
; 154  :           Tracev((stderr, "inflate:     fixed codes block%s\n",
; 155  :                  s->last ? " (last)" : ""));
; 156  :           {
; 157  :             uInt bl, bd;
; 158  :             inflate_huft *tl, *td;
; 159  : 
; 160  :             inflate_trees_fixed(&bl, &bd, &tl, &td, z);

  00112	56		 push	 esi
  00113	8d 44 24 30	 lea	 eax, DWORD PTR _td$1828[esp+80]
  00117	50		 push	 eax
  00118	8d 4c 24 38	 lea	 ecx, DWORD PTR _tl$1827[esp+84]
  0011c	51		 push	 ecx
  0011d	8d 54 24 40	 lea	 edx, DWORD PTR _bd$1826[esp+88]
  00121	8d 4c 24 44	 lea	 ecx, DWORD PTR _bl$1825[esp+88]
  00125	e8 00 00 00 00	 call	 @inflate_trees_fixed@20

; 161  :             s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);

  0012a	8b 54 24 2c	 mov	 edx, DWORD PTR _td$1828[esp+76]
  0012e	8b 44 24 30	 mov	 eax, DWORD PTR _tl$1827[esp+76]
  00132	8b 4c 24 38	 mov	 ecx, DWORD PTR _bl$1825[esp+76]
  00136	56		 push	 esi
  00137	52		 push	 edx
  00138	8b 54 24 3c	 mov	 edx, DWORD PTR _bd$1826[esp+84]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 @inflate_codes_new@20

; 162  :             if (s->sub.decode.codes == Z_NULL)

  00142	85 c0		 test	 eax, eax
  00144	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00147	0f 84 62 06 00
	00		 je	 $L2017

; 166  :             }
; 167  :           }
; 168  :           DUMPBITS(3)

  0014d	c1 6c 24 10 03	 shr	 DWORD PTR _b$[esp+76], 3
  00152	83 ed 03	 sub	 ebp, 3

; 169  :           s->mode = CODES;

  00155	c7 03 06 00 00
	00		 mov	 DWORD PTR [ebx], 6

; 170  :           break;

  0015b	e9 1c 06 00 00	 jmp	 $L1808
$L1830:

; 171  :         case 2:                         /* dynamic */
; 172  :           Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 173  :                  s->last ? " (last)" : ""));
; 174  :           DUMPBITS(3)

  00160	c1 e8 03	 shr	 eax, 3
  00163	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax
  00167	83 ed 03	 sub	 ebp, 3

; 175  :           s->mode = TABLE;

  0016a	c7 03 03 00 00
	00		 mov	 DWORD PTR [ebx], 3

; 183  :       }
; 184  :       break;

  00170	e9 07 06 00 00	 jmp	 $L1808
$L2007:

; 185  :     case LENS:
; 186  :       NEEDBITS(32)

  00175	83 fd 20	 cmp	 ebp, 32			; 00000020H
  00178	73 3b		 jae	 SHORT $L2049
  0017a	8d 9b 00 00 00
	00		 npad	 6
$L1836:
  00180	8b 4c 24 14	 mov	 ecx, DWORD PTR _n$[esp+76]
  00184	85 c9		 test	 ecx, ecx
  00186	0f 84 88 07 00
	00		 je	 $L1913
  0018c	8b d1		 mov	 edx, ecx
  0018e	4a		 dec	 edx
  0018f	89 54 24 14	 mov	 DWORD PTR _n$[esp+76], edx
  00193	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00196	8b cd		 mov	 ecx, ebp
  00198	d3 e2		 shl	 edx, cl
  0019a	83 c5 08	 add	 ebp, 8
  0019d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _r$[esp+72], 0
  001a5	0b c2		 or	 eax, edx
  001a7	47		 inc	 edi
  001a8	83 fd 20	 cmp	 ebp, 32			; 00000020H
  001ab	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax
  001af	89 7c 24 20	 mov	 DWORD PTR _p$[esp+76], edi
  001b3	72 cb		 jb	 SHORT $L1836
$L2049:

; 187  :       if ((((~b) >> 16) & 0xffff) != (b & 0xffff))

  001b5	8b c8		 mov	 ecx, eax
  001b7	f7 d0		 not	 eax
  001b9	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  001bf	c1 e8 10	 shr	 eax, 16			; 00000010H
  001c2	3b c1		 cmp	 eax, ecx
  001c4	0f 85 72 06 00
	00		 jne	 $L2018

; 193  :       }
; 194  :       s->sub.left = (uInt)b & 0xffff;
; 195  :       b = k = 0;                      /* dump bits */

  001ca	33 ed		 xor	 ebp, ebp

; 196  :       Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
; 197  :       s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);

  001cc	8b c1		 mov	 eax, ecx
  001ce	3b c5		 cmp	 eax, ebp
  001d0	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  001d3	89 6c 24 10	 mov	 DWORD PTR _b$[esp+76], ebp
  001d7	0f 84 2d 01 00
	00		 je	 $L1989
  001dd	b8 02 00 00 00	 mov	 eax, 2

; 210  :         break;
; 211  :       Tracev((stderr, "inflate:       stored end, %lu total out\n",
; 212  :               z->total_out + (q >= s->read ? q - s->read :
; 213  :               (s->end - s->read) + (q - s->window))));
; 214  :       s->mode = s->last ? DRY : TYPE;

  001e2	89 03		 mov	 DWORD PTR [ebx], eax

; 215  :       break;

  001e4	e9 93 05 00 00	 jmp	 $L1808
$L1845:

; 198  :       break;
; 199  :     case STORED:
; 200  :       if (n == 0)

  001e9	8b 44 24 14	 mov	 eax, DWORD PTR _n$[esp+76]
  001ed	85 c0		 test	 eax, eax
  001ef	0f 84 df 06 00
	00		 je	 $L1904

; 201  :         LEAVE
; 202  :       NEEDOUT

  001f5	85 c9		 test	 ecx, ecx
  001f7	0f 85 a4 00 00
	00		 jne	 $L2054
  001fd	8b 53 2c	 mov	 edx, DWORD PTR [ebx+44]
  00200	39 54 24 18	 cmp	 DWORD PTR _q$[esp+76], edx
  00204	75 23		 jne	 SHORT $L2037
  00206	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  00209	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0020c	3b c8		 cmp	 ecx, eax
  0020e	74 19		 je	 SHORT $L2037
  00210	89 4c 24 18	 mov	 DWORD PTR _q$[esp+76], ecx
  00214	73 07		 jae	 SHORT $L1991
  00216	2b c1		 sub	 eax, ecx
  00218	48		 dec	 eax
  00219	8b c8		 mov	 ecx, eax
  0021b	eb 04		 jmp	 SHORT $L2058
$L1991:
  0021d	2b d1		 sub	 edx, ecx
  0021f	8b ca		 mov	 ecx, edx
$L2058:
  00221	85 c9		 test	 ecx, ecx
  00223	89 4c 24 1c	 mov	 DWORD PTR _m$[esp+76], ecx
  00227	75 78		 jne	 SHORT $L2054
$L2037:
  00229	8b 4c 24 50	 mov	 ecx, DWORD PTR _r$[esp+72]
  0022d	8b 44 24 18	 mov	 eax, DWORD PTR _q$[esp+76]
  00231	51		 push	 ecx
  00232	8b d6		 mov	 edx, esi
  00234	8b cb		 mov	 ecx, ebx
  00236	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00239	e8 00 00 00 00	 call	 @inflate_flush@12
  0023e	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  00241	89 44 24 50	 mov	 DWORD PTR _r$[esp+72], eax
  00245	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00248	3b c1		 cmp	 eax, ecx
  0024a	89 44 24 18	 mov	 DWORD PTR _q$[esp+76], eax
  0024e	89 4c 24 24	 mov	 DWORD PTR tv1040[esp+76], ecx
  00252	73 05		 jae	 SHORT $L1993
  00254	2b c8		 sub	 ecx, eax
  00256	49		 dec	 ecx
  00257	eb 05		 jmp	 SHORT $L2059
$L1993:
  00259	8b 4b 2c	 mov	 ecx, DWORD PTR [ebx+44]
  0025c	2b c8		 sub	 ecx, eax
$L2059:
  0025e	8b 53 2c	 mov	 edx, DWORD PTR [ebx+44]
  00261	3b c2		 cmp	 eax, edx
  00263	89 4c 24 1c	 mov	 DWORD PTR _m$[esp+76], ecx
  00267	89 54 24 3c	 mov	 DWORD PTR tv1046[esp+76], edx
  0026b	75 2c		 jne	 SHORT $L1996
  0026d	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00270	8b 54 24 24	 mov	 edx, DWORD PTR tv1040[esp+76]
  00274	3b c2		 cmp	 eax, edx
  00276	74 1d		 je	 SHORT $L2050
  00278	89 44 24 18	 mov	 DWORD PTR _q$[esp+76], eax
  0027c	73 0b		 jae	 SHORT $L1995
  0027e	2b d0		 sub	 edx, eax
  00280	4a		 dec	 edx
  00281	8b ca		 mov	 ecx, edx
  00283	89 4c 24 1c	 mov	 DWORD PTR _m$[esp+76], ecx
  00287	eb 10		 jmp	 SHORT $L1996
$L1995:
  00289	8b 4c 24 3c	 mov	 ecx, DWORD PTR tv1046[esp+76]
  0028d	2b c8		 sub	 ecx, eax
  0028f	89 4c 24 1c	 mov	 DWORD PTR _m$[esp+76], ecx
  00293	eb 04		 jmp	 SHORT $L1996
$L2050:
  00295	8b 44 24 18	 mov	 eax, DWORD PTR _q$[esp+76]
$L1996:
  00299	85 c9		 test	 ecx, ecx
  0029b	0f 84 ad 05 00
	00		 je	 $L2020
$L2054:

; 203  :       t = s->sub.left;

  002a1	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 204  :       if (t > n) t = n;

  002a4	8b 54 24 14	 mov	 edx, DWORD PTR _n$[esp+76]
  002a8	3b c2		 cmp	 eax, edx
  002aa	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _r$[esp+72], 0
  002b2	76 02		 jbe	 SHORT $L1858
  002b4	8b c2		 mov	 eax, edx
$L1858:

; 205  :       if (t > m) t = m;

  002b6	3b c1		 cmp	 eax, ecx
  002b8	76 02		 jbe	 SHORT $L1859
  002ba	8b c1		 mov	 eax, ecx
$L1859:

; 206  :       zmemcpy(q, p, t);

  002bc	8b 74 24 20	 mov	 esi, DWORD PTR _p$[esp+76]
  002c0	8b 7c 24 18	 mov	 edi, DWORD PTR _q$[esp+76]
  002c4	8b c8		 mov	 ecx, eax
  002c6	8b d1		 mov	 edx, ecx
  002c8	c1 e9 02	 shr	 ecx, 2
  002cb	f3 a5		 rep movsd
  002cd	8b ca		 mov	 ecx, edx

; 207  :       p += t;  n -= t;
; 208  :       q += t;  m -= t;

  002cf	8b 54 24 1c	 mov	 edx, DWORD PTR _m$[esp+76]
  002d3	83 e1 03	 and	 ecx, 3
  002d6	f3 a4		 rep movsb
  002d8	8b 4c 24 20	 mov	 ecx, DWORD PTR _p$[esp+76]
  002dc	8b 7c 24 14	 mov	 edi, DWORD PTR _n$[esp+76]
  002e0	8b 74 24 18	 mov	 esi, DWORD PTR _q$[esp+76]
  002e4	03 c8		 add	 ecx, eax
  002e6	89 4c 24 20	 mov	 DWORD PTR _p$[esp+76], ecx

; 209  :       if ((s->sub.left -= t) != 0)

  002ea	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  002ed	2b f8		 sub	 edi, eax
  002ef	03 f0		 add	 esi, eax
  002f1	2b d0		 sub	 edx, eax
  002f3	2b c8		 sub	 ecx, eax
  002f5	89 7c 24 14	 mov	 DWORD PTR _n$[esp+76], edi
  002f9	89 74 24 18	 mov	 DWORD PTR _q$[esp+76], esi
  002fd	89 54 24 1c	 mov	 DWORD PTR _m$[esp+76], edx
  00301	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  00304	0f 85 72 04 00
	00		 jne	 $L1808
$L1989:

; 210  :         break;
; 211  :       Tracev((stderr, "inflate:       stored end, %lu total out\n",
; 212  :               z->total_out + (q >= s->read ? q - s->read :
; 213  :               (s->end - s->read) + (q - s->window))));
; 214  :       s->mode = s->last ? DRY : TYPE;

  0030a	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  0030d	f7 d8		 neg	 eax
  0030f	1b c0		 sbb	 eax, eax
  00311	83 e0 07	 and	 eax, 7
  00314	89 03		 mov	 DWORD PTR [ebx], eax

; 215  :       break;

  00316	e9 61 04 00 00	 jmp	 $L1808
$L2008:

; 216  :     case TABLE:
; 217  :       NEEDBITS(14)

  0031b	83 fd 0e	 cmp	 ebp, 14			; 0000000eH
  0031e	73 31		 jae	 SHORT $L2051
$L1863:
  00320	8b 4c 24 14	 mov	 ecx, DWORD PTR _n$[esp+76]
  00324	85 c9		 test	 ecx, ecx
  00326	0f 84 a8 05 00
	00		 je	 $L1904
  0032c	8b d1		 mov	 edx, ecx
  0032e	4a		 dec	 edx
  0032f	89 54 24 14	 mov	 DWORD PTR _n$[esp+76], edx
  00333	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00336	8b cd		 mov	 ecx, ebp
  00338	d3 e2		 shl	 edx, cl
  0033a	83 c5 08	 add	 ebp, 8
  0033d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _r$[esp+72], 0
  00345	0b c2		 or	 eax, edx
  00347	47		 inc	 edi
  00348	83 fd 0e	 cmp	 ebp, 14			; 0000000eH
  0034b	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax
  0034f	72 cf		 jb	 SHORT $L1863
$L2051:

; 218  :       s->sub.trees.table = t = (uInt)b & 0x3fff;

  00351	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH

; 219  : #ifndef PKZIP_BUG_WORKAROUND
; 220  :       if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)

  00356	8b c8		 mov	 ecx, eax
  00358	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0035b	83 f9 1d	 cmp	 ecx, 29			; 0000001dH
  0035e	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00361	0f 87 2a 05 00
	00		 ja	 $L1870
  00367	c1 e8 05	 shr	 eax, 5
  0036a	83 e0 1f	 and	 eax, 31			; 0000001fH
  0036d	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  00370	0f 87 1b 05 00
	00		 ja	 $L1870

; 226  :       }
; 227  : #endif
; 228  :       t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
; 229  :       if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)

  00376	8d 94 08 02 01
	00 00		 lea	 edx, DWORD PTR [eax+ecx+258]
  0037d	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00380	6a 04		 push	 4
  00382	ff 56 20	 call	 DWORD PTR [esi+32]
  00385	85 c0		 test	 eax, eax
  00387	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  0038a	0f 84 fa 04 00
	00		 je	 $L2022

; 233  :       }
; 234  :       DUMPBITS(14)

  00390	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+76]
  00394	c1 e9 0e	 shr	 ecx, 14			; 0000000eH
  00397	89 4c 24 10	 mov	 DWORD PTR _b$[esp+76], ecx
  0039b	83 ed 0e	 sub	 ebp, 14			; 0000000eH

; 235  :       s->sub.trees.index = 0;

  0039e	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 236  :       Tracev((stderr, "inflate:       table sizes ok\n"));
; 237  :       s->mode = BTREE;

  003a5	c7 03 04 00 00
	00		 mov	 DWORD PTR [ebx], 4
  003ab	8b c1		 mov	 eax, ecx
$L2052:

; 238  :     case BTREE:
; 239  :       while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))

  003ad	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  003b0	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  003b3	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  003b6	83 c1 04	 add	 ecx, 4
  003b9	3b d1		 cmp	 edx, ecx
  003bb	73 7c		 jae	 SHORT $L2011
  003bd	8d 49 00	 npad	 3
$L1878:

; 240  :       {
; 241  :         NEEDBITS(3)

  003c0	83 fd 03	 cmp	 ebp, 3
  003c3	73 3c		 jae	 SHORT $L1882
  003c5	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$L1881:
  003d0	8b 4c 24 14	 mov	 ecx, DWORD PTR _n$[esp+76]
  003d4	85 c9		 test	 ecx, ecx
  003d6	0f 84 f8 04 00
	00		 je	 $L1904
  003dc	8b d1		 mov	 edx, ecx
  003de	4a		 dec	 edx
  003df	89 54 24 14	 mov	 DWORD PTR _n$[esp+76], edx
  003e3	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  003e6	8b cd		 mov	 ecx, ebp
  003e8	d3 e2		 shl	 edx, cl
  003ea	83 c5 08	 add	 ebp, 8
  003ed	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _r$[esp+72], 0
  003f5	0b c2		 or	 eax, edx
  003f7	47		 inc	 edi
  003f8	83 fd 03	 cmp	 ebp, 3
  003fb	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax
  003ff	72 cf		 jb	 SHORT $L1881
$L1882:

; 242  :         s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;

  00401	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00404	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _border[ecx*4]
  0040b	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0040e	83 e0 07	 and	 eax, 7
  00411	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  00414	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]

; 243  :         DUMPBITS(3)

  00417	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+76]
  0041b	42		 inc	 edx
  0041c	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  0041f	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00422	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00425	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  00428	c1 e8 03	 shr	 eax, 3
  0042b	83 c2 04	 add	 edx, 4
  0042e	83 ed 03	 sub	 ebp, 3
  00431	3b ca		 cmp	 ecx, edx
  00433	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax
  00437	72 87		 jb	 SHORT $L1878
$L2011:

; 244  :       }
; 245  :       while (s->sub.trees.index < 19)

  00439	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0043c	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  00441	3b c8		 cmp	 ecx, eax
  00443	73 2c		 jae	 SHORT $L1889
  00445	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$L1888:

; 246  :         s->sub.trees.blens[border[s->sub.trees.index++]] = 0;

  00450	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00453	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _border[ecx*4]
  0045a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0045d	c7 04 91 00 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 0
  00464	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00467	42		 inc	 edx
  00468	8b ca		 mov	 ecx, edx
  0046a	3b c8		 cmp	 ecx, eax
  0046c	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  0046f	72 df		 jb	 SHORT $L1888
$L1889:

; 247  :       s->sub.trees.bb = 7;
; 248  :       t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
; 249  :                              &s->sub.trees.tb, s->hufts, z);

  00471	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00474	56		 push	 esi
  00475	50		 push	 eax
  00476	8d 4b 14	 lea	 ecx, DWORD PTR [ebx+20]
  00479	8d 53 10	 lea	 edx, DWORD PTR [ebx+16]
  0047c	51		 push	 ecx
  0047d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00480	c7 02 07 00 00
	00		 mov	 DWORD PTR [edx], 7
  00486	e8 00 00 00 00	 call	 @inflate_trees_bits@20

; 250  :       if (t != Z_OK)

  0048b	85 c0		 test	 eax, eax
  0048d	89 44 24 1c	 mov	 DWORD PTR _t$[esp+76], eax
  00491	0f 85 0c 04 00
	00		 jne	 $L2023

; 259  :       }
; 260  :       s->sub.trees.index = 0;

  00497	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 261  :       Tracev((stderr, "inflate:       bits tree ok\n"));
; 262  :       s->mode = DTREE;

  0049a	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+76]
  0049e	c7 03 05 00 00
	00		 mov	 DWORD PTR [ebx], 5
$L2053:

; 263  :     case DTREE:
; 264  :       while (t = s->sub.trees.table,
; 265  :              s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))

  004a4	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  004a7	8b d1		 mov	 edx, ecx
  004a9	c1 ea 05	 shr	 edx, 5
  004ac	83 e2 1f	 and	 edx, 31			; 0000001fH
  004af	83 e1 1f	 and	 ecx, 31			; 0000001fH
  004b2	8d 8c 0a 02 01
	00 00		 lea	 ecx, DWORD PTR [edx+ecx+258]
  004b9	39 4b 08	 cmp	 DWORD PTR [ebx+8], ecx
  004bc	0f 83 95 01 00
	00		 jae	 $L1896
  004c2	eb 04		 jmp	 SHORT $L1895
$L2042:
  004c4	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+76]
$L1895:

; 266  :       {
; 267  :         inflate_huft *h;
; 268  :         uInt i, j, c;
; 269  : 
; 270  :         t = s->sub.trees.bb;

  004c8	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]

; 271  :         NEEDBITS(t)

  004cb	3b e9		 cmp	 ebp, ecx
  004cd	73 34		 jae	 SHORT $L1903
  004cf	90		 npad	 1
$L1902:
  004d0	8b 4c 24 14	 mov	 ecx, DWORD PTR _n$[esp+76]
  004d4	85 c9		 test	 ecx, ecx
  004d6	0f 84 f8 03 00
	00		 je	 $L1904
  004dc	8b d1		 mov	 edx, ecx
  004de	4a		 dec	 edx
  004df	89 54 24 14	 mov	 DWORD PTR _n$[esp+76], edx
  004e3	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  004e6	8b cd		 mov	 ecx, ebp
  004e8	d3 e2		 shl	 edx, cl
  004ea	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  004ed	83 c5 08	 add	 ebp, 8
  004f0	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _r$[esp+72], 0
  004f8	0b c2		 or	 eax, edx
  004fa	47		 inc	 edi
  004fb	3b e9		 cmp	 ebp, ecx
  004fd	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax
  00501	72 cd		 jb	 SHORT $L1902
$L1903:

; 272  :         h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);

  00503	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _inflate_mask[ecx*4]
  0050a	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  0050d	23 c8		 and	 ecx, eax
  0050f	8d 14 ca	 lea	 edx, DWORD PTR [edx+ecx*8]

; 273  :         t = h->bits;

  00512	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]

; 274  :         c = h->base;

  00516	8b 52 04	 mov	 edx, DWORD PTR [edx+4]

; 275  :         if (c < 16)

  00519	83 fa 10	 cmp	 edx, 16			; 00000010H
  0051c	89 4c 24 1c	 mov	 DWORD PTR _t$[esp+76], ecx
  00520	89 54 24 40	 mov	 DWORD PTR _c$1900[esp+76], edx
  00524	73 19		 jae	 SHORT $L1908

; 276  :         {
; 277  :           DUMPBITS(t)

  00526	d3 e8		 shr	 eax, cl
  00528	2b e9		 sub	 ebp, ecx

; 278  :           s->sub.trees.blens[s->sub.trees.index++] = c;

  0052a	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0052d	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax
  00531	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00534	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  00537	ff 43 08	 inc	 DWORD PTR [ebx+8]

; 279  :         }
; 280  :         else /* c == 16..18 */

  0053a	e9 fa 00 00 00	 jmp	 $L1909
$L1908:

; 281  :         {
; 282  :           i = c == 18 ? 7 : c - 14;

  0053f	83 fa 12	 cmp	 edx, 18			; 00000012H
  00542	75 0a		 jne	 SHORT $L1997
  00544	c7 44 24 24 07
	00 00 00	 mov	 DWORD PTR _i$1898[esp+76], 7
  0054c	eb 07		 jmp	 SHORT $L1998
$L1997:
  0054e	8d 4a f2	 lea	 ecx, DWORD PTR [edx-14]
  00551	89 4c 24 24	 mov	 DWORD PTR _i$1898[esp+76], ecx
$L1998:

; 283  :           j = c == 18 ? 11 : 3;

  00555	33 c9		 xor	 ecx, ecx
  00557	83 fa 12	 cmp	 edx, 18			; 00000012H

; 284  :           NEEDBITS(t + i)

  0055a	8b 54 24 24	 mov	 edx, DWORD PTR _i$1898[esp+76]
  0055e	0f 94 c1	 sete	 cl
  00561	8d 0c cd 03 00
	00 00		 lea	 ecx, DWORD PTR [ecx*8+3]
  00568	89 4c 24 20	 mov	 DWORD PTR _j$1899[esp+76], ecx
  0056c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _t$[esp+76]
  00570	03 ca		 add	 ecx, edx
  00572	3b e9		 cmp	 ebp, ecx
  00574	89 4c 24 3c	 mov	 DWORD PTR $T2035[esp+76], ecx
  00578	73 3a		 jae	 SHORT $L1912
  0057a	8d 9b 00 00 00
	00		 npad	 6
$L1911:
  00580	8b 4c 24 14	 mov	 ecx, DWORD PTR _n$[esp+76]
  00584	85 c9		 test	 ecx, ecx
  00586	0f 84 88 03 00
	00		 je	 $L1913
  0058c	8b d1		 mov	 edx, ecx
  0058e	4a		 dec	 edx
  0058f	89 54 24 14	 mov	 DWORD PTR _n$[esp+76], edx
  00593	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00596	8b cd		 mov	 ecx, ebp
  00598	d3 e2		 shl	 edx, cl
  0059a	8b 4c 24 3c	 mov	 ecx, DWORD PTR $T2035[esp+76]
  0059e	83 c5 08	 add	 ebp, 8
  005a1	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _r$[esp+72], 0
  005a9	0b c2		 or	 eax, edx
  005ab	47		 inc	 edi
  005ac	3b e9		 cmp	 ebp, ecx
  005ae	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax
  005b2	72 cc		 jb	 SHORT $L1911
$L1912:

; 285  :           DUMPBITS(t)

  005b4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _t$[esp+76]
  005b8	d3 e8		 shr	 eax, cl

; 286  :           j += (uInt)b & inflate_mask[i];

  005ba	8b 4c 24 24	 mov	 ecx, DWORD PTR _i$1898[esp+76]
  005be	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _inflate_mask[ecx*4]
  005c5	8b 4c 24 20	 mov	 ecx, DWORD PTR _j$1899[esp+76]
  005c9	23 d0		 and	 edx, eax
  005cb	03 ca		 add	 ecx, edx
  005cd	89 4c 24 20	 mov	 DWORD PTR _j$1899[esp+76], ecx

; 287  :           DUMPBITS(i)

  005d1	8b 4c 24 24	 mov	 ecx, DWORD PTR _i$1898[esp+76]
  005d5	d3 e8		 shr	 eax, cl
  005d7	89 44 24 10	 mov	 DWORD PTR _b$[esp+76], eax
  005db	8b 44 24 1c	 mov	 eax, DWORD PTR _t$[esp+76]
  005df	03 c8		 add	 ecx, eax

; 288  :           i = s->sub.trees.index;
; 289  :           t = s->sub.trees.table;

  005e1	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 290  :           if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
; 291  :               (c == 16 && i < 1))

  005e4	8b d0		 mov	 edx, eax
  005e6	c1 ea 05	 shr	 edx, 5
  005e9	83 e2 1f	 and	 edx, 31			; 0000001fH
  005ec	83 e0 1f	 and	 eax, 31			; 0000001fH
  005ef	8d 84 02 02 01
	00 00		 lea	 eax, DWORD PTR [edx+eax+258]
  005f6	8b 54 24 20	 mov	 edx, DWORD PTR _j$1899[esp+76]
  005fa	2b e9		 sub	 ebp, ecx
  005fc	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  005ff	03 d1		 add	 edx, ecx
  00601	3b d0		 cmp	 edx, eax
  00603	0f 87 4b 03 00
	00		 ja	 $L2016
  00609	83 7c 24 40 10	 cmp	 DWORD PTR _c$1900[esp+76], 16 ; 00000010H
  0060e	75 12		 jne	 SHORT $L1999
  00610	83 f9 01	 cmp	 ecx, 1
  00613	0f 82 3b 03 00
	00		 jb	 $L2016

; 298  :           }
; 299  :           c = c == 16 ? s->sub.trees.blens[i - 1] : 0;

  00619	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0061c	8b 44 88 fc	 mov	 eax, DWORD PTR [eax+ecx*4-4]
  00620	eb 02		 jmp	 SHORT $L1922
$L1999:
  00622	33 c0		 xor	 eax, eax
$L1922:

; 300  :           do {
; 301  :             s->sub.trees.blens[i++] = c;

  00624	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00627	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 302  :           } while (--j);

  0062a	8b 54 24 20	 mov	 edx, DWORD PTR _j$1899[esp+76]
  0062e	41		 inc	 ecx
  0062f	4a		 dec	 edx
  00630	89 54 24 20	 mov	 DWORD PTR _j$1899[esp+76], edx
  00634	75 ee		 jne	 SHORT $L1922

; 303  :           s->sub.trees.index = i;

  00636	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
$L1909:

; 263  :     case DTREE:
; 264  :       while (t = s->sub.trees.table,
; 265  :              s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))

  00639	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0063c	8b c8		 mov	 ecx, eax
  0063e	c1 e9 05	 shr	 ecx, 5
  00641	83 e0 1f	 and	 eax, 31			; 0000001fH
  00644	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00647	8d 94 01 02 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax+258]
  0064e	39 53 08	 cmp	 DWORD PTR [ebx+8], edx
  00651	0f 82 6d fe ff
	ff		 jb	 $L2042
$L1896:

; 304  :         }
; 305  :       }
; 306  :       s->sub.trees.tb = Z_NULL;
; 307  :       {
; 308  :         uInt bl, bd;
; 309  :         inflate_huft *tl, *td;
; 310  :         inflate_codes_statef *c;
; 311  : 
; 312  :         bl = 9;         /* must be <= 9 for lookahead assumptions */
; 313  :         bd = 6;         /* must be <= 9 for lookahead assumptions */
; 314  :         t = s->sub.trees.table;
; 315  :         t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
; 316  :                                   s->sub.trees.blens, &bl, &bd, &tl, &td,
; 317  :                                   s->hufts, z);

  00657	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0065a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0065d	56		 push	 esi
  0065e	50		 push	 eax
  0065f	8d 54 24 4c	 lea	 edx, DWORD PTR _td$1928[esp+84]
  00663	52		 push	 edx
  00664	8d 44 24 54	 lea	 eax, DWORD PTR _tl$1927[esp+88]
  00668	50		 push	 eax
  00669	8d 54 24 34	 lea	 edx, DWORD PTR _bd$1926[esp+92]
  0066d	52		 push	 edx
  0066e	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00671	8d 44 24 34	 lea	 eax, DWORD PTR _bl$1925[esp+96]
  00675	50		 push	 eax
  00676	52		 push	 edx
  00677	8b d1		 mov	 edx, ecx
  00679	c1 ea 05	 shr	 edx, 5
  0067c	83 e2 1f	 and	 edx, 31			; 0000001fH
  0067f	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00682	42		 inc	 edx
  00683	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00689	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0
  00690	c7 44 24 3c 09
	00 00 00	 mov	 DWORD PTR _bl$1925[esp+104], 9
  00698	c7 44 24 40 06
	00 00 00	 mov	 DWORD PTR _bd$1926[esp+104], 6
  006a0	e8 00 00 00 00	 call	 @inflate_trees_dynamic@36

; 318  :         if (t != Z_OK)

  006a5	85 c0		 test	 eax, eax
  006a7	89 44 24 1c	 mov	 DWORD PTR _t$[esp+76], eax
  006ab	0f 85 f6 02 00
	00		 jne	 $L2024

; 327  :         }
; 328  :         Tracev((stderr, "inflate:       trees ok\n"));
; 329  :         if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)

  006b1	8b 44 24 44	 mov	 eax, DWORD PTR _td$1928[esp+76]
  006b5	8b 4c 24 48	 mov	 ecx, DWORD PTR _tl$1927[esp+76]
  006b9	8b 54 24 24	 mov	 edx, DWORD PTR _bd$1926[esp+76]
  006bd	56		 push	 esi
  006be	50		 push	 eax
  006bf	51		 push	 ecx
  006c0	8b 4c 24 2c	 mov	 ecx, DWORD PTR _bl$1925[esp+88]
  006c4	e8 00 00 00 00	 call	 @inflate_codes_new@20
  006c9	85 c0		 test	 eax, eax
  006cb	0f 84 2c 03 00
	00		 je	 $L2025

; 333  :         }
; 334  :         s->sub.decode.codes = c;
; 335  :       }
; 336  :       ZFREE(z, s->sub.trees.blens);

  006d1	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  006d4	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  006d7	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  006da	ff 56 24	 call	 DWORD PTR [esi+36]

; 337  :       s->mode = CODES;

  006dd	c7 03 06 00 00
	00		 mov	 DWORD PTR [ebx], 6
$L1936:

; 338  :     case CODES:
; 339  :       UPDATE

  006e3	8b 54 24 10	 mov	 edx, DWORD PTR _b$[esp+76]
  006e7	8b 44 24 14	 mov	 eax, DWORD PTR _n$[esp+76]
  006eb	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  006ee	8b 54 24 18	 mov	 edx, DWORD PTR _q$[esp+76]
  006f2	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  006f5	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  006f8	89 46 04	 mov	 DWORD PTR [esi+4], eax
  006fb	8b 06		 mov	 eax, DWORD PTR [esi]
  006fd	8b cf		 mov	 ecx, edi
  006ff	2b c8		 sub	 ecx, eax

; 340  :       if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)

  00701	8b 44 24 50	 mov	 eax, DWORD PTR _r$[esp+72]
  00705	03 e9		 add	 ebp, ecx
  00707	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0070a	89 3e		 mov	 DWORD PTR [esi], edi
  0070c	89 53 34	 mov	 DWORD PTR [ebx+52], edx
  0070f	50		 push	 eax
  00710	8b d6		 mov	 edx, esi
  00712	8b cb		 mov	 ecx, ebx
  00714	e8 00 00 00 00	 call	 @inflate_codes@12
  00719	83 f8 01	 cmp	 eax, 1

; 342  :       r = Z_OK;
; 343  :       inflate_codes_free(s->sub.decode.codes, z);

  0071c	8b d6		 mov	 edx, esi
  0071e	0f 85 16 03 00
	00		 jne	 $L2026
  00724	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00727	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR _r$[esp+72], 0
  0072f	e8 00 00 00 00	 call	 @inflate_codes_free@8

; 344  :       LOAD

  00734	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00737	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  0073a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0073c	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  0073f	8b 6b 1c	 mov	 ebp, DWORD PTR [ebx+28]
  00742	89 4c 24 14	 mov	 DWORD PTR _n$[esp+76], ecx
  00746	8b 4b 34	 mov	 ecx, DWORD PTR [ebx+52]
  00749	3b c8		 cmp	 ecx, eax
  0074b	89 7c 24 20	 mov	 DWORD PTR _p$[esp+76], edi
  0074f	89 54 24 10	 mov	 DWORD PTR _b$[esp+76], edx
  00753	89 4c 24 18	 mov	 DWORD PTR _q$[esp+76], ecx
  00757	73 07		 jae	 SHORT $L2001
  00759	8b d1		 mov	 edx, ecx
  0075b	2b c2		 sub	 eax, edx
  0075d	48		 dec	 eax
  0075e	eb 07		 jmp	 SHORT $L2060
$L2001:
  00760	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  00763	2b 44 24 18	 sub	 eax, DWORD PTR _q$[esp+76]
$L2060:
  00767	89 44 24 1c	 mov	 DWORD PTR _m$[esp+76], eax

; 345  :       Tracev((stderr, "inflate:       codes end, %lu total out\n",
; 346  :               z->total_out + (q >= s->read ? q - s->read :
; 347  :               (s->end - s->read) + (q - s->window))));
; 348  :       if (!s->last)

  0076b	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  0076e	85 c0		 test	 eax, eax
  00770	0f 85 d6 02 00
	00		 jne	 $L1940

; 349  :       {
; 350  :         s->mode = TYPE;

  00776	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
$L1808:

; 135  : 
; 136  :   /* process input based on current state */
; 137  :   while (1) switch (s->mode)

  0077c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0077e	83 fa 09	 cmp	 edx, 9

; 340  :       if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)

  00781	8b 74 24 28	 mov	 esi, DWORD PTR _z$[esp+76]
  00785	8b 7c 24 20	 mov	 edi, DWORD PTR _p$[esp+76]
  00789	0f 86 f7 f8 ff
	ff		 jbe	 $L2040
  0078f	e9 b5 f8 ff ff	 jmp	 $L1947
$L1815:

; 138  :   {
; 139  :     case TYPE:
; 140  :       NEEDBITS(3)

  00794	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+76]
  00798	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  0079b	8b 44 24 50	 mov	 eax, DWORD PTR _r$[esp+72]
  0079f	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  007a2	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  007a9	50		 push	 eax
  007aa	e9 ad f8 ff ff	 jmp	 $L2061
$L2017:

; 163  :             {
; 164  :               r = Z_MEM_ERROR;
; 165  :               LEAVE

  007af	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+76]
  007b3	8b 54 24 14	 mov	 edx, DWORD PTR _n$[esp+76]
  007b7	89 4b 20	 mov	 DWORD PTR [ebx+32], ecx
  007ba	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  007bd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007c0	89 56 04	 mov	 DWORD PTR [esi+4], edx
  007c3	8b 16		 mov	 edx, DWORD PTR [esi]
  007c5	8b c7		 mov	 eax, edi
  007c7	2b c2		 sub	 eax, edx
  007c9	03 c8		 add	 ecx, eax
  007cb	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  007ce	8b 4c 24 18	 mov	 ecx, DWORD PTR _q$[esp+76]
  007d2	89 3e		 mov	 DWORD PTR [esi], edi
  007d4	89 4b 34	 mov	 DWORD PTR [ebx+52], ecx
  007d7	6a fc		 push	 -4			; fffffffcH

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  007d9	8b d6		 mov	 edx, esi
  007db	8b cb		 mov	 ecx, ebx
  007dd	e8 00 00 00 00	 call	 @inflate_flush@12
  007e2	5f		 pop	 edi
  007e3	5e		 pop	 esi
  007e4	5d		 pop	 ebp
  007e5	5b		 pop	 ebx

; 368  :   }
; 369  : }

  007e6	83 c4 3c	 add	 esp, 60			; 0000003cH
  007e9	c2 04 00	 ret	 4
$L1831:

; 176  :           break;
; 177  :         case 3:                         /* illegal */
; 178  :           DUMPBITS(3)

  007ec	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+76]

; 179  :           s->mode = BAD;
; 180  :           z->msg = (char*)"invalid block type";
; 181  :           r = Z_DATA_ERROR;
; 182  :           LEAVE

  007f0	8b 54 24 14	 mov	 edx, DWORD PTR _n$[esp+76]
  007f4	c7 03 09 00 00
	00		 mov	 DWORD PTR [ebx], 9
  007fa	c1 e8 03	 shr	 eax, 3
  007fd	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
  00804	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00807	83 c5 fd	 add	 ebp, -3			; fffffffdH
  0080a	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  0080d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00810	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00813	8b 16		 mov	 edx, DWORD PTR [esi]
  00815	8b c7		 mov	 eax, edi
  00817	2b c2		 sub	 eax, edx
  00819	03 c8		 add	 ecx, eax
  0081b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0081e	8b 4c 24 18	 mov	 ecx, DWORD PTR _q$[esp+76]
  00822	89 3e		 mov	 DWORD PTR [esi], edi
  00824	89 4b 34	 mov	 DWORD PTR [ebx+52], ecx

; 296  :             r = Z_DATA_ERROR;
; 297  :             LEAVE

  00827	6a fd		 push	 -3			; fffffffdH

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  00829	8b d6		 mov	 edx, esi
  0082b	8b cb		 mov	 ecx, ebx
  0082d	e8 00 00 00 00	 call	 @inflate_flush@12
  00832	5f		 pop	 edi
  00833	5e		 pop	 esi
  00834	5d		 pop	 ebp
  00835	5b		 pop	 ebx

; 368  :   }
; 369  : }

  00836	83 c4 3c	 add	 esp, 60			; 0000003cH
  00839	c2 04 00	 ret	 4
$L2018:

; 188  :       {
; 189  :         s->mode = BAD;

  0083c	c7 03 09 00 00
	00		 mov	 DWORD PTR [ebx], 9

; 190  :         z->msg = (char*)"invalid stored block lengths";

  00842	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 191  :         r = Z_DATA_ERROR;
; 192  :         LEAVE

  00849	e9 1c 01 00 00	 jmp	 $L2065
$L2020:

; 201  :         LEAVE
; 202  :       NEEDOUT

  0084e	8b 54 24 10	 mov	 edx, DWORD PTR _b$[esp+76]
  00852	8b 4c 24 14	 mov	 ecx, DWORD PTR _n$[esp+76]
  00856	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  00859	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  0085c	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0085f	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00862	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00864	8b d7		 mov	 edx, edi
  00866	2b d1		 sub	 edx, ecx
  00868	03 ea		 add	 ebp, edx
  0086a	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  0086d	89 3e		 mov	 DWORD PTR [esi], edi
  0086f	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00872	8b 44 24 50	 mov	 eax, DWORD PTR _r$[esp+72]
  00876	50		 push	 eax

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  00877	8b d6		 mov	 edx, esi
  00879	8b cb		 mov	 ecx, ebx
  0087b	e8 00 00 00 00	 call	 @inflate_flush@12
  00880	5f		 pop	 edi
  00881	5e		 pop	 esi
  00882	5d		 pop	 ebp
  00883	5b		 pop	 ebx

; 368  :   }
; 369  : }

  00884	83 c4 3c	 add	 esp, 60			; 0000003cH
  00887	c2 04 00	 ret	 4
$L2022:

; 230  :       {
; 231  :         r = Z_MEM_ERROR;
; 232  :         LEAVE

  0088a	6a fc		 push	 -4			; fffffffcH
  0088c	e9 ba f7 ff ff	 jmp	 $L2063
$L1870:

; 221  :       {
; 222  :         s->mode = BAD;

  00891	c7 03 09 00 00
	00		 mov	 DWORD PTR [ebx], 9

; 223  :         z->msg = (char*)"too many length or distance symbols";

  00897	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 224  :         r = Z_DATA_ERROR;
; 225  :         LEAVE

  0089e	e9 c7 00 00 00	 jmp	 $L2065
$L2023:

; 251  :       {
; 252  :         r = t;
; 253  :         if (r == Z_DATA_ERROR)

  008a3	83 7c 24 1c fd	 cmp	 DWORD PTR _t$[esp+76], -3 ; fffffffdH
  008a8	75 0f		 jne	 SHORT $L1891

; 254  :         {
; 255  :           ZFREE(z, s->sub.trees.blens);

  008aa	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  008ad	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  008b0	ff 56 24	 call	 DWORD PTR [esi+36]

; 256  :           s->mode = BAD;

  008b3	c7 03 09 00 00
	00		 mov	 DWORD PTR [ebx], 9
$L1891:

; 257  :         }
; 258  :         LEAVE

  008b9	8b 54 24 10	 mov	 edx, DWORD PTR _b$[esp+76]
  008bd	8b 44 24 14	 mov	 eax, DWORD PTR _n$[esp+76]
  008c1	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  008c4	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  008c7	89 46 04	 mov	 DWORD PTR [esi+4], eax
  008ca	8b 44 24 1c	 mov	 eax, DWORD PTR _t$[esp+76]
  008ce	50		 push	 eax
  008cf	e9 88 f7 ff ff	 jmp	 $L2061
$L1904:

; 271  :         NEEDBITS(t)

  008d4	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+76]
  008d8	8b 44 24 18	 mov	 eax, DWORD PTR _q$[esp+76]
  008dc	89 4b 20	 mov	 DWORD PTR [ebx+32], ecx
  008df	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  008e2	8b 2e		 mov	 ebp, DWORD PTR [esi]
  008e4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  008e7	8b d7		 mov	 edx, edi
  008e9	2b d5		 sub	 edx, ebp
  008eb	03 ca		 add	 ecx, edx
  008ed	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  008f0	8b 4c 24 50	 mov	 ecx, DWORD PTR _r$[esp+72]
  008f4	51		 push	 ecx
  008f5	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  008fc	89 3e		 mov	 DWORD PTR [esi], edi

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  008fe	8b d6		 mov	 edx, esi
  00900	8b cb		 mov	 ecx, ebx
  00902	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00905	e8 00 00 00 00	 call	 @inflate_flush@12
  0090a	5f		 pop	 edi
  0090b	5e		 pop	 esi
  0090c	5d		 pop	 ebp
  0090d	5b		 pop	 ebx

; 368  :   }
; 369  : }

  0090e	83 c4 3c	 add	 esp, 60			; 0000003cH
  00911	c2 04 00	 ret	 4
$L1913:

; 284  :           NEEDBITS(t + i)

  00914	8b 54 24 10	 mov	 edx, DWORD PTR _b$[esp+76]
  00918	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  0091b	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  0091e	8b 16		 mov	 edx, DWORD PTR [esi]
  00920	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00923	8b c7		 mov	 eax, edi
  00925	2b c2		 sub	 eax, edx
  00927	8b 54 24 50	 mov	 edx, DWORD PTR _r$[esp+72]
  0092b	03 c8		 add	 ecx, eax
  0092d	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00930	8b 4c 24 18	 mov	 ecx, DWORD PTR _q$[esp+76]
  00934	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0093b	89 3e		 mov	 DWORD PTR [esi], edi
  0093d	89 4b 34	 mov	 DWORD PTR [ebx+52], ecx
  00940	52		 push	 edx

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  00941	8b d6		 mov	 edx, esi
  00943	8b cb		 mov	 ecx, ebx
  00945	e8 00 00 00 00	 call	 @inflate_flush@12
  0094a	5f		 pop	 edi
  0094b	5e		 pop	 esi
  0094c	5d		 pop	 ebp
  0094d	5b		 pop	 ebx

; 368  :   }
; 369  : }

  0094e	83 c4 3c	 add	 esp, 60			; 0000003cH
  00951	c2 04 00	 ret	 4
$L2016:

; 292  :           {
; 293  :             ZFREE(z, s->sub.trees.blens);

  00954	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00957	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0095a	ff 56 24	 call	 DWORD PTR [esi+36]

; 294  :             s->mode = BAD;

  0095d	c7 03 09 00 00
	00		 mov	 DWORD PTR [ebx], 9

; 295  :             z->msg = (char*)"invalid bit length repeat";

  00963	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
$L2065:

; 296  :             r = Z_DATA_ERROR;
; 297  :             LEAVE

  0096a	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+76]
  0096e	8b 4c 24 14	 mov	 ecx, DWORD PTR _n$[esp+76]
  00972	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00975	8b 44 24 18	 mov	 eax, DWORD PTR _q$[esp+76]
  00979	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  0097c	8b 2e		 mov	 ebp, DWORD PTR [esi]
  0097e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00981	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00984	8b d7		 mov	 edx, edi
  00986	2b d5		 sub	 edx, ebp
  00988	03 ca		 add	 ecx, edx
  0098a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0098d	89 3e		 mov	 DWORD PTR [esi], edi
  0098f	6a fd		 push	 -3			; fffffffdH

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  00991	8b d6		 mov	 edx, esi
  00993	8b cb		 mov	 ecx, ebx
  00995	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00998	e8 00 00 00 00	 call	 @inflate_flush@12
  0099d	5f		 pop	 edi
  0099e	5e		 pop	 esi
  0099f	5d		 pop	 ebp
  009a0	5b		 pop	 ebx

; 368  :   }
; 369  : }

  009a1	83 c4 3c	 add	 esp, 60			; 0000003cH
  009a4	c2 04 00	 ret	 4
$L2024:

; 319  :         {
; 320  :           if (t == (uInt)Z_DATA_ERROR)

  009a7	83 7c 24 1c fd	 cmp	 DWORD PTR _t$[esp+76], -3 ; fffffffdH
  009ac	75 0f		 jne	 SHORT $L1932

; 321  :           {
; 322  :             ZFREE(z, s->sub.trees.blens);

  009ae	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  009b1	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  009b4	ff 56 24	 call	 DWORD PTR [esi+36]

; 323  :             s->mode = BAD;

  009b7	c7 03 09 00 00
	00		 mov	 DWORD PTR [ebx], 9
$L1932:

; 324  :           }
; 325  :           r = t;
; 326  :           LEAVE

  009bd	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+76]
  009c1	8b 54 24 14	 mov	 edx, DWORD PTR _n$[esp+76]
  009c5	89 4b 20	 mov	 DWORD PTR [ebx+32], ecx
  009c8	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  009cb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  009ce	89 56 04	 mov	 DWORD PTR [esi+4], edx
  009d1	8b 16		 mov	 edx, DWORD PTR [esi]
  009d3	8b c7		 mov	 eax, edi
  009d5	2b c2		 sub	 eax, edx
  009d7	8b 54 24 1c	 mov	 edx, DWORD PTR _t$[esp+76]
  009db	03 c8		 add	 ecx, eax
  009dd	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  009e0	8b 4c 24 18	 mov	 ecx, DWORD PTR _q$[esp+76]
  009e4	89 3e		 mov	 DWORD PTR [esi], edi
  009e6	89 4b 34	 mov	 DWORD PTR [ebx+52], ecx
  009e9	52		 push	 edx

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  009ea	8b d6		 mov	 edx, esi
  009ec	8b cb		 mov	 ecx, ebx
  009ee	e8 00 00 00 00	 call	 @inflate_flush@12
  009f3	5f		 pop	 edi
  009f4	5e		 pop	 esi
  009f5	5d		 pop	 ebp
  009f6	5b		 pop	 ebx

; 368  :   }
; 369  : }

  009f7	83 c4 3c	 add	 esp, 60			; 0000003cH
  009fa	c2 04 00	 ret	 4
$L2025:

; 330  :         {
; 331  :           r = Z_MEM_ERROR;
; 332  :           LEAVE

  009fd	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+76]
  00a01	8b 4c 24 14	 mov	 ecx, DWORD PTR _n$[esp+76]
  00a05	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00a08	8b 44 24 18	 mov	 eax, DWORD PTR _q$[esp+76]
  00a0c	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  00a0f	8b 2e		 mov	 ebp, DWORD PTR [esi]
  00a11	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00a14	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00a17	8b d7		 mov	 edx, edi
  00a19	2b d5		 sub	 edx, ebp
  00a1b	03 ca		 add	 ecx, edx
  00a1d	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00a20	89 3e		 mov	 DWORD PTR [esi], edi
  00a22	6a fc		 push	 -4			; fffffffcH

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  00a24	8b d6		 mov	 edx, esi
  00a26	8b cb		 mov	 ecx, ebx
  00a28	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00a2b	e8 00 00 00 00	 call	 @inflate_flush@12
  00a30	5f		 pop	 edi
  00a31	5e		 pop	 esi
  00a32	5d		 pop	 ebp
  00a33	5b		 pop	 ebx

; 368  :   }
; 369  : }

  00a34	83 c4 3c	 add	 esp, 60			; 0000003cH
  00a37	c2 04 00	 ret	 4
$L2026:

; 341  :         return inflate_flush(s, z, r);

  00a3a	50		 push	 eax

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  00a3b	8b cb		 mov	 ecx, ebx
  00a3d	e8 00 00 00 00	 call	 @inflate_flush@12
  00a42	5f		 pop	 edi
  00a43	5e		 pop	 esi
  00a44	5d		 pop	 ebp
  00a45	5b		 pop	 ebx

; 368  :   }
; 369  : }

  00a46	83 c4 3c	 add	 esp, 60			; 0000003cH
  00a49	c2 04 00	 ret	 4
$L1940:

; 351  :         break;
; 352  :       }
; 353  :       s->mode = DRY;

  00a4c	c7 03 07 00 00
	00		 mov	 DWORD PTR [ebx], 7
$L1941:

; 354  :     case DRY:
; 355  :       FLUSH

  00a52	8b 4c 24 18	 mov	 ecx, DWORD PTR _q$[esp+76]
  00a56	8b 54 24 50	 mov	 edx, DWORD PTR _r$[esp+72]
  00a5a	89 4b 34	 mov	 DWORD PTR [ebx+52], ecx
  00a5d	52		 push	 edx
  00a5e	8b d6		 mov	 edx, esi
  00a60	8b cb		 mov	 ecx, ebx
  00a62	e8 00 00 00 00	 call	 @inflate_flush@12
  00a67	8b 4b 34	 mov	 ecx, DWORD PTR [ebx+52]

; 356  :       if (s->read != s->write)

  00a6a	39 4b 30	 cmp	 DWORD PTR [ebx+48], ecx
  00a6d	89 4c 24 18	 mov	 DWORD PTR _q$[esp+76], ecx
  00a71	74 17		 je	 SHORT $L1944

; 357  :         LEAVE

  00a73	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+76]
  00a77	8b 54 24 14	 mov	 edx, DWORD PTR _n$[esp+76]
  00a7b	89 4b 20	 mov	 DWORD PTR [ebx+32], ecx
  00a7e	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  00a81	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00a84	50		 push	 eax
  00a85	e9 d2 f5 ff ff	 jmp	 $L2061
$L1944:

; 358  :       s->mode = DONE;

  00a8a	c7 03 08 00 00
	00		 mov	 DWORD PTR [ebx], 8
$L1945:

; 359  :     case DONE:
; 360  :       r = Z_STREAM_END;
; 361  :       LEAVE

  00a90	8b 44 24 10	 mov	 eax, DWORD PTR _b$[esp+76]
  00a94	8b 4c 24 14	 mov	 ecx, DWORD PTR _n$[esp+76]
  00a98	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00a9b	8b 44 24 18	 mov	 eax, DWORD PTR _q$[esp+76]
  00a9f	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  00aa2	8b 2e		 mov	 ebp, DWORD PTR [esi]
  00aa4	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00aa7	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00aaa	8b d7		 mov	 edx, edi
  00aac	2b d5		 sub	 edx, ebp
  00aae	03 ca		 add	 ecx, edx
  00ab0	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00ab3	89 3e		 mov	 DWORD PTR [esi], edi
  00ab5	6a 01		 push	 1

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  00ab7	8b d6		 mov	 edx, esi
  00ab9	8b cb		 mov	 ecx, ebx
  00abb	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00abe	e8 00 00 00 00	 call	 @inflate_flush@12
  00ac3	5f		 pop	 edi
  00ac4	5e		 pop	 esi
  00ac5	5d		 pop	 ebp
  00ac6	5b		 pop	 ebx

; 368  :   }
; 369  : }

  00ac7	83 c4 3c	 add	 esp, 60			; 0000003cH
  00aca	c2 04 00	 ret	 4
$L1946:

; 362  :     case BAD:
; 363  :       r = Z_DATA_ERROR;
; 364  :       LEAVE

  00acd	8b 4c 24 10	 mov	 ecx, DWORD PTR _b$[esp+76]
  00ad1	8b 54 24 14	 mov	 edx, DWORD PTR _n$[esp+76]
  00ad5	89 4b 20	 mov	 DWORD PTR [ebx+32], ecx
  00ad8	89 6b 1c	 mov	 DWORD PTR [ebx+28], ebp
  00adb	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00ade	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00ae1	8b 16		 mov	 edx, DWORD PTR [esi]
  00ae3	8b c7		 mov	 eax, edi
  00ae5	2b c2		 sub	 eax, edx
  00ae7	03 c8		 add	 ecx, eax
  00ae9	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00aec	8b 4c 24 18	 mov	 ecx, DWORD PTR _q$[esp+76]
  00af0	89 3e		 mov	 DWORD PTR [esi], edi
  00af2	89 4b 34	 mov	 DWORD PTR [ebx+52], ecx
  00af5	6a fd		 push	 -3			; fffffffdH

; 365  :     default:
; 366  :       r = Z_STREAM_ERROR;
; 367  :       LEAVE

  00af7	8b d6		 mov	 edx, esi
  00af9	8b cb		 mov	 ecx, ebx
  00afb	e8 00 00 00 00	 call	 @inflate_flush@12
  00b00	5f		 pop	 edi
  00b01	5e		 pop	 esi
  00b02	5d		 pop	 ebp
  00b03	5b		 pop	 ebx

; 368  :   }
; 369  : }

  00b04	83 c4 3c	 add	 esp, 60			; 0000003cH
  00b07	c2 04 00	 ret	 4
  00b0a	8b ff		 npad	 2
$L2067:
  00b0c	00 00 00 00	 DD	 $L2006
  00b10	00 00 00 00	 DD	 $L2007
  00b14	00 00 00 00	 DD	 $L1845
  00b18	00 00 00 00	 DD	 $L2008
  00b1c	00 00 00 00	 DD	 $L2052
  00b20	00 00 00 00	 DD	 $L2053
  00b24	00 00 00 00	 DD	 $L1936
  00b28	00 00 00 00	 DD	 $L1941
  00b2c	00 00 00 00	 DD	 $L1945
  00b30	00 00 00 00	 DD	 $L1946
$L2068:
  00b34	00 00 00 00	 DD	 $L1823
  00b38	00 00 00 00	 DD	 $L1824
  00b3c	00 00 00 00	 DD	 $L1830
  00b40	00 00 00 00	 DD	 $L1831
@inflate_blocks@12 ENDP
_TEXT	ENDS
PUBLIC	@inflate_blocks_free@8
; Function compile flags: /Ogty
;	COMDAT @inflate_blocks_free@8
_TEXT	SEGMENT
@inflate_blocks_free@8 PROC NEAR			; COMDAT
; _s$ = ecx
; _z$ = edx

; 375  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 376  :   inflate_blocks_reset(s, z, Z_NULL);

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	83 f8 04	 cmp	 eax, 4
  00008	57		 push	 edi
  00009	8b fa		 mov	 edi, edx
  0000b	74 05		 je	 SHORT $L2076
  0000d	83 f8 05	 cmp	 eax, 5
  00010	75 09		 jne	 SHORT $L2075
$L2076:
  00012	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00015	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00018	ff 57 24	 call	 DWORD PTR [edi+36]
$L2075:
  0001b	83 3e 06	 cmp	 DWORD PTR [esi], 6
  0001e	75 0a		 jne	 SHORT $L2077
  00020	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00023	8b d7		 mov	 edx, edi
  00025	e8 00 00 00 00	 call	 @inflate_codes_free@8
$L2077:
  0002a	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0002d	33 c9		 xor	 ecx, ecx
  0002f	89 46 34	 mov	 DWORD PTR [esi+52], eax
  00032	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00035	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00038	3b c1		 cmp	 eax, ecx
  0003a	89 0e		 mov	 DWORD PTR [esi], ecx
  0003c	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx
  0003f	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  00042	74 0b		 je	 SHORT $L2078
  00044	51		 push	 ecx
  00045	33 d2		 xor	 edx, edx
  00047	ff d0		 call	 eax
  00049	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0004c	89 47 30	 mov	 DWORD PTR [edi+48], eax
$L2078:

; 377  :   ZFREE(z, s->window);

  0004f	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00052	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00055	ff 57 24	 call	 DWORD PTR [edi+36]

; 378  :   ZFREE(z, s->hufts);

  00058	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  0005b	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  0005e	ff 57 24	 call	 DWORD PTR [edi+36]

; 379  :   ZFREE(z, s);

  00061	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00064	8b d6		 mov	 edx, esi
  00066	ff 57 24	 call	 DWORD PTR [edi+36]
  00069	5f		 pop	 edi

; 380  :   Tracev((stderr, "inflate:   blocks freed\n"));
; 381  :   return Z_OK;

  0006a	33 c0		 xor	 eax, eax
  0006c	5e		 pop	 esi

; 382  : }

  0006d	c3		 ret	 0
@inflate_blocks_free@8 ENDP
_TEXT	ENDS
PUBLIC	@inflate_set_dictionary@12
; Function compile flags: /Ogty
;	COMDAT @inflate_set_dictionary@12
_TEXT	SEGMENT
_n$ = 8							; size = 4
@inflate_set_dictionary@12 PROC NEAR			; COMDAT
; _s$ = ecx
; _d$ = edx

; 389  : {

  00000	8b c1		 mov	 eax, ecx
  00002	53		 push	 ebx

; 390  :   zmemcpy(s->window, d, n);

  00003	8b 5c 24 08	 mov	 ebx, DWORD PTR _n$[esp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 78 28	 mov	 edi, DWORD PTR [eax+40]
  0000c	8b cb		 mov	 ecx, ebx
  0000e	8b f2		 mov	 esi, edx
  00010	8b d1		 mov	 edx, ecx
  00012	c1 e9 02	 shr	 ecx, 2
  00015	f3 a5		 rep movsd
  00017	8b ca		 mov	 ecx, edx
  00019	83 e1 03	 and	 ecx, 3
  0001c	f3 a4		 rep movsb

; 391  :   s->read = s->write = s->window + n;

  0001e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00021	5f		 pop	 edi
  00022	03 cb		 add	 ecx, ebx
  00024	5e		 pop	 esi
  00025	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  00028	89 48 30	 mov	 DWORD PTR [eax+48], ecx
  0002b	5b		 pop	 ebx

; 392  : }

  0002c	c2 04 00	 ret	 4
@inflate_set_dictionary@12 ENDP
_TEXT	ENDS
PUBLIC	@inflate_blocks_sync_point@4
; Function compile flags: /Ogty
;	COMDAT @inflate_blocks_sync_point@4
_TEXT	SEGMENT
@inflate_blocks_sync_point@4 PROC NEAR			; COMDAT
; _s$ = ecx

; 402  :   return s->mode == LENS;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	33 c0		 xor	 eax, eax
  00004	83 fa 01	 cmp	 edx, 1
  00007	0f 94 c0	 sete	 al

; 403  : }

  0000a	c3		 ret	 0
@inflate_blocks_sync_point@4 ENDP
_TEXT	ENDS
END
