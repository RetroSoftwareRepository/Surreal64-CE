; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\inffast.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT @inflate_fast@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	@inflate_fast@24
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
EXTRN	_inflate_mask:BYTE
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\inffast.c
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT @inflate_fast@24
_TEXT	SEGMENT
_n$ = -24						; size = 4
_p$ = -20						; size = 4
_m$ = -16						; size = 4
_ml$ = -12						; size = 4
_bl$ = -12						; size = 4
_md$ = -8						; size = 4
tv566 = -4						; size = 4
_c$ = -4						; size = 4
_tl$ = 8						; size = 4
_td$ = 12						; size = 4
_s$ = 16						; size = 4
_z$ = 20						; size = 4
@inflate_fast@24 PROC NEAR				; COMDAT
; _bl$ = ecx
; _bd$ = edx

; 34   : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx

; 35   :   inflate_huft *t;      /* temporary pointer */
; 36   :   uInt e;               /* extra bits or operation */
; 37   :   uLong b;              /* bit buffer */
; 38   :   uInt k;               /* bits in bit buffer */
; 39   :   Bytef *p;             /* input data pointer */
; 40   :   uInt n;               /* bytes available there */
; 41   :   Bytef *q;             /* output window write pointer */
; 42   :   uInt m;               /* bytes to end of window or read pointer */
; 43   :   uInt ml;              /* mask for literal/length tree */
; 44   :   uInt md;              /* mask for distance tree */
; 45   :   uInt c;               /* bytes to copy */
; 46   :   uInt d;               /* distance back to copy from */
; 47   :   Bytef *r;             /* copy source pointer */
; 48   : 
; 49   :   /* load input, output, bit values */
; 50   :   LOAD

  00004	8b 5c 24 28	 mov	 ebx, DWORD PTR _s$[esp+24]
  00008	55		 push	 ebp
  00009	8b 6b 34	 mov	 ebp, DWORD PTR [ebx+52]
  0000c	56		 push	 esi
  0000d	8b 73 20	 mov	 esi, DWORD PTR [ebx+32]
  00010	57		 push	 edi
  00011	8b 7c 24 38	 mov	 edi, DWORD PTR _z$[esp+36]
  00015	8b 07		 mov	 eax, DWORD PTR [edi]
  00017	89 4c 24 1c	 mov	 DWORD PTR _bl$[esp+40], ecx
  0001b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001e	89 4c 24 10	 mov	 DWORD PTR _n$[esp+40], ecx
  00022	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  00025	3b e9		 cmp	 ebp, ecx
  00027	89 44 24 14	 mov	 DWORD PTR _p$[esp+40], eax
  0002b	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0002e	73 09		 jae	 SHORT $L1866
  00030	2b cd		 sub	 ecx, ebp
  00032	49		 dec	 ecx
  00033	89 4c 24 18	 mov	 DWORD PTR _m$[esp+40], ecx
  00037	eb 09		 jmp	 SHORT $L1867
$L1866:
  00039	8b 5b 2c	 mov	 ebx, DWORD PTR [ebx+44]
  0003c	2b dd		 sub	 ebx, ebp
  0003e	89 5c 24 18	 mov	 DWORD PTR _m$[esp+40], ebx
$L1867:

; 51   : 
; 52   :   /* initialize masks */
; 53   :   ml = inflate_mask[bl];

  00042	8b 4c 24 1c	 mov	 ecx, DWORD PTR _bl$[esp+40]
  00046	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR _inflate_mask[ecx*4]

; 54   :   md = inflate_mask[bd];

  0004d	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _inflate_mask[edx*4]
  00054	89 4c 24 1c	 mov	 DWORD PTR _ml$[esp+40], ecx
  00058	89 54 24 20	 mov	 DWORD PTR _md$[esp+40], edx
  0005c	8d 64 24 00	 npad	 4
$L1793:

; 55   : 
; 56   :   /* do until not enough input or output space for fast loop */
; 57   :   do {                          /* assume called with m >= 258 && n >= 10 */
; 58   :     /* get literal/length code */
; 59   :     GRABBITS(20)                /* max bits for literal/length code */

  00060	83 f8 14	 cmp	 eax, 20			; 00000014H
  00063	73 27		 jae	 SHORT $L1798
$L1797:
  00065	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+40]
  00069	8b 5c 24 14	 mov	 ebx, DWORD PTR _p$[esp+40]
  0006d	49		 dec	 ecx
  0006e	89 4c 24 10	 mov	 DWORD PTR _n$[esp+40], ecx
  00072	8b 4c 24 14	 mov	 ecx, DWORD PTR _p$[esp+40]
  00076	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00079	8b c8		 mov	 ecx, eax
  0007b	d3 e2		 shl	 edx, cl
  0007d	83 c0 08	 add	 eax, 8
  00080	0b f2		 or	 esi, edx
  00082	43		 inc	 ebx
  00083	83 f8 14	 cmp	 eax, 20			; 00000014H
  00086	89 5c 24 14	 mov	 DWORD PTR _p$[esp+40], ebx
  0008a	72 d9		 jb	 SHORT $L1797
$L1798:

; 60   :     if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)

  0008c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ml$[esp+40]
  00090	8b 54 24 2c	 mov	 edx, DWORD PTR _tl$[esp+36]
  00094	23 ce		 and	 ecx, esi
  00096	0f b6 1c ca	 movzx	 ebx, BYTE PTR [edx+ecx*8]
  0009a	8d 14 ca	 lea	 edx, DWORD PTR [edx+ecx*8]

; 61   :     {
; 62   :       DUMPBITS(t->bits)

  0009d	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  000a1	d3 ee		 shr	 esi, cl
  000a3	85 db		 test	 ebx, ebx

; 63   :       Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
; 64   :                 "inflate:         * literal '%c'\n" :
; 65   :                 "inflate:         * literal 0x%02x\n", t->base));
; 66   :       *q++ = (Byte)t->base;
; 67   :       m--;
; 68   :       continue;

  000a5	0f 84 ac 01 00
	00		 je	 $L1898

; 69   :     }
; 70   :     do {
; 71   :       DUMPBITS(t->bits)

  000ab	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  000af	2b c1		 sub	 eax, ecx

; 72   :       if (e & 16)

  000b1	f6 c3 10	 test	 bl, 16			; 00000010H
  000b4	75 37		 jne	 SHORT $L1890
$L1803:

; 147  :       }
; 148  :       if ((e & 64) == 0)

  000b6	f6 c3 40	 test	 bl, 64			; 00000040H
  000b9	0f 85 77 02 00
	00		 jne	 $L1847

; 149  :       {
; 150  :         t += t->base;
; 151  :         if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)

  000bf	8b 0c 9d 00 00
	00 00		 mov	 ecx, DWORD PTR _inflate_mask[ebx*4]
  000c6	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  000c9	23 ce		 and	 ecx, esi
  000cb	03 cb		 add	 ecx, ebx
  000cd	0f b6 1c ca	 movzx	 ebx, BYTE PTR [edx+ecx*8]
  000d1	8d 14 ca	 lea	 edx, DWORD PTR [edx+ecx*8]
  000d4	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  000d8	d3 ee		 shr	 esi, cl
  000da	85 db		 test	 ebx, ebx
  000dc	0f 84 75 01 00
	00		 je	 $L1898
  000e2	0f b6 4a 01	 movzx	 ecx, BYTE PTR [edx+1]
  000e6	2b c1		 sub	 eax, ecx
  000e8	f6 c3 10	 test	 bl, 16			; 00000010H
  000eb	74 c9		 je	 SHORT $L1803
$L1890:

; 73   :       {
; 74   :         /* get extra bits for length */
; 75   :         e &= 15;
; 76   :         c = t->base + ((uInt)b & inflate_mask[e]);

  000ed	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  000f0	83 e3 0f	 and	 ebx, 15			; 0000000fH
  000f3	8b 0c 9d 00 00
	00 00		 mov	 ecx, DWORD PTR _inflate_mask[ebx*4]
  000fa	23 ce		 and	 ecx, esi
  000fc	03 cf		 add	 ecx, edi
  000fe	89 4c 24 24	 mov	 DWORD PTR _c$[esp+40], ecx

; 77   :         DUMPBITS(e)

  00102	8b cb		 mov	 ecx, ebx
  00104	2b c3		 sub	 eax, ebx
  00106	d3 ee		 shr	 esi, cl

; 78   :         Tracevv((stderr, "inflate:         * length %u\n", c));
; 79   : 
; 80   :         /* decode distance base of block to copy */
; 81   :         GRABBITS(15);           /* max bits for distance code */

  00108	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0010b	73 26		 jae	 SHORT $L1810
  0010d	8d 49 00	 npad	 3
$L1809:
  00110	8b 4c 24 10	 mov	 ecx, DWORD PTR _n$[esp+40]
  00114	8b 54 24 14	 mov	 edx, DWORD PTR _p$[esp+40]
  00118	0f b6 3a	 movzx	 edi, BYTE PTR [edx]
  0011b	49		 dec	 ecx
  0011c	89 4c 24 10	 mov	 DWORD PTR _n$[esp+40], ecx
  00120	8b c8		 mov	 ecx, eax
  00122	d3 e7		 shl	 edi, cl
  00124	83 c0 08	 add	 eax, 8
  00127	0b f7		 or	 esi, edi
  00129	42		 inc	 edx
  0012a	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0012d	89 54 24 14	 mov	 DWORD PTR _p$[esp+40], edx
  00131	72 dd		 jb	 SHORT $L1809
$L1810:

; 82   :         e = (t = td + ((uInt)b & md))->exop;

  00133	8b 54 24 20	 mov	 edx, DWORD PTR _md$[esp+40]
  00137	8b 4c 24 30	 mov	 ecx, DWORD PTR _td$[esp+36]
  0013b	23 d6		 and	 edx, esi
  0013d	8d 3c d1	 lea	 edi, DWORD PTR [ecx+edx*8]

; 83   :         do {
; 84   :           DUMPBITS(t->bits)

  00140	0f b6 4f 01	 movzx	 ecx, BYTE PTR [edi+1]
  00144	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00147	d3 ee		 shr	 esi, cl
  00149	2b c1		 sub	 eax, ecx

; 85   :           if (e & 16)

  0014b	f6 c2 10	 test	 dl, 16			; 00000010H
  0014e	75 2b		 jne	 SHORT $L1892
$L1813:

; 130  :             }
; 131  :             break;
; 132  :           }
; 133  :           else if ((e & 64) == 0)

  00150	f6 c2 40	 test	 dl, 64			; 00000040H
  00153	0f 85 7a 01 00
	00		 jne	 $L1842

; 134  :           {
; 135  :             t += t->base;
; 136  :             e = (t += ((uInt)b & inflate_mask[e]))->exop;

  00159	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR _inflate_mask[edx*4]
  00160	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00163	23 d6		 and	 edx, esi
  00165	03 d1		 add	 edx, ecx
  00167	0f b6 4c d7 01	 movzx	 ecx, BYTE PTR [edi+edx*8+1]
  0016c	8d 3c d7	 lea	 edi, DWORD PTR [edi+edx*8]
  0016f	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00172	d3 ee		 shr	 esi, cl
  00174	2b c1		 sub	 eax, ecx
  00176	f6 c2 10	 test	 dl, 16			; 00000010H
  00179	74 d5		 je	 SHORT $L1813
$L1892:

; 86   :           {
; 87   :             /* get extra bits to add to distance base */
; 88   :             e &= 15;

  0017b	83 e2 0f	 and	 edx, 15			; 0000000fH

; 89   :             GRABBITS(e)         /* get extra bits (up to 13) */

  0017e	3b c2		 cmp	 eax, edx
  00180	73 26		 jae	 SHORT $L1819
$L1818:
  00182	8b 5c 24 10	 mov	 ebx, DWORD PTR _n$[esp+40]
  00186	8b 4c 24 14	 mov	 ecx, DWORD PTR _p$[esp+40]
  0018a	4b		 dec	 ebx
  0018b	89 5c 24 10	 mov	 DWORD PTR _n$[esp+40], ebx
  0018f	0f b6 19	 movzx	 ebx, BYTE PTR [ecx]
  00192	8b c8		 mov	 ecx, eax
  00194	d3 e3		 shl	 ebx, cl
  00196	8b 4c 24 14	 mov	 ecx, DWORD PTR _p$[esp+40]
  0019a	83 c0 08	 add	 eax, 8
  0019d	0b f3		 or	 esi, ebx
  0019f	41		 inc	 ecx
  001a0	3b c2		 cmp	 eax, edx
  001a2	89 4c 24 14	 mov	 DWORD PTR _p$[esp+40], ecx
  001a6	72 da		 jb	 SHORT $L1818
$L1819:

; 90   :             d = t->base + ((uInt)b & inflate_mask[e]);

  001a8	8b 1c 95 00 00
	00 00		 mov	 ebx, DWORD PTR _inflate_mask[edx*4]
  001af	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 91   :             DUMPBITS(e)
; 92   :             Tracevv((stderr, "inflate:         * distance %u\n", d));
; 93   : 
; 94   :             /* do the copy */
; 95   :             m -= c;

  001b2	8b 7c 24 24	 mov	 edi, DWORD PTR _c$[esp+40]
  001b6	23 de		 and	 ebx, esi
  001b8	03 d9		 add	 ebx, ecx
  001ba	8b ca		 mov	 ecx, edx
  001bc	d3 ee		 shr	 esi, cl
  001be	29 7c 24 18	 sub	 DWORD PTR _m$[esp+40], edi

; 96   :             r = q - d;

  001c2	8b cd		 mov	 ecx, ebp
  001c4	2b cb		 sub	 ecx, ebx

; 97   :             if (r < s->window)                  /* wrap if needed */

  001c6	8b 5c 24 34	 mov	 ebx, DWORD PTR _s$[esp+36]
  001ca	2b c2		 sub	 eax, edx
  001cc	8b 53 28	 mov	 edx, DWORD PTR [ebx+40]
  001cf	3b ca		 cmp	 ecx, edx
  001d1	73 62		 jae	 SHORT $L1822
  001d3	8b 5b 2c	 mov	 ebx, DWORD PTR [ebx+44]

; 127  :               do {
; 128  :                 *q++ = *r++;

  001d6	89 5c 24 24	 mov	 DWORD PTR tv566[esp+40], ebx
  001da	2b da		 sub	 ebx, edx
  001dc	8d 64 24 00	 npad	 4
$L1823:
  001e0	03 cb		 add	 ecx, ebx
  001e2	3b ca		 cmp	 ecx, edx
  001e4	72 fa		 jb	 SHORT $L1823
  001e6	8b 54 24 24	 mov	 edx, DWORD PTR tv566[esp+40]
  001ea	2b d1		 sub	 edx, ecx
  001ec	3b fa		 cmp	 edi, edx
  001ee	76 23		 jbe	 SHORT $L1826

; 98   :             {
; 99   :               do {
; 100  :                 r += s->end - s->window;        /* force pointer in window */
; 101  :               } while (r < s->window);          /* covers invalid distances */
; 102  :               e = s->end - r;
; 103  :               if (c > e)
; 104  :               {
; 105  :                 c -= e;                         /* wrapped copy */

  001f0	2b fa		 sub	 edi, edx
$L1827:

; 106  :                 do {
; 107  :                     *q++ = *r++;

  001f2	8a 19		 mov	 bl, BYTE PTR [ecx]
  001f4	88 5d 00	 mov	 BYTE PTR [ebp], bl
  001f7	45		 inc	 ebp
  001f8	41		 inc	 ecx

; 108  :                 } while (--e);

  001f9	4a		 dec	 edx
  001fa	75 f6		 jne	 SHORT $L1827

; 109  :                 r = s->window;

  001fc	8b 54 24 34	 mov	 edx, DWORD PTR _s$[esp+36]
  00200	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
$L1830:

; 110  :                 do {
; 111  :                     *q++ = *r++;

  00203	8a 11		 mov	 dl, BYTE PTR [ecx]
  00205	88 55 00	 mov	 BYTE PTR [ebp], dl
  00208	45		 inc	 ebp
  00209	41		 inc	 ecx

; 112  :                 } while (--c);

  0020a	4f		 dec	 edi
  0020b	75 f6		 jne	 SHORT $L1830

; 113  :               }
; 114  :               else                              /* normal copy */

  0020d	8b 7c 24 38	 mov	 edi, DWORD PTR _z$[esp+36]
  00211	eb 56		 jmp	 SHORT $L1794
$L1826:

; 115  :               {
; 116  :                 *q++ = *r++;  c--;

  00213	8a 11		 mov	 dl, BYTE PTR [ecx]
  00215	88 55 00	 mov	 BYTE PTR [ebp], dl

; 117  :                 *q++ = *r++;  c--;

  00218	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0021b	45		 inc	 ebp
  0021c	41		 inc	 ecx
  0021d	88 55 00	 mov	 BYTE PTR [ebp], dl
  00220	45		 inc	 ebp
  00221	41		 inc	 ecx
  00222	83 ef 02	 sub	 edi, 2
$L1834:

; 118  :                 do {
; 119  :                     *q++ = *r++;

  00225	8a 11		 mov	 dl, BYTE PTR [ecx]
  00227	88 55 00	 mov	 BYTE PTR [ebp], dl
  0022a	45		 inc	 ebp
  0022b	41		 inc	 ecx

; 120  :                 } while (--c);

  0022c	4f		 dec	 edi
  0022d	75 f6		 jne	 SHORT $L1834

; 121  :               }
; 122  :             }
; 123  :             else                                /* normal copy */

  0022f	8b 7c 24 38	 mov	 edi, DWORD PTR _z$[esp+36]
  00233	eb 34		 jmp	 SHORT $L1794
$L1822:

; 124  :             {
; 125  :               *q++ = *r++;  c--;

  00235	8a 11		 mov	 dl, BYTE PTR [ecx]
  00237	88 55 00	 mov	 BYTE PTR [ebp], dl

; 126  :               *q++ = *r++;  c--;

  0023a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0023d	45		 inc	 ebp
  0023e	41		 inc	 ecx
  0023f	88 55 00	 mov	 BYTE PTR [ebp], dl
  00242	45		 inc	 ebp
  00243	41		 inc	 ecx
  00244	83 ef 02	 sub	 edi, 2
$L1838:

; 127  :               do {
; 128  :                 *q++ = *r++;

  00247	8a 11		 mov	 dl, BYTE PTR [ecx]
  00249	88 55 00	 mov	 BYTE PTR [ebp], dl
  0024c	45		 inc	 ebp
  0024d	41		 inc	 ecx

; 129  :               } while (--c);

  0024e	4f		 dec	 edi
  0024f	75 f6		 jne	 SHORT $L1838

; 143  :             return Z_DATA_ERROR;
; 144  :           }
; 145  :         } while (1);
; 146  :         break;

  00251	8b 7c 24 38	 mov	 edi, DWORD PTR _z$[esp+36]
  00255	eb 12		 jmp	 SHORT $L1794
$L1898:

; 152  :         {
; 153  :           DUMPBITS(t->bits)

  00257	2b c1		 sub	 eax, ecx

; 154  :           Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
; 155  :                     "inflate:         * literal '%c'\n" :
; 156  :                     "inflate:         * literal 0x%02x\n", t->base));
; 157  :           *q++ = (Byte)t->base;

  00259	8a 4a 04	 mov	 cl, BYTE PTR [edx+4]
  0025c	88 4d 00	 mov	 BYTE PTR [ebp], cl

; 158  :           m--;

  0025f	8b 4c 24 18	 mov	 ecx, DWORD PTR _m$[esp+40]
  00263	45		 inc	 ebp
  00264	49		 dec	 ecx
  00265	89 4c 24 18	 mov	 DWORD PTR _m$[esp+40], ecx
$L1794:

; 175  :       }
; 176  :     } while (1);
; 177  :   } while (m >= 258 && n >= 10);

  00269	81 7c 24 18 02
	01 00 00	 cmp	 DWORD PTR _m$[esp+40], 258 ; 00000102H
  00271	72 0b		 jb	 SHORT $L1856
  00273	83 7c 24 10 0a	 cmp	 DWORD PTR _n$[esp+40], 10 ; 0000000aH
  00278	0f 83 e2 fd ff
	ff		 jae	 $L1793
$L1856:

; 178  : 
; 179  :   /* not enough input or output--restore pointers and return */
; 180  :   UNGRAB

  0027e	8b 54 24 10	 mov	 edx, DWORD PTR _n$[esp+40]
  00282	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00285	2b ca		 sub	 ecx, edx
  00287	8b d0		 mov	 edx, eax
  00289	c1 ea 03	 shr	 edx, 3
  0028c	3b d1		 cmp	 edx, ecx
  0028e	73 02		 jae	 SHORT $L1874
  00290	8b ca		 mov	 ecx, edx
$L1874:

; 181  :   UPDATE

  00292	8b 5c 24 34	 mov	 ebx, DWORD PTR _s$[esp+36]
  00296	8b 54 24 14	 mov	 edx, DWORD PTR _p$[esp+40]
  0029a	89 73 20	 mov	 DWORD PTR [ebx+32], esi
  0029d	8d 34 cd 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*8]
  002a4	2b c6		 sub	 eax, esi
  002a6	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  002a9	8b 44 24 10	 mov	 eax, DWORD PTR _n$[esp+40]
  002ad	8b 37		 mov	 esi, DWORD PTR [edi]
  002af	2b d1		 sub	 edx, ecx
  002b1	03 c8		 add	 ecx, eax
  002b3	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  002b6	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  002b9	8b ca		 mov	 ecx, edx
  002bb	2b ce		 sub	 ecx, esi
  002bd	03 c1		 add	 eax, ecx
  002bf	89 47 08	 mov	 DWORD PTR [edi+8], eax
  002c2	89 17		 mov	 DWORD PTR [edi], edx
  002c4	5f		 pop	 edi
  002c5	5e		 pop	 esi
  002c6	89 6b 34	 mov	 DWORD PTR [ebx+52], ebp
  002c9	5d		 pop	 ebp

; 182  :   return Z_OK;

  002ca	33 c0		 xor	 eax, eax
  002cc	5b		 pop	 ebx

; 183  : }

  002cd	83 c4 18	 add	 esp, 24			; 00000018H
  002d0	c2 10 00	 ret	 16			; 00000010H
$L1842:

; 137  :           }
; 138  :           else
; 139  :           {
; 140  :             z->msg = (char*)"invalid distance code";

  002d3	8b 4c 24 38	 mov	 ecx, DWORD PTR _z$[esp+36]

; 141  :             UNGRAB

  002d7	8b 7c 24 10	 mov	 edi, DWORD PTR _n$[esp+40]
  002db	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002de	2b d7		 sub	 edx, edi
  002e0	8b f8		 mov	 edi, eax
  002e2	c1 ef 03	 shr	 edi, 3
  002e5	3b fa		 cmp	 edi, edx
  002e7	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  002ee	73 02		 jae	 SHORT $L1868
  002f0	8b d7		 mov	 edx, edi
$L1868:

; 142  :             UPDATE

  002f2	8b 5c 24 34	 mov	 ebx, DWORD PTR _s$[esp+36]
  002f6	8b 7c 24 14	 mov	 edi, DWORD PTR _p$[esp+40]
  002fa	89 73 20	 mov	 DWORD PTR [ebx+32], esi
  002fd	8d 34 d5 00 00
	00 00		 lea	 esi, DWORD PTR [edx*8]
  00304	2b c6		 sub	 eax, esi
  00306	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  00309	8b 44 24 10	 mov	 eax, DWORD PTR _n$[esp+40]
  0030d	8b 31		 mov	 esi, DWORD PTR [ecx]
  0030f	2b fa		 sub	 edi, edx
  00311	03 d0		 add	 edx, eax
  00313	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00316	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00319	8b d7		 mov	 edx, edi
  0031b	2b d6		 sub	 edx, esi
  0031d	89 39		 mov	 DWORD PTR [ecx], edi
  0031f	5f		 pop	 edi
  00320	03 c2		 add	 eax, edx
  00322	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00325	5e		 pop	 esi

; 173  :         UPDATE

  00326	89 6b 34	 mov	 DWORD PTR [ebx+52], ebp
  00329	5d		 pop	 ebp

; 174  :         return Z_DATA_ERROR;

  0032a	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0032f	5b		 pop	 ebx

; 183  : }

  00330	83 c4 18	 add	 esp, 24			; 00000018H
  00333	c2 10 00	 ret	 16			; 00000010H
$L1847:

; 159  :           break;
; 160  :         }
; 161  :       }
; 162  :       else if (e & 32)
; 163  :       {
; 164  :         Tracevv((stderr, "inflate:         * end of block\n"));
; 165  :         UNGRAB

  00336	8b 54 24 10	 mov	 edx, DWORD PTR _n$[esp+40]
  0033a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0033d	2b ca		 sub	 ecx, edx
  0033f	8b d0		 mov	 edx, eax
  00341	c1 ea 03	 shr	 edx, 3
  00344	f6 c3 20	 test	 bl, 32			; 00000020H
  00347	74 4a		 je	 SHORT $L1852
  00349	3b d1		 cmp	 edx, ecx
  0034b	73 02		 jae	 SHORT $L1870
  0034d	8b ca		 mov	 ecx, edx
$L1870:

; 166  :         UPDATE

  0034f	8b 5c 24 34	 mov	 ebx, DWORD PTR _s$[esp+36]
  00353	8b 54 24 14	 mov	 edx, DWORD PTR _p$[esp+40]
  00357	89 73 20	 mov	 DWORD PTR [ebx+32], esi
  0035a	8d 34 cd 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*8]
  00361	2b c6		 sub	 eax, esi
  00363	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  00366	8b 44 24 10	 mov	 eax, DWORD PTR _n$[esp+40]
  0036a	8b 37		 mov	 esi, DWORD PTR [edi]
  0036c	2b d1		 sub	 edx, ecx
  0036e	03 c8		 add	 ecx, eax
  00370	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00373	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00376	8b ca		 mov	 ecx, edx
  00378	2b ce		 sub	 ecx, esi
  0037a	03 c1		 add	 eax, ecx
  0037c	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0037f	89 17		 mov	 DWORD PTR [edi], edx
  00381	5f		 pop	 edi
  00382	5e		 pop	 esi

; 173  :         UPDATE

  00383	89 6b 34	 mov	 DWORD PTR [ebx+52], ebp
  00386	5d		 pop	 ebp
  00387	b8 01 00 00 00	 mov	 eax, 1
  0038c	5b		 pop	 ebx

; 183  : }

  0038d	83 c4 18	 add	 esp, 24			; 00000018H
  00390	c2 10 00	 ret	 16			; 00000010H
$L1852:

; 167  :         return Z_STREAM_END;
; 168  :       }
; 169  :       else
; 170  :       {
; 171  :         z->msg = (char*)"invalid literal/length code";
; 172  :         UNGRAB

  00393	3b d1		 cmp	 edx, ecx
  00395	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  0039c	73 02		 jae	 SHORT $L1872
  0039e	8b ca		 mov	 ecx, edx
$L1872:

; 173  :         UPDATE

  003a0	8b 5c 24 34	 mov	 ebx, DWORD PTR _s$[esp+36]
  003a4	8b 54 24 14	 mov	 edx, DWORD PTR _p$[esp+40]
  003a8	89 73 20	 mov	 DWORD PTR [ebx+32], esi
  003ab	8d 34 cd 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*8]
  003b2	2b c6		 sub	 eax, esi
  003b4	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  003b7	8b 44 24 10	 mov	 eax, DWORD PTR _n$[esp+40]
  003bb	8b 37		 mov	 esi, DWORD PTR [edi]
  003bd	2b d1		 sub	 edx, ecx
  003bf	03 c8		 add	 ecx, eax
  003c1	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003c4	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  003c7	8b ca		 mov	 ecx, edx
  003c9	2b ce		 sub	 ecx, esi
  003cb	03 c1		 add	 eax, ecx
  003cd	89 47 08	 mov	 DWORD PTR [edi+8], eax
  003d0	89 17		 mov	 DWORD PTR [edi], edx
  003d2	5f		 pop	 edi
  003d3	5e		 pop	 esi
  003d4	89 6b 34	 mov	 DWORD PTR [ebx+52], ebp
  003d7	5d		 pop	 ebp

; 174  :         return Z_DATA_ERROR;

  003d8	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  003dd	5b		 pop	 ebx

; 183  : }

  003de	83 c4 18	 add	 esp, 24			; 00000018H
  003e1	c2 10 00	 ret	 16			; 00000010H
@inflate_fast@24 ENDP
_TEXT	ENDS
END
