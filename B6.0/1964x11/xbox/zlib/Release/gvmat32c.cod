; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\gvmat32c.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _Direct3D_AddRef@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_Release@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _Direct3D_GetAdapterCount@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_BeginScene@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DDevice_EndScene@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @D3DDevice_GetRenderState@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @D3DDevice_GetTextureStageState@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @D3DDevice_SetRenderState@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @D3DDevice_SetTextureStageState@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @D3DDevice_SetVertexShaderConstant@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @D3DDevice_SetVertexShaderConstantFast@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @D3DDevice_BeginState@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @D3DDevice_EndState@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_GetBackBuffer@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreateTexture@32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreateVolumeTexture@36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreateCubeTexture@28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreateVertexBuffer@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreateIndexBuffer@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreatePalette@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreateRenderTarget@28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreateDepthStencilSurface@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreateImageSurface@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_GetRenderTarget@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_GetDepthStencilSurface@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_GetTexture@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_GetPalette@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_GetStreamSource@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_GetIndices@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_GetPersistedSurface@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreateFixup@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DDevice8_CreatePushBuffer@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DResource_MoveResourceMemory@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DTexture_UnlockRect@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DTexture8_GetSurfaceLevel@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVolumeTexture_UnlockBox@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DVolumeTexture8_GetVolumeLevel@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DCubeTexture_UnlockRect@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DCubeTexture8_GetCubeMapSurface@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVertexBuffer_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DVertexBuffer8_Lock@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DIndexBuffer_Lock@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DIndexBuffer_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DPalette_Unlock@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DPalette8_Lock@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DSurface_UnlockRect@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DSurface8_GetContainer@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DVolume_UnlockBox@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IDirect3DVolume8_GetContainer@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @match_init@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @longest_match@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @longest_match_c@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_D3DPRIMITIVETOVERTEXCOUNT
PUBLIC	_D3DSIMPLERENDERSTATEENCODE
PUBLIC	_D3DTEXTUREDIRECTENCODE
PUBLIC	_D3DDIRTYFROMRENDERSTATE
PUBLIC	_D3DDIRTYFROMTEXTURESTATE
;	COMDAT _D3DPRIMITIVETOVERTEXCOUNT
CONST	SEGMENT
_D3DPRIMITIVETOVERTEXCOUNT DD 00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	02H
	DD	04H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT _D3DSIMPLERENDERSTATEENCODE
CONST	SEGMENT
_D3DSIMPLERENDERSTATEENCODE DD 040260H
	DD	040264H
	DD	040268H
	DD	04026cH
	DD	040270H
	DD	040274H
	DD	040278H
	DD	04027cH
	DD	040288H
	DD	04028cH
	DD	040a60H
	DD	040a64H
	DD	040a68H
	DD	040a6cH
	DD	040a70H
	DD	040a74H
	DD	040a78H
	DD	040a7cH
	DD	040a80H
	DD	040a84H
	DD	040a88H
	DD	040a8cH
	DD	040a90H
	DD	040a94H
	DD	040a98H
	DD	040a9cH
	DD	040aa0H
	DD	040aa4H
	DD	040aa8H
	DD	040aacH
	DD	040ab0H
	DD	040ab4H
	DD	040ab8H
	DD	040abcH
	DD	040ac0H
	DD	040ac4H
	DD	040ac8H
	DD	040accH
	DD	040ad0H
	DD	040ad4H
	DD	040ad8H
	DD	040adcH
	DD	0417f8H
	DD	041e20H
	DD	041e24H
	DD	041e40H
	DD	041e44H
	DD	041e48H
	DD	041e4cH
	DD	041e50H
	DD	041e54H
	DD	041e58H
	DD	041e5cH
	DD	041e60H
	DD	041d90H
	DD	041e74H
	DD	041e78H
	DD	040354H
	DD	04033cH
	DD	040304H
	DD	040300H
	DD	040340H
	DD	040344H
	DD	040348H
	DD	04035cH
	DD	040310H
	DD	04037cH
	DD	040358H
	DD	040374H
	DD	040378H
	DD	040364H
	DD	040368H
	DD	04036cH
	DD	040360H
	DD	040350H
	DD	04034cH
	DD	0409f8H
	DD	040384H
	DD	040388H
	DD	040330H
	DD	040334H
	DD	040338H
	DD	041d78H
	DD	04147cH
	DD	041d90H
	DD	041d90H
	DD	041d90H
	DD	041d90H
	DD	041d90H
	DD	041d90H
	DD	041d90H
	DD	041d90H
CONST	ENDS
;	COMDAT _D3DTEXTUREDIRECTENCODE
CONST	SEGMENT
_D3DTEXTUREDIRECTENCODE DD 081b00H
	DD	081b40H
	DD	081b80H
	DD	081bc0H
CONST	ENDS
;	COMDAT _D3DDIRTYFROMRENDERSTATE
CONST	SEGMENT
_D3DDIRTYFROMRENDERSTATE DD 02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	02000H
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	01200H
	DD	03000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	01000H
	DD	0100H
	DD	0100H
	DD	0900H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	0100H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT _D3DDIRTYFROMTEXTURESTATE
CONST	SEGMENT
_D3DDIRTYFROMTEXTURESTATE DD 0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0fH
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0800H
	DD	0400H
CONST	ENDS
_DATA	SEGMENT
?iIsPPro@?1??longest_match@@9@9 DD 02H			; `longest_match'::`2'::iIsPPro
_DATA	ENDS
PUBLIC	@match_init@0
; Function compile flags: /Ogty
; File c:\documents and settings\weinerschnitzel\my documents\xbox\surreal64ce sf\trunk\b5.6\1964x11\xbox\zlib\gvmat32c.c
;	COMDAT @match_init@0
_TEXT	SEGMENT
@match_init@0 PROC NEAR					; COMDAT

; 36   : }

  00000	c3		 ret	 0
@match_init@0 ENDP
_TEXT	ENDS
PUBLIC	@longest_match_c@8
; Function compile flags: /Ogty
;	COMDAT @longest_match_c@8
_TEXT	SEGMENT
_chain_length$ = -24					; size = 4
_nice_match$ = -20					; size = 4
_scan_end$ = -16					; size = 2
_limit$ = -12						; size = 4
_scan_start$ = -8					; size = 2
tv267 = -4						; size = 4
@longest_match_c@8 PROC NEAR				; COMDAT
; _s$ = ecx
; _cur_match$ = edx

; 69   : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H

; 70   :     unsigned chain_length = s->max_chain_length;/* max hash chain length */

  00003	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00006	53		 push	 ebx

; 71   :     register Bytef *scan = s->window + s->strstart; /* current string */
; 72   :     register Bytef *match;                       /* matched string */
; 73   :     register int len;                           /* length of current match */
; 74   :     int best_len = s->prev_length;              /* best match length so far */
; 75   :     int nice_match = s->nice_match;             /* stop if match long enough */
; 76   :     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
; 77   :         s->strstart - (IPos)MAX_DIST(s) : NIL;

  00007	8b 59 24	 mov	 ebx, DWORD PTR [ecx+36]
  0000a	55		 push	 ebp
  0000b	56		 push	 esi
  0000c	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  0000f	8b ea		 mov	 ebp, edx
  00011	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  00017	57		 push	 edi
  00018	8b 79 64	 mov	 edi, DWORD PTR [ecx+100]
  0001b	89 54 24 14	 mov	 DWORD PTR _nice_match$[esp+40], edx
  0001f	8d 93 fa fe ff
	ff		 lea	 edx, DWORD PTR [ebx-262]
  00025	03 f7		 add	 esi, edi
  00027	3b fa		 cmp	 edi, edx
  00029	89 44 24 10	 mov	 DWORD PTR _chain_length$[esp+40], eax
  0002d	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  00030	76 0e		 jbe	 SHORT $L25287
  00032	2b fb		 sub	 edi, ebx
  00034	81 c7 06 01 00
	00		 add	 edi, 262		; 00000106H
  0003a	89 7c 24 1c	 mov	 DWORD PTR _limit$[esp+40], edi
  0003e	eb 08		 jmp	 SHORT $L25288
$L25287:
  00040	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _limit$[esp+40], 0
$L25288:

; 78   :     /* Stop when cur_match becomes <= limit. To simplify the code,
; 79   :      * we prevent matches with the string of window index 0.
; 80   :      */
; 81   :     Posf *prev = s->prev;
; 82   :     uInt wmask = s->w_mask;
; 83   : 
; 84   : #ifdef UNALIGNED_OK
; 85   :     /* Compare two bytes at a time. Note: this is not always beneficial.
; 86   :      * Try with and without -DUNALIGNED_OK to check.
; 87   :      */
; 88   :     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
; 89   :     register ush scan_start = *(ushf*)scan;

  00048	66 8b 3e	 mov	 di, WORD PTR [esi]
  0004b	66 89 7c 24 20	 mov	 WORD PTR _scan_start$[esp+40], di

; 90   :     register ush scan_end   = *(ushf*)(scan+best_len-1);

  00050	66 8b 7c 30 ff	 mov	 di, WORD PTR [eax+esi-1]
  00055	66 89 7c 24 18	 mov	 WORD PTR _scan_end$[esp+40], di

; 91   : #else
; 92   :     register Bytef *strend = s->window + s->strstart + MAX_MATCH;
; 93   :     register Byte scan_end1  = scan[best_len-1];
; 94   :     register Byte scan_end   = scan[best_len];
; 95   : #endif
; 96   : 
; 97   :     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
; 98   :      * It is easy to get rid of this optimization if necessary.
; 99   :      */
; 100  :     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
; 101  : 
; 102  :     /* Do not waste too much time if we already have a good match: */
; 103  :     if (s->prev_length >= s->good_match) {

  0005a	3b 81 84 00 00
	00		 cmp	 eax, DWORD PTR [ecx+132]
  00060	8d 96 01 01 00
	00		 lea	 edx, DWORD PTR [esi+257]
  00066	72 05		 jb	 SHORT $L25296

; 104  :         chain_length >>= 2;

  00068	c1 6c 24 10 02	 shr	 DWORD PTR _chain_length$[esp+40], 2
$L25296:

; 105  :     }
; 106  :     /* Do not look for matches beyond the end of the input. This is necessary
; 107  :      * to make deflate deterministic.
; 108  :      */
; 109  :     if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

  0006d	8b 79 6c	 mov	 edi, DWORD PTR [ecx+108]
  00070	39 7c 24 14	 cmp	 DWORD PTR _nice_match$[esp+40], edi
  00074	89 7c 24 24	 mov	 DWORD PTR tv267[esp+40], edi
  00078	76 06		 jbe	 SHORT $L25192
  0007a	89 7c 24 14	 mov	 DWORD PTR _nice_match$[esp+40], edi
  0007e	8b ff		 npad	 2
$L25192:

; 110  : 
; 111  :     Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
; 112  : 
; 113  :     do {
; 114  :         Assert(cur_match < s->strstart, "no future");
; 115  :         match = s->window + cur_match;

  00080	8b 79 30	 mov	 edi, DWORD PTR [ecx+48]

; 116  : 
; 117  :         /* Skip to next match if the match length cannot increase
; 118  :          * or if the match length is less than 2:
; 119  :          */
; 120  : #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
; 121  :         /* This code assumes sizeof(unsigned short) == 2. Do not use
; 122  :          * UNALIGNED_OK if your compiler uses a different size.
; 123  :          */
; 124  :         if (*(ushf*)(match+best_len-1) != scan_end ||
; 125  :             *(ushf*)match != scan_start) continue;

  00083	66 8b 5c 24 18	 mov	 bx, WORD PTR _scan_end$[esp+40]
  00088	03 fd		 add	 edi, ebp
  0008a	66 39 5c 07 ff	 cmp	 WORD PTR [edi+eax-1], bx
  0008f	75 7f		 jne	 SHORT $L25193
  00091	66 8b 5c 24 20	 mov	 bx, WORD PTR _scan_start$[esp+40]
  00096	66 39 1f	 cmp	 WORD PTR [edi], bx
  00099	75 75		 jne	 SHORT $L25193

; 126  : 
; 127  :         /* It is not necessary to compare scan[2] and match[2] since they are
; 128  :          * always equal when the other bytes match, given that the hash keys
; 129  :          * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
; 130  :          * strstart+3, +5, ... up to strstart+257. We check for insufficient
; 131  :          * lookahead only every 4th comparison; the 128th check will be made
; 132  :          * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
; 133  :          * necessary to put more guard bytes at the end of the window, or
; 134  :          * to check more often for insufficient lookahead.
; 135  :          */
; 136  :         Assert(scan[2] == match[2], "scan[2]?");
; 137  :         scan++, match++;

  0009b	46		 inc	 esi
  0009c	47		 inc	 edi
  0009d	8d 49 00	 npad	 3
$L25199:

; 138  :         do {
; 139  :         } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 140  :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 141  :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 142  :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 143  :                  scan < strend);

  000a0	66 8b 5e 02	 mov	 bx, WORD PTR [esi+2]
  000a4	83 c6 02	 add	 esi, 2
  000a7	83 c7 02	 add	 edi, 2
  000aa	66 3b 1f	 cmp	 bx, WORD PTR [edi]
  000ad	75 31		 jne	 SHORT $L25210
  000af	66 8b 5e 02	 mov	 bx, WORD PTR [esi+2]
  000b3	83 c6 02	 add	 esi, 2
  000b6	83 c7 02	 add	 edi, 2
  000b9	66 3b 1f	 cmp	 bx, WORD PTR [edi]
  000bc	75 22		 jne	 SHORT $L25210
  000be	66 8b 5e 02	 mov	 bx, WORD PTR [esi+2]
  000c2	83 c6 02	 add	 esi, 2
  000c5	83 c7 02	 add	 edi, 2
  000c8	66 3b 1f	 cmp	 bx, WORD PTR [edi]
  000cb	75 13		 jne	 SHORT $L25210
  000cd	66 8b 5e 02	 mov	 bx, WORD PTR [esi+2]
  000d1	83 c6 02	 add	 esi, 2
  000d4	83 c7 02	 add	 edi, 2
  000d7	66 3b 1f	 cmp	 bx, WORD PTR [edi]
  000da	75 04		 jne	 SHORT $L25210
  000dc	3b f2		 cmp	 esi, edx
  000de	72 c0		 jb	 SHORT $L25199
$L25210:

; 144  :         /* The funny "do {}" generates better code on most compilers */
; 145  : 
; 146  :         /* Here, scan <= window+strstart+257 */
; 147  :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 148  :         if (*scan == *match) scan++;

  000e0	8a 1e		 mov	 bl, BYTE PTR [esi]
  000e2	3a 1f		 cmp	 bl, BYTE PTR [edi]
  000e4	75 01		 jne	 SHORT $L25211
  000e6	46		 inc	 esi
$L25211:

; 149  : 
; 150  :         len = (MAX_MATCH - 1) - (int)(strend-scan);

  000e7	8b fe		 mov	 edi, esi
  000e9	2b fa		 sub	 edi, edx
  000eb	81 c7 01 01 00
	00		 add	 edi, 257		; 00000101H

; 151  :         scan = strend - (MAX_MATCH-1);
; 152  : 
; 153  : #else /* UNALIGNED_OK */
; 154  : 
; 155  :         if (match[best_len]   != scan_end  ||
; 156  :             match[best_len-1] != scan_end1 ||
; 157  :             *match            != *scan     ||
; 158  :             *++match          != scan[1])      continue;
; 159  : 
; 160  :         /* The check at best_len-1 can be removed because it will be made
; 161  :          * again later. (This heuristic is not always a win.)
; 162  :          * It is not necessary to compare scan[2] and match[2] since they
; 163  :          * are always equal when the other bytes match, given that
; 164  :          * the hash keys are equal and that HASH_BITS >= 8.
; 165  :          */
; 166  :         scan += 2, match++;
; 167  :         Assert(*scan == *match, "match[2]?");
; 168  : 
; 169  :         /* We check for insufficient lookahead only every 8th comparison;
; 170  :          * the 256th check will be made at strstart+258.
; 171  :          */
; 172  :         do {
; 173  :         } while (*++scan == *++match && *++scan == *++match &&
; 174  :                  *++scan == *++match && *++scan == *++match &&
; 175  :                  *++scan == *++match && *++scan == *++match &&
; 176  :                  *++scan == *++match && *++scan == *++match &&
; 177  :                  scan < strend);
; 178  : 
; 179  :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 180  : 
; 181  :         len = MAX_MATCH - (int)(strend - scan);
; 182  :         scan = strend - MAX_MATCH;
; 183  : 
; 184  : #endif /* UNALIGNED_OK */
; 185  : 
; 186  :         if (len > best_len) {

  000f1	3b f8		 cmp	 edi, eax
  000f3	8d b2 ff fe ff
	ff		 lea	 esi, DWORD PTR [edx-257]
  000f9	7e 15		 jle	 SHORT $L25193

; 187  :             s->match_start = cur_match;
; 188  :             best_len = len;
; 189  :             if (len >= nice_match) break;

  000fb	3b 7c 24 14	 cmp	 edi, DWORD PTR _nice_match$[esp+40]
  000ff	89 69 68	 mov	 DWORD PTR [ecx+104], ebp
  00102	8b c7		 mov	 eax, edi
  00104	7d 26		 jge	 SHORT $L25194

; 190  : #ifdef UNALIGNED_OK
; 191  :             scan_end = *(ushf*)(scan+best_len-1);

  00106	66 8b 7c 37 ff	 mov	 di, WORD PTR [edi+esi-1]
  0010b	66 89 7c 24 18	 mov	 WORD PTR _scan_end$[esp+40], di
$L25193:

; 192  : #else
; 193  :             scan_end1  = scan[best_len-1];
; 194  :             scan_end   = scan[best_len];
; 195  : #endif
; 196  :         }
; 197  :     } while ((cur_match = prev[cur_match & wmask]) > limit
; 198  :              && --chain_length != 0);

  00110	8b 59 2c	 mov	 ebx, DWORD PTR [ecx+44]
  00113	8b 79 38	 mov	 edi, DWORD PTR [ecx+56]
  00116	23 dd		 and	 ebx, ebp
  00118	0f b7 2c 5f	 movzx	 ebp, WORD PTR [edi+ebx*2]
  0011c	3b 6c 24 1c	 cmp	 ebp, DWORD PTR _limit$[esp+40]
  00120	76 0a		 jbe	 SHORT $L25194
  00122	ff 4c 24 10	 dec	 DWORD PTR _chain_length$[esp+40]
  00126	0f 85 54 ff ff
	ff		 jne	 $L25192
$L25194:

; 199  : 
; 200  :     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;

  0012c	8b 4c 24 24	 mov	 ecx, DWORD PTR tv267[esp+40]
  00130	3b c1		 cmp	 eax, ecx
  00132	5f		 pop	 edi
  00133	5e		 pop	 esi
  00134	5d		 pop	 ebp
  00135	5b		 pop	 ebx
  00136	76 02		 jbe	 SHORT $L25172

; 201  :     return s->lookahead;

  00138	8b c1		 mov	 eax, ecx
$L25172:

; 202  : }

  0013a	83 c4 18	 add	 esp, 24			; 00000018H
  0013d	c3		 ret	 0
@longest_match_c@8 ENDP
_TEXT	ENDS
PUBLIC	@longest_match@8
EXTRN	_cpudetect32:NEAR
EXTRN	_longest_match_7fff:NEAR
; Function compile flags: /Ogty
;	COMDAT @longest_match@8
_TEXT	SEGMENT
@longest_match@8 PROC NEAR				; COMDAT
; _s$ = ecx
; _cur_match$ = edx

; 52   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 53   : 	static uInt iIsPPro=2;
; 54   : 
; 55   :     if ((s->w_mask == 0x7fff) && (iIsPPro==0))

  00003	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00006	57		 push	 edi
  00007	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iIsPPro@?1??longest_match@@9@9
  00011	8b fa		 mov	 edi, edx
  00013	75 11		 jne	 SHORT $L25167
  00015	85 c0		 test	 eax, eax
  00017	75 0d		 jne	 SHORT $L25167

; 56   :         return longest_match_7fff(s,cur_match);

  00019	57		 push	 edi
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _longest_match_7fff
  00020	83 c4 08	 add	 esp, 8
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi

; 62   : }

  00025	c3		 ret	 0
$L25167:

; 57   : 
; 58   : 	if (iIsPPro==2)

  00026	83 f8 02	 cmp	 eax, 2
  00029	75 17		 jne	 SHORT $L25168

; 59   : 		iIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;

  0002b	e8 00 00 00 00	 call	 _cpudetect32
  00030	25 00 0f 00 00	 and	 eax, 3840		; 00000f00H
  00035	3d 00 06 00 00	 cmp	 eax, 1536		; 00000600H
  0003a	1b c0		 sbb	 eax, eax
  0003c	40		 inc	 eax
  0003d	a3 00 00 00 00	 mov	 DWORD PTR ?iIsPPro@?1??longest_match@@9@9, eax
$L25168:

; 60   : 
; 61   : 	return longest_match_c(s,cur_match);

  00042	8b d7		 mov	 edx, edi
  00044	5f		 pop	 edi
  00045	8b ce		 mov	 ecx, esi
  00047	5e		 pop	 esi
  00048	e9 00 00 00 00	 jmp	 @longest_match_c@8
@longest_match@8 ENDP
_TEXT	ENDS
END
